<!DOCTYPE html>
<!--
Doodle2.0 - Recombinatorial MetaMedium Drawing System
A shape recognition and composition teaching interface

FEATURES:
- Draw shapes on canvas with automatic recognition
- Geometric type system (Point, Segment, Angle, Polygon, Circle)
- Shape library with built-in primitives (Circle, Line, Rectangle, Triangle)
- Save custom shapes and compositions to library
- Spatial relationship detection (intersection, containment, proximity)
- Composition matching (recognize patterns you've taught)
- Refinement controls (smooth, simplify, normalize)
- Debug mode for visualizing geometric relationships
- Undo/Redo system with keyboard shortcuts
- Semantic query API for programmatic access

KEYBOARD SHORTCUTS:
- Ctrl+Z: Undo
- Ctrl+Shift+Z: Redo
- Enter: Accept top suggestion
- Escape: Clear selection

JOHN HANACEK, JHDESIGN LLC
-->
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Doodle2.0 - Recombinatorial MetaMedium Drawing System</title>
    <style>
        * {
            box-sizing: border-box;
        }

        body {
            margin: 0;
            padding: 0;
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', 'Roboto', sans-serif;
            background: #4A4A4A;
            color: #E0E0E0;
            overflow: hidden;
        }

        .app {
            height: 100vh;
            display: flex;
            flex-direction: column;
        }

        /* Header */
        .app-header {
            background: #3A3A3A;
            padding: 8px 20px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            flex-shrink: 0;
            border-bottom: 1px solid #555;
        }

        .header-left {
            display: flex;
            align-items: baseline;
            gap: 12px;
        }

        .app-header h1 {
            margin: 0;
            font-size: 22px;
            color: #FBBF24;
            font-weight: 700;
        }

        .app-header .subtitle {
            margin: 0;
            font-size: 11px;
            color: #999;
        }

        .header-right .copyright {
            font-size: 11px;
            color: #FBBF24;
        }

        /* Main Content Area */
        .app-content {
            flex: 1;
            display: flex;
            flex-direction: column;
            min-height: 0;
            overflow: hidden;
        }

        /* Main Workspace (3-column) */
        .main-workspace {
            display: flex;
            flex: 1;
            min-height: 0;
            overflow: hidden;
        }

        /* Metrics Panel (left, toggleable) */
        .metrics-panel {
            width: 200px;
            background: #3A3A3A;
            padding: 12px;
            overflow-y: auto;
            flex-shrink: 0;
            display: none; /* Hidden by default */
            flex-direction: column;
            border-right: 1px solid #555;
        }

        .metrics-panel.visible {
            display: flex;
        }

        .metrics-panel h2 {
            margin: 0 0 12px 0;
            font-size: 14px;
            font-weight: 600;
            color: #E0E0E0;
        }

        .metrics-section {
            margin-bottom: 16px;
        }

        .metrics-section h3 {
            margin: 0 0 8px 0;
            font-size: 12px;
            font-weight: 600;
            color: #999;
        }

        .metric-item {
            display: flex;
            justify-content: space-between;
            padding: 4px 0;
            border-bottom: 1px solid #505050;
            font-size: 11px;
        }

        .metric-label {
            color: #B0B0B0;
        }

        .metric-value {
            color: #FFFFFF;
            font-weight: 600;
            font-family: 'Courier New', monospace;
        }

        .condition-check {
            margin: 6px 0;
            padding: 6px 10px;
            border-radius: 4px;
            font-size: 11px;
        }

        .condition-check.pass {
            background: rgba(74, 222, 128, 0.15);
            border-left: 3px solid #4ade80;
        }

        .condition-check.fail {
            background: rgba(239, 68, 68, 0.15);
            border-left: 3px solid #ef4444;
        }

        .condition-check .shape-name {
            font-weight: 600;
            margin-bottom: 2px;
        }

        .condition-check .reason {
            color: #999;
            font-size: 10px;
        }

        .no-stroke-message {
            padding: 16px;
            text-align: center;
            color: #888;
            font-style: italic;
            font-size: 12px;
        }

        /* Center - Canvas */
        .canvas-container {
            flex: 1;
            display: flex;
            flex-direction: column;
            min-width: 0;
            min-height: 0;
            padding: 8px;
        }

        .canvas-wrapper {
            background: white;
            border-radius: 4px;
            display: flex;
            flex-direction: column;
            flex: 1;
            width: 100%;
            min-width: 0;
            min-height: 0;
            overflow: hidden;
        }

        canvas {
            border: none;
            background: white;
            cursor: crosshair;
            display: block;
            flex: 1;
            width: 100%;
        }

        .canvas-input {
            width: 100%;
            padding: 10px 14px;
            font-size: 13px;
            border: none;
            border-top: 1px solid #E0E0E0;
            outline: none;
            font-family: inherit;
            background: #f9f9f9;
            color: #999;
        }

        .canvas-input::placeholder {
            color: #bbb;
        }

        .canvas-input:focus {
            background: #fff;
            color: #333;
        }

        /* Right panel - Recognition */
        .recognition-panel {
            width: 200px;
            background: #3A3A3A;
            padding: 12px;
            overflow-y: auto;
            flex-shrink: 0;
            display: flex;
            flex-direction: column;
            border-left: 1px solid #555;
        }

        .recognition-panel h2 {
            margin: 0 0 12px 0;
            font-size: 14px;
            font-weight: 600;
            color: #E0E0E0;
        }

        .recognition-status {
            padding: 10px 12px;
            background: #555;
            border-radius: 4px;
            margin-bottom: 12px;
            text-align: center;
            font-size: 12px;
            color: #ccc;
        }

        .fuzzy-match-container {
            margin-bottom: 12px;
            display: flex;
            flex-direction: column;
            gap: 4px;
        }

        .fuzzy-match-container label {
            font-size: 11px;
            font-weight: 600;
            color: #999;
        }

        .fuzzy-match-container input {
            padding: 8px 10px;
            border: 1px solid #555;
            border-radius: 4px;
            font-size: 12px;
            background: #4A4A4A;
            color: #E0E0E0;
        }

        .fuzzy-match-container input:focus {
            outline: none;
            border-color: #8B5CF6;
        }

        .suggestions {
            display: flex;
            flex-direction: column;
            gap: 6px;
        }

        .suggestion-button {
            padding: 10px 12px;
            border: 1px solid #555;
            border-radius: 4px;
            background: #4A4A4A;
            cursor: pointer;
            text-align: left;
            transition: all 0.15s ease;
            display: flex;
            flex-direction: column;
            gap: 2px;
        }

        .suggestion-button:hover {
            border-color: #8B5CF6;
            background: #555;
        }

        .suggestion-button .label {
            font-size: 13px;
            font-weight: 600;
            color: #E0E0E0;
        }

        .suggestion-button .confidence {
            font-size: 11px;
            color: #999;
        }

        .suggestion-button .confidence.high {
            color: #4ade80;
        }

        .suggestion-button .confidence.medium {
            color: #fbbf24;
        }

        .something-else-button {
            padding: 10px 12px;
            border: 1px solid #8B5CF6;
            border-radius: 4px;
            background: transparent;
            cursor: pointer;
            text-align: center;
            color: #8B5CF6;
            font-weight: 600;
            font-size: 12px;
            transition: all 0.15s ease;
        }

        .something-else-button:hover:not(.disabled) {
            background: rgba(139, 92, 246, 0.1);
        }

        .something-else-button.disabled {
            opacity: 0.4;
            cursor: not-allowed;
            border-color: #666;
            color: #666;
        }

        /* Library Row (horizontal scrollable) */
        .library-row {
            background: #3A3A3A;
            padding: 8px 12px;
            border-top: 1px solid #555;
            overflow-x: auto;
            overflow-y: hidden;
            flex-shrink: 0;
            display: none; /* Hidden by default */
        }

        .library-row.visible {
            display: block;
        }

        .library-items {
            display: flex;
            gap: 10px;
            min-width: min-content;
        }

        .library-item {
            background: #4A4A4A;
            border: 1px solid #666;
            border-radius: 6px;
            padding: 8px;
            cursor: pointer;
            transition: all 0.15s ease;
            display: flex;
            flex-direction: column;
            gap: 4px;
            min-width: 90px;
            flex-shrink: 0;
            position: relative;
        }

        .library-item.builtin {
            border-color: #8B5CF6;
        }

        .library-item:hover {
            border-color: #8B5CF6;
            background: #555;
        }

        .library-item-thumbnail {
            width: 70px;
            height: 50px;
            background: #fff;
            border-radius: 4px;
            display: flex;
            align-items: center;
            justify-content: center;
            overflow: hidden;
        }

        .library-item-thumbnail canvas {
            max-width: 100%;
            max-height: 100%;
            object-fit: contain;
        }

        .library-item-info {
            display: flex;
            flex-direction: column;
            gap: 1px;
        }

        .library-item-label {
            font-size: 11px;
            font-weight: 600;
            color: #E0E0E0;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }

        .library-item-meta {
            font-size: 9px;
            color: #999;
        }

        .delete-button {
            position: absolute;
            top: 2px;
            right: 2px;
            width: 16px;
            height: 16px;
            padding: 0;
            font-size: 12px;
            line-height: 14px;
            background: rgba(239, 68, 68, 0.9);
            color: white;
            border: none;
            border-radius: 50%;
            cursor: pointer;
            opacity: 0;
            transition: opacity 0.15s ease;
        }

        .library-item:hover .delete-button {
            opacity: 1;
        }

        .empty-message {
            font-size: 11px;
            color: #888;
            font-style: italic;
            padding: 8px;
        }

        /* Bottom Toolbar */
        .bottom-toolbar {
            background: #3A3A3A;
            padding: 8px 12px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            gap: 12px;
            border-top: 1px solid #555;
            flex-shrink: 0;
            flex-wrap: wrap;
        }

        .toolbar-left, .toolbar-right {
            display: flex;
            align-items: center;
            gap: 8px;
            flex-wrap: wrap;
        }

        .toolbar-btn {
            padding: 6px 12px;
            font-size: 12px;
            font-weight: 600;
            background: #555;
            color: #E0E0E0;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            transition: all 0.15s ease;
            white-space: nowrap;
        }

        .toolbar-btn:hover {
            background: #666;
        }

        .toolbar-btn.primary {
            background: #8B5CF6;
            color: white;
        }

        .toolbar-btn.primary:hover {
            background: #7C3AED;
        }

        .toolbar-btn.warning {
            background: #FBBF24;
            color: #1F2937;
        }

        .toolbar-btn.warning:hover {
            background: #F59E0B;
        }

        .toolbar-btn.toggle-btn {
            min-width: 80px;
        }

        .toolbar-btn.toggle-btn.active {
            background: #4ade80;
            color: #1F2937;
        }

        .toolbar-info {
            font-size: 12px;
            color: #999;
            padding: 0 8px;
        }

        .canvas-looks-like {
            display: flex;
            align-items: center;
            gap: 6px;
            font-size: 11px;
            padding: 4px 8px;
            background: #4A4A4A;
            border-radius: 4px;
        }

        .looks-like-label {
            color: #888;
        }

        .looks-like-list {
            color: #8B5CF6;
            font-weight: 600;
        }

        .looks-like-list.empty {
            color: #666;
        }

        .refinement-control {
            display: flex;
            gap: 6px;
            align-items: center;
        }

        .refinement-control label {
            font-size: 11px;
            color: #999;
            white-space: nowrap;
        }

        .refinement-control input[type="range"] {
            width: 60px;
            height: 4px;
            border-radius: 2px;
            background: #555;
            outline: none;
            -webkit-appearance: none;
        }

        .refinement-control input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            width: 12px;
            height: 12px;
            border-radius: 50%;
            background: #8B5CF6;
            cursor: pointer;
        }

        .refinement-control input[type="checkbox"] {
            cursor: pointer;
            accent-color: #8B5CF6;
        }

        .slider-value {
            font-size: 11px;
            color: #E0E0E0;
            font-weight: 600;
            min-width: 14px;
            text-align: center;
        }

        /* Save Primitive Container */
        .save-primitive-container {
            display: none;
            gap: 8px;
            align-items: center;
            padding: 8px 12px;
            background: rgba(74, 222, 128, 0.1);
            border: 1px solid #4ade80;
            border-radius: 4px;
            margin: 0 12px 8px 12px;
        }

        .save-primitive-container.active {
            display: flex;
        }

        .save-primitive-container label {
            font-size: 12px;
            color: #E0E0E0;
            white-space: nowrap;
        }

        .save-primitive-container input {
            flex: 1;
            padding: 6px 10px;
            border: 1px solid #555;
            border-radius: 4px;
            font-size: 12px;
            background: #4A4A4A;
            color: #E0E0E0;
        }

        .save-primitive-container input:focus {
            outline: none;
            border-color: #4ade80;
        }

        .save-primitive-container button {
            padding: 6px 12px;
            font-size: 12px;
            font-weight: 600;
            border: none;
            border-radius: 4px;
            cursor: pointer;
        }

        .save-primitive-container .confirm-save {
            background: #4ade80;
            color: #1F2937;
        }

        .save-primitive-container .cancel-save {
            background: #555;
            color: #E0E0E0;
        }
    </style>
</head>

<body>
    <div class="app">
        <header class="app-header">
            <div class="header-left">
                <h1>Doodle2.0</h1>
                <p class="subtitle">Recombinatorial MetaMedium Drawing System <a href="https://jjh111.github.io/MetaMedium/MetaMedium_Whitepaper_v4.html">Whitepaper</a>This demo is being depreciated in favor of<a href="https://jjh111.github.io/MetaMedium/doodle2-canvas.html">MetaMedium Canvas</a></p>
            </div>
            <div class="header-right">
                <span class="copyright">JOHN HANACEK, JHDESIGN LLC</span>
            </div>
        </header>

        <div class="app-content">
            <!-- Main Workspace Row -->
            <div class="main-workspace">
                <!-- Left: Metrics Panel (toggleable) -->
                <div class="metrics-panel" id="metricsPanel">
                    <h2>Recognition Metrics</h2>
                    <div id="metricsContent" class="no-stroke-message">
                        Draw a stroke to see metrics...
                    </div>
                </div>

                <!-- Center: Canvas -->
                <div class="canvas-container">
                    <div class="canvas-wrapper">
                        <canvas id="canvas"></canvas>
                        <input type="text" id="canvasInput" class="canvas-input"
                            placeholder="Placeholder Command Area" autocomplete="off">
                    </div>
                </div>

                <!-- Right: Recognition Panel -->
                <div class="recognition-panel">
                    <h2>Suggestions</h2>

                    <div id="recognitionStatus" class="recognition-status">
                        Waiting for stroke...
                    </div>

                    <!-- Fuzzy Match Input -->
                    <div class="fuzzy-match-container">
                        <label for="fuzzyMatchInput">Force match:</label>
                        <input type="text" id="fuzzyMatchInput" placeholder="Type shape name..." />
                    </div>

                    <div id="suggestions" class="suggestions">
                        <button class="something-else-button disabled">Something else</button>
                    </div>
                </div>
            </div>

            <!-- Library Row (horizontal scrollable) -->
            <div class="library-row">
                <div id="libraryGrid" class="library-items"></div>
            </div>

            <!-- Bottom Toolbar -->
            <div class="bottom-toolbar">
                <div class="toolbar-left">
                    <button id="showLibraryBtn" class="toolbar-btn">Show Library</button>
                    <button id="showMetricsBtn" class="toolbar-btn">Show Metrics</button>
                    <button id="saveToLibraryBtn" class="toolbar-btn primary">Save to Library</button>
                    <button id="clearBtn" class="toolbar-btn warning">Clear Canvas</button>
                    <button id="exportLibraryBtn" class="toolbar-btn">Export</button>
                    <span class="toolbar-info">Strokes: <span id="strokeCount">0</span> | Accepted: <span id="acceptedCount">0</span></span>
                    <div id="canvasLooksLike" class="canvas-looks-like">
                        <span class="looks-like-label">Canvas looks like:</span>
                        <span id="looksLikeList" class="looks-like-list">—</span>
                    </div>
                </div>
                <div class="toolbar-right">
                    <button id="debugToggleBtn" class="toolbar-btn toggle-btn">Debug Off</button>
                    <button id="refinementToggle" class="toolbar-btn toggle-btn">Refine Off</button>
                    <div class="refinement-control">
                        <label for="smoothSlider">Smooth</label>
                        <input type="range" id="smoothSlider" min="0" max="10" value="2" step="1">
                        <span id="smoothValue" class="slider-value">2</span>
                    </div>
                    <div class="refinement-control">
                        <label for="simplifySlider">Simplify</label>
                        <input type="range" id="simplifySlider" min="0" max="10" value="2" step="1">
                        <span id="simplifyValue" class="slider-value">2</span>
                    </div>
                    <div class="refinement-control">
                        <label for="normalizeToggle">Normalize</label>
                        <input type="checkbox" id="normalizeToggle">
                    </div>
                </div>
            </div>

            <!-- Hidden: Save Primitive UI (appears when saving) -->
            <div id="savePrimitiveContainer" class="save-primitive-container">
                <label>Save current stroke as:</label>
                <input type="text" id="primitiveNameInput" placeholder="Enter shape name..." />
                <button id="confirmSaveBtn" class="confirm-save">Save</button>
                <button id="cancelSaveBtn" class="cancel-save">Cancel</button>
            </div>
        </div>

        <script>
            console.log('Doodle2.0 loading...');

            // ===== GEOMETRIC TYPE SYSTEM (Day 5) =====
            // Formal geometric primitives and utilities
            // Everything in the system derives from these foundational types

            // POINT - The atomic geometric primitive
            function Point(x, y) {
                return {
                    type: 'point',
                    x: x,
                    y: y
                };
            }

            function distance(p1, p2) {
                const dx = p2.x - p1.x;
                const dy = p2.y - p1.y;
                return Math.sqrt(dx * dx + dy * dy);
            }

            function midpoint(p1, p2) {
                return Point(
                    (p1.x + p2.x) / 2,
                    (p1.y + p2.y) / 2
                );
            }

            // SEGMENT - Line segment between two points
            function Segment(start, end) {
                const len = distance(start, end);
                const dx = end.x - start.x;
                const dy = end.y - start.y;

                return {
                    type: 'segment',
                    start: start,
                    end: end,
                    length: len,
                    midpoint: midpoint(start, end),
                    slope: dx !== 0 ? dy / dx : Infinity,
                    angle: Math.atan2(dy, dx) // radians
                };
            }

            // ANGLE - Angle formed by three points
            function Angle(arm1, vertex, arm2) {
                // Vector from vertex to arm1
                const v1x = arm1.x - vertex.x;
                const v1y = arm1.y - vertex.y;

                // Vector from vertex to arm2
                const v2x = arm2.x - vertex.x;
                const v2y = arm2.y - vertex.y;

                // Calculate angle using atan2
                const angle1 = Math.atan2(v1y, v1x);
                const angle2 = Math.atan2(v2y, v2x);

                let radians = angle2 - angle1;

                // Normalize to [0, 2π]
                if (radians < 0) radians += Math.PI * 2;
                if (radians > Math.PI * 2) radians -= Math.PI * 2;

                const degrees = radians * (180 / Math.PI);

                // Classify angle
                let classification;
                if (Math.abs(degrees) < 0.1 || Math.abs(degrees - 360) < 0.1) {
                    classification = 'zero';
                } else if (degrees < 90) {
                    classification = 'acute';
                } else if (Math.abs(degrees - 90) < 0.1) {
                    classification = 'right';
                } else if (degrees < 180) {
                    classification = 'obtuse';
                } else if (Math.abs(degrees - 180) < 0.1) {
                    classification = 'straight';
                } else {
                    classification = 'reflex';
                }

                return {
                    type: 'angle',
                    vertex: vertex,
                    arm1: arm1,
                    arm2: arm2,
                    radians: radians,
                    degrees: degrees,
                    classification: classification
                };
            }

            // CIRCLE - Formal circle definition
            function Circle(center, radius) {
                return {
                    type: 'circle',
                    center: center,
                    radius: radius,
                    circumference: 2 * Math.PI * radius,
                    area: Math.PI * radius * radius,
                    diameter: radius * 2
                };
            }

            // ELLIPSE - Formal ellipse definition (stretched circle)
            // FUTURE: Can be transformed into Circle when radiusX ≈ radiusY
            function Ellipse(center, radiusX, radiusY, rotation = 0) {
                // rotation in radians (0 = horizontal major axis)
                const a = Math.max(radiusX, radiusY); // Semi-major axis
                const b = Math.min(radiusX, radiusY); // Semi-minor axis
                const eccentricity = Math.sqrt(1 - (b * b) / (a * a));

                return {
                    type: 'ellipse',
                    center: center,
                    radiusX: radiusX,
                    radiusY: radiusY,
                    rotation: rotation,
                    majorAxis: a * 2,
                    minorAxis: b * 2,
                    eccentricity: eccentricity,
                    // Approximate circumference (Ramanujan formula)
                    circumference: Math.PI * (3 * (a + b) - Math.sqrt((3 * a + b) * (a + 3 * b))),
                    area: Math.PI * radiusX * radiusY
                };
            }

            // ARC - Formal arc definition (partial circle)
            // FUTURE: Can be transformed into Circle (full arc) or Line (flat arc)
            function Arc(center, radius, startAngle, endAngle) {
                // Angles in radians, measured counter-clockwise from positive X axis
                // Normalize angles to [0, 2π)
                startAngle = startAngle % (Math.PI * 2);
                endAngle = endAngle % (Math.PI * 2);
                if (startAngle < 0) startAngle += Math.PI * 2;
                if (endAngle < 0) endAngle += Math.PI * 2;

                // Calculate sweep angle
                let sweep = endAngle - startAngle;
                if (sweep < 0) sweep += Math.PI * 2;

                // Calculate endpoints
                const startPoint = Point(
                    center.x + radius * Math.cos(startAngle),
                    center.y + radius * Math.sin(startAngle)
                );
                const endPoint = Point(
                    center.x + radius * Math.cos(endAngle),
                    center.y + radius * Math.sin(endAngle)
                );

                // Calculate midpoint (point on arc at middle angle)
                const midAngle = startAngle + sweep / 2;
                const midPoint = Point(
                    center.x + radius * Math.cos(midAngle),
                    center.y + radius * Math.sin(midAngle)
                );

                // Arc length
                const arcLength = radius * sweep;

                // Chord length (straight line distance between endpoints)
                const chordLength = 2 * radius * Math.sin(sweep / 2);

                return {
                    type: 'arc',
                    center: center,
                    radius: radius,
                    startAngle: startAngle,
                    endAngle: endAngle,
                    sweep: sweep,
                    startPoint: startPoint,
                    endPoint: endPoint,
                    midPoint: midPoint,
                    arcLength: arcLength,
                    chordLength: chordLength,
                    // Useful for conversion detection
                    isNearlyComplete: sweep > Math.PI * 1.9, // Almost a full circle
                    isNearlyFlat: sweep < Math.PI * 0.1      // Almost a straight line
                };
            }

            // POLYGON - Formal polygon from vertices
            function Polygon(vertices, closed = true) {
                if (!vertices || vertices.length < 2) {
                    return null;
                }

                // Calculate sides
                const sides = [];
                for (let i = 0; i < vertices.length - 1; i++) {
                    sides.push(Segment(vertices[i], vertices[i + 1]));
                }
                if (closed && vertices.length > 2) {
                    sides.push(Segment(vertices[vertices.length - 1], vertices[0]));
                }

                // Calculate angles (for closed polygons)
                const angles = [];
                if (closed && vertices.length > 2) {
                    for (let i = 0; i < vertices.length; i++) {
                        const prev = vertices[(i - 1 + vertices.length) % vertices.length];
                        const curr = vertices[i];
                        const next = vertices[(i + 1) % vertices.length];
                        angles.push(Angle(prev, curr, next));
                    }
                }

                // Calculate perimeter
                const perimeter = sides.reduce((sum, side) => sum + side.length, 0);

                // Calculate area using shoelace formula (for closed polygons)
                let area = 0;
                if (closed && vertices.length > 2) {
                    for (let i = 0; i < vertices.length; i++) {
                        const j = (i + 1) % vertices.length;
                        area += vertices[i].x * vertices[j].y;
                        area -= vertices[j].x * vertices[i].y;
                    }
                    area = Math.abs(area) / 2;
                }

                // Calculate centroid
                let centroidX = 0, centroidY = 0;
                vertices.forEach(v => {
                    centroidX += v.x;
                    centroidY += v.y;
                });
                const centroid = Point(centroidX / vertices.length, centroidY / vertices.length);

                // Check if convex (for closed polygons with 3+ vertices)
                let isConvex = null;
                if (closed && vertices.length >= 3) {
                    isConvex = true;
                    const n = vertices.length;
                    let sign = null;

                    for (let i = 0; i < n; i++) {
                        const p1 = vertices[i];
                        const p2 = vertices[(i + 1) % n];
                        const p3 = vertices[(i + 2) % n];

                        const cross = (p2.x - p1.x) * (p3.y - p2.y) - (p2.y - p1.y) * (p3.x - p2.x);

                        if (Math.abs(cross) > 0.001) { // Ignore near-zero cross products
                            if (sign === null) {
                                sign = cross > 0;
                            } else if ((cross > 0) !== sign) {
                                isConvex = false;
                                break;
                            }
                        }
                    }
                }

                return {
                    type: 'polygon',
                    vertices: vertices,
                    sides: sides,
                    angles: angles,
                    closed: closed,
                    perimeter: perimeter,
                    area: area,
                    centroid: centroid,
                    isConvex: isConvex,
                    vertexCount: vertices.length
                };
            }

            // Helper: Convert raw points to Points
            function pointsFromRaw(rawPoints) {
                return rawPoints.map(p => Point(p.x, p.y));
            }

            // Helper: Calculate bounding box from points
            function boundsFromPoints(points) {
                if (!points || points.length === 0) return null;

                let minX = Infinity, maxX = -Infinity;
                let minY = Infinity, maxY = -Infinity;

                points.forEach(p => {
                    if (p.x < minX) minX = p.x;
                    if (p.x > maxX) maxX = p.x;
                    if (p.y < minY) minY = p.y;
                    if (p.y > maxY) maxY = p.y;
                });

                return { minX, maxX, minY, maxY };
            }

            // ===== CONVEX HULL & POLYGON ALGORITHMS =====
            // Robust geometric algorithms for accurate corner detection

            function convexHull(points) {
                // Graham scan algorithm for convex hull
                // Returns vertices of convex hull in counter-clockwise order

                if (!points || points.length < 3) return points;

                // Convert to Points if needed
                const pts = points.map(p => p.type === 'point' ? p : Point(p.x, p.y));

                // Find the bottom-most point (and leftmost if tie)
                let start = pts[0];
                for (let i = 1; i < pts.length; i++) {
                    if (pts[i].y < start.y || (pts[i].y === start.y && pts[i].x < start.x)) {
                        start = pts[i];
                    }
                }

                // Sort points by polar angle with respect to start point
                const sorted = pts.filter(p => p !== start).sort((a, b) => {
                    const angleA = Math.atan2(a.y - start.y, a.x - start.x);
                    const angleB = Math.atan2(b.y - start.y, b.x - start.x);

                    if (angleA !== angleB) return angleA - angleB;

                    // If same angle, closer point comes first
                    const distA = distance(start, a);
                    const distB = distance(start, b);
                    return distA - distB;
                });

                // Build hull
                const hull = [start, sorted[0]];

                for (let i = 1; i < sorted.length; i++) {
                    let top = hull[hull.length - 1];
                    let middle = hull[hull.length - 2];

                    // Remove points that make clockwise turn
                    while (hull.length > 1 && ccw(middle, top, sorted[i]) <= 0) {
                        hull.pop();
                        top = hull[hull.length - 1];
                        middle = hull[hull.length - 2];
                    }

                    hull.push(sorted[i]);
                }

                return hull;
            }

            function ccw(p1, p2, p3) {
                // Counter-clockwise test
                // Returns > 0 if counter-clockwise, < 0 if clockwise, 0 if collinear
                return (p2.x - p1.x) * (p3.y - p1.y) - (p2.y - p1.y) * (p3.x - p1.x);
            }

            function findCorners(points, targetCount, angleThreshold = Math.PI * 0.75) {
                // Find the N most prominent corners in a polygon
                // Uses angle analysis to identify sharpest turns

                if (!points || points.length < targetCount) return points;

                const hull = convexHull(points);
                if (hull.length <= targetCount) return hull;

                // Calculate angles at each hull vertex
                const corners = [];
                for (let i = 0; i < hull.length; i++) {
                    const prev = hull[(i - 1 + hull.length) % hull.length];
                    const curr = hull[i];
                    const next = hull[(i + 1) % hull.length];

                    const angle = Angle(prev, curr, next);

                    corners.push({
                        point: curr,
                        angle: angle.radians,
                        sharpness: Math.PI - angle.radians, // How far from straight (π)
                        index: i
                    });
                }

                // Sort by sharpness (most acute angles first)
                corners.sort((a, b) => b.sharpness - a.sharpness);

                // Take the N sharpest corners
                const selected = corners.slice(0, targetCount);

                // Sort back by position around hull for proper order
                selected.sort((a, b) => a.index - b.index);

                return selected.map(c => c.point);
            }

            function findCornersWithSeparation(hullPoints, targetCount) {
                // Find N corners ensuring they're well-separated
                // Prevents picking multiple corners on the same edge

                if (!hullPoints || hullPoints.length <= targetCount) return hullPoints;

                // Calculate hull perimeter for minimum separation
                let perimeter = 0;
                for (let i = 0; i < hullPoints.length; i++) {
                    const next = (i + 1) % hullPoints.length;
                    perimeter += distance(hullPoints[i], hullPoints[next]);
                }

                // Minimum separation: corners must be at least 1/6 of perimeter apart
                const minSeparation = perimeter / (targetCount * 1.5);

                // Calculate angles at each hull vertex
                const corners = [];
                for (let i = 0; i < hullPoints.length; i++) {
                    const prev = hullPoints[(i - 1 + hullPoints.length) % hullPoints.length];
                    const curr = hullPoints[i];
                    const next = hullPoints[(i + 1) % hullPoints.length];

                    const angle = Angle(prev, curr, next);

                    corners.push({
                        point: curr,
                        angle: angle.radians,
                        sharpness: Math.PI - angle.radians,
                        index: i
                    });
                }

                // Sort by sharpness
                corners.sort((a, b) => b.sharpness - a.sharpness);

                // Greedily select corners ensuring minimum separation
                const selected = [];

                for (let i = 0; i < corners.length && selected.length < targetCount; i++) {
                    const candidate = corners[i];

                    // Check if this corner is far enough from all already-selected corners
                    let tooClose = false;
                    for (const existing of selected) {
                        // Calculate distance along hull perimeter
                        const indexDiff = Math.abs(candidate.index - existing.index);
                        const wrapDiff = hullPoints.length - indexDiff;
                        const minIndexDiff = Math.min(indexDiff, wrapDiff);

                        // Approximate arc length by number of points
                        const approxDist = (minIndexDiff / hullPoints.length) * perimeter;

                        if (approxDist < minSeparation) {
                            tooClose = true;
                            break;
                        }
                    }

                    if (!tooClose) {
                        selected.push(candidate);
                    }
                }

                // If we couldn't find enough separated corners, fall back to best we have
                if (selected.length < targetCount) {
                    console.warn(`Only found ${selected.length} separated corners, needed ${targetCount}`);
                    // Add the sharpest remaining corners regardless of separation
                    for (let i = 0; i < corners.length && selected.length < targetCount; i++) {
                        if (!selected.includes(corners[i])) {
                            selected.push(corners[i]);
                        }
                    }
                }

                // Sort by position around hull
                selected.sort((a, b) => a.index - b.index);

                return selected.map(c => c.point);
            }

            function fitRectangle(points) {
                // Simplified: Always use axis-aligned bounding box
                // FUTURE (Day 7): Add rotation-invariant fitting with proper PCA/minimum bounding rectangle
                // For now, prioritize stability and building geometric relationships (Phase 3)

                const bounds = boundsFromPoints(points);
                return [
                    Point(bounds.minX, bounds.minY),  // Top-left
                    Point(bounds.maxX, bounds.minY),  // Top-right
                    Point(bounds.maxX, bounds.maxY),  // Bottom-right
                    Point(bounds.minX, bounds.maxY)   // Bottom-left
                ];
            }

            function findRectangleCorners(hullPoints) {
                // Find 4 corners that best represent a rectangle
                // Strategy: Find the 4 corner points by combining extreme values
                // This works for both axis-aligned AND rotated rectangles

                if (hullPoints.length <= 4) return hullPoints;

                // Find extreme bounds
                let minX = Infinity, maxX = -Infinity;
                let minY = Infinity, maxY = -Infinity;

                hullPoints.forEach(p => {
                    if (p.x < minX) minX = p.x;
                    if (p.x > maxX) maxX = p.x;
                    if (p.y < minY) minY = p.y;
                    if (p.y > maxY) maxY = p.y;
                });

                // Find the 4 corners by looking for points that combine two extremes
                // For axis-aligned rectangles: these will be exact matches
                // For rotated rectangles: we'll find the closest points

                const threshold = 5; // pixels - allow small tolerance for matching

                // Top-left: min X AND min Y (or close to both)
                let topLeft = hullPoints.reduce((best, p) => {
                    const dist = Math.abs(p.x - minX) + Math.abs(p.y - minY);
                    const bestDist = Math.abs(best.x - minX) + Math.abs(best.y - minY);
                    return dist < bestDist ? p : best;
                });

                // Top-right: max X AND min Y
                let topRight = hullPoints.reduce((best, p) => {
                    const dist = Math.abs(p.x - maxX) + Math.abs(p.y - minY);
                    const bestDist = Math.abs(best.x - maxX) + Math.abs(best.y - minY);
                    return dist < bestDist ? p : best;
                });

                // Bottom-right: max X AND max Y
                let bottomRight = hullPoints.reduce((best, p) => {
                    const dist = Math.abs(p.x - maxX) + Math.abs(p.y - maxY);
                    const bestDist = Math.abs(best.x - maxX) + Math.abs(best.y - maxY);
                    return dist < bestDist ? p : best;
                });

                // Bottom-left: min X AND max Y
                let bottomLeft = hullPoints.reduce((best, p) => {
                    const dist = Math.abs(p.x - minX) + Math.abs(p.y - maxY);
                    const bestDist = Math.abs(best.x - minX) + Math.abs(best.y - maxY);
                    return dist < bestDist ? p : best;
                });

                // Remove duplicates and ensure we have exactly 4 corners
                const corners = [topLeft, topRight, bottomRight, bottomLeft];
                const unique = [];
                const seen = new Set();

                corners.forEach(c => {
                    const key = `${Math.round(c.x)},${Math.round(c.y)}`;
                    if (!seen.has(key)) {
                        seen.add(key);
                        unique.push(c);
                    }
                });

                // If we lost corners due to duplicates (shouldn't happen, but just in case),
                // fill in with the sharpest remaining corners
                if (unique.length < 4) {
                    const remaining = hullPoints.filter(p => {
                        const key = `${Math.round(p.x)},${Math.round(p.y)}`;
                        return !seen.has(key);
                    });

                    if (remaining.length > 0) {
                        const additional = findCorners(remaining, 4 - unique.length);
                        unique.push(...additional);
                    }
                }

                // Sort in counter-clockwise order around centroid
                const cx = unique.reduce((sum, p) => sum + p.x, 0) / unique.length;
                const cy = unique.reduce((sum, p) => sum + p.y, 0) / unique.length;

                unique.sort((a, b) => {
                    const angleA = Math.atan2(a.y - cy, a.x - cx);
                    const angleB = Math.atan2(b.y - cy, b.x - cx);
                    return angleA - angleB;
                });

                return unique.slice(0, 4);
            }

            function fitTriangle(points) {
                // Find best-fit triangle for a set of points
                // Returns 3 corners

                const hull = convexHull(points);

                if (hull.length === 3) {
                    // Perfect triangle
                    return hull;
                }

                if (hull.length < 3) {
                    // Degenerate case
                    return hull;
                }

                // Find 3 maximally separated corners
                return findTriangleCorners(hull);
            }

            function findTriangleCorners(hullPoints) {
                // Find 3 corners that best represent a triangle
                // Strategy: Find 3 maximally separated points to avoid picking
                // multiple corners on the same edge

                if (hullPoints.length <= 3) return hullPoints;

                // Calculate centroid
                const cx = hullPoints.reduce((sum, p) => sum + p.x, 0) / hullPoints.length;
                const cy = hullPoints.reduce((sum, p) => sum + p.y, 0) / hullPoints.length;

                // 1. Find point farthest from centroid (first corner)
                let corner1 = hullPoints.reduce((farthest, p) => {
                    const dist = distance(p, { x: cx, y: cy });
                    const farthestDist = distance(farthest, { x: cx, y: cy });
                    return dist > farthestDist ? p : farthest;
                });

                // 2. Find point farthest from first corner (second corner)
                let corner2 = hullPoints.reduce((farthest, p) => {
                    if (p === corner1) return farthest;
                    const dist = distance(p, corner1);
                    const farthestDist = distance(farthest, corner1);
                    return dist > farthestDist ? p : farthest;
                });

                // 3. Find point farthest from the line between corner1 and corner2 (third corner)
                let corner3 = hullPoints.reduce((farthest, p) => {
                    if (p === corner1 || p === corner2) return farthest;

                    // Calculate perpendicular distance from point to line
                    const dist = pointToLineDistance(p, corner1, corner2);
                    const farthestDist = pointToLineDistance(farthest, corner1, corner2);

                    return dist > farthestDist ? p : farthest;
                });

                // Sort corners in counter-clockwise order around centroid
                const corners = [corner1, corner2, corner3];
                corners.sort((a, b) => {
                    const angleA = Math.atan2(a.y - cy, a.x - cx);
                    const angleB = Math.atan2(b.y - cy, b.x - cx);
                    return angleA - angleB;
                });

                return corners;
            }

            function pointToLineDistance(point, lineStart, lineEnd) {
                // Calculate perpendicular distance from point to line segment
                const A = point.x - lineStart.x;
                const B = point.y - lineStart.y;
                const C = lineEnd.x - lineStart.x;
                const D = lineEnd.y - lineStart.y;

                const dot = A * C + B * D;
                const lenSq = C * C + D * D;

                if (lenSq === 0) {
                    // Line start and end are the same point
                    return distance(point, lineStart);
                }

                const param = dot / lenSq;

                let nearestX, nearestY;

                if (param < 0) {
                    nearestX = lineStart.x;
                    nearestY = lineStart.y;
                } else if (param > 1) {
                    nearestX = lineEnd.x;
                    nearestY = lineEnd.y;
                } else {
                    nearestX = lineStart.x + param * C;
                    nearestY = lineStart.y + param * D;
                }

                const dx = point.x - nearestX;
                const dy = point.y - nearestY;

                return Math.sqrt(dx * dx + dy * dy);
            }

            function douglasPeucker(points, tolerance) {
                // Douglas-Peucker simplification algorithm
                // More aggressive than simplifyStroke for polygon extraction

                if (!points || points.length <= 2) return points;

                function perpendicularDistance(point, lineStart, lineEnd) {
                    const dx = lineEnd.x - lineStart.x;
                    const dy = lineEnd.y - lineStart.y;
                    const mag = Math.sqrt(dx * dx + dy * dy);

                    if (mag === 0) {
                        return distance(point, lineStart);
                    }

                    const u = ((point.x - lineStart.x) * dx + (point.y - lineStart.y) * dy) / (mag * mag);
                    const closestPoint = Point(
                        lineStart.x + u * dx,
                        lineStart.y + u * dy
                    );

                    return distance(point, closestPoint);
                }

                function simplify(pts, tol) {
                    if (pts.length <= 2) return pts;

                    let maxDistance = 0;
                    let maxIndex = 0;
                    const end = pts.length - 1;

                    for (let i = 1; i < end; i++) {
                        const dist = perpendicularDistance(pts[i], pts[0], pts[end]);
                        if (dist > maxDistance) {
                            maxDistance = dist;
                            maxIndex = i;
                        }
                    }

                    if (maxDistance > tol) {
                        const left = simplify(pts.slice(0, maxIndex + 1), tol);
                        const right = simplify(pts.slice(maxIndex), tol);
                        return left.slice(0, -1).concat(right);
                    }

                    return [pts[0], pts[end]];
                }

                return simplify(points, tolerance);
            }

            console.log('✓ Convex hull & polygon algorithms loaded');

            // ===== END CONVEX HULL & POLYGON ALGORITHMS =====

            console.log('✓ Geometric type system loaded');

            // ===== END GEOMETRIC TYPE SYSTEM =====

            // ===== SHAPE STRUCTURE (Day 5) =====
            // Unified shape representation with formalism levels

            function Shape(config) {
                // config: {
                //   type, formalism, definition, properties,
                //   rendering: {original, refined}, label, accepted
                // }

                return {
                    id: config.id || Date.now() + Math.random(),
                    type: config.type,                    // 'circle' | 'line' | 'polygon' | 'point' | 'curve' | 'stroke'
                    formalism: config.formalism,          // 'formal' | 'semi-formal' | 'informal' | 'undefined'
                    definition: config.definition,        // Geometric primitives (Point, Circle, Polygon, etc.)
                    properties: config.properties || {},  // Derived properties (area, perimeter, angles, etc.)
                    rendering: {
                        original: config.rendering?.original || null,  // Raw user stroke
                        refined: config.rendering?.refined || null     // Cleaned geometric representation
                    },
                    label: config.label || `shape${config.id}`,
                    accepted: config.accepted || false
                };
            }

            // Factory: Create formal circle shape
            function createCircleShape(rawPoints, center, radius, label = 'circle', accepted = false) {
                const centerPoint = Point(center.x, center.y);
                const circleDef = Circle(centerPoint, radius);

                return Shape({
                    type: 'circle',
                    formalism: 'formal',
                    definition: circleDef,
                    properties: {
                        circumference: circleDef.circumference,
                        area: circleDef.area,
                        diameter: circleDef.diameter
                    },
                    rendering: {
                        original: rawPoints,
                        refined: generateCirclePoints(centerPoint, radius, 50)
                    },
                    label: label,
                    accepted: accepted
                });
            }

            // Factory: Create formal ellipse shape
            // FUTURE: Provide updateEllipseRadii(shapeId, newRX, newRY) for mutations
            function createEllipseShape(rawPoints, center, radiusX, radiusY, rotation, label = 'ellipse', accepted = false) {
                const centerPoint = Point(center.x, center.y);
                const ellipseDef = Ellipse(centerPoint, radiusX, radiusY, rotation);

                return Shape({
                    type: 'ellipse',
                    formalism: 'formal',
                    definition: ellipseDef,
                    properties: {
                        circumference: ellipseDef.circumference,
                        area: ellipseDef.area,
                        eccentricity: ellipseDef.eccentricity,
                        majorAxis: ellipseDef.majorAxis,
                        minorAxis: ellipseDef.minorAxis
                    },
                    rendering: {
                        original: rawPoints,
                        refined: generateEllipsePoints(centerPoint, radiusX, radiusY, rotation, 50)
                    },
                    label: label,
                    accepted: accepted
                });
            }

            // Factory: Create formal arc shape
            // FUTURE: Provide updateArcAngles(shapeId, newStart, newEnd) for mutations
            function createArcShape(rawPoints, center, radius, startAngle, endAngle, label = 'arc', accepted = false) {
                const centerPoint = Point(center.x, center.y);
                const arcDef = Arc(centerPoint, radius, startAngle, endAngle);

                return Shape({
                    type: 'arc',
                    formalism: 'formal',
                    definition: arcDef,
                    properties: {
                        arcLength: arcDef.arcLength,
                        chordLength: arcDef.chordLength,
                        sweep: arcDef.sweep,
                        isNearlyComplete: arcDef.isNearlyComplete,
                        isNearlyFlat: arcDef.isNearlyFlat
                    },
                    rendering: {
                        original: rawPoints,
                        refined: generateArcPoints(centerPoint, radius, startAngle, endAngle, 30)
                    },
                    label: label,
                    accepted: accepted
                });
            }

            // Factory: Create formal line shape
            function createLineShape(rawPoints, start, end, label = 'line', accepted = false) {
                const startPoint = Point(start.x, start.y);
                const endPoint = Point(end.x, end.y);
                const segmentDef = Segment(startPoint, endPoint);

                return Shape({
                    type: 'line',
                    formalism: 'formal',
                    definition: segmentDef,
                    properties: {
                        length: segmentDef.length,
                        midpoint: segmentDef.midpoint,
                        slope: segmentDef.slope,
                        angle: segmentDef.angle
                    },
                    rendering: {
                        original: rawPoints,
                        refined: [startPoint, endPoint]
                    },
                    label: label,
                    accepted: accepted
                });
            }

            // Factory: Create formal polygon shape (rectangle, triangle, etc.)
            function createPolygonShape(rawPoints, vertices, label = 'polygon', accepted = false) {
                // Ensure vertices are Point objects
                const points = vertices.map(v => {
                    if (v.type === 'point') {
                        return v; // Already a Point object
                    }
                    return Point(v.x, v.y);
                });

                const polyDef = Polygon(points, true);

                return Shape({
                    type: 'polygon',
                    formalism: 'semi-formal',
                    definition: polyDef,
                    properties: {
                        vertexCount: polyDef.vertexCount,
                        perimeter: polyDef.perimeter,
                        area: polyDef.area,
                        isConvex: polyDef.isConvex,
                        angles: polyDef.angles
                    },
                    rendering: {
                        original: rawPoints,
                        refined: points
                    },
                    label: label,
                    accepted: accepted
                });
            }

            // Factory: Create point shape (zero-length stroke)
            function createPointShape(x, y, label = 'point', accepted = false) {
                const pointDef = Point(x, y);

                return Shape({
                    type: 'point',
                    formalism: 'formal',
                    definition: pointDef,
                    properties: {},
                    rendering: {
                        original: [pointDef],
                        refined: [pointDef]
                    },
                    label: label,
                    accepted: accepted
                });
            }

            // Factory: Create informal curve/stroke shape
            function createCurveShape(rawPoints, label = 'curve', accepted = false) {
                const points = pointsFromRaw(rawPoints);
                const simplified = simplifyStroke(rawPoints, 5);
                const bounds = boundsFromPoints(points);

                return Shape({
                    type: 'curve',
                    formalism: 'informal',
                    definition: {
                        points: points,
                        boundary: pointsFromRaw(simplified),
                        bounds: bounds
                    },
                    properties: {
                        pointCount: points.length,
                        bounds: bounds,
                        pathLength: calculatePathLength(points)
                    },
                    rendering: {
                        original: rawPoints,
                        refined: simplified
                    },
                    label: label,
                    accepted: accepted
                });
            }

            // Helper: Calculate path length
            function calculatePathLength(points) {
                let length = 0;
                for (let i = 1; i < points.length; i++) {
                    length += distance(points[i - 1], points[i]);
                }
                return length;
            }

            // Helper: Generate circle points for rendering
            function generateCirclePoints(center, radius, segments = 50) {
                const points = [];
                for (let i = 0; i <= segments; i++) {
                    const angle = (i / segments) * Math.PI * 2;
                    points.push(Point(
                        center.x + Math.cos(angle) * radius,
                        center.y + Math.sin(angle) * radius
                    ));
                }
                return points;
            }

            // Helper: Generate ellipse points for rendering
            function generateEllipsePoints(center, radiusX, radiusY, rotation = 0, segments = 50) {
                const points = [];
                const cos = Math.cos(rotation);
                const sin = Math.sin(rotation);

                for (let i = 0; i <= segments; i++) {
                    const angle = (i / segments) * Math.PI * 2;
                    // Point on unrotated ellipse
                    const x = radiusX * Math.cos(angle);
                    const y = radiusY * Math.sin(angle);

                    // Apply rotation
                    const rotatedX = x * cos - y * sin;
                    const rotatedY = x * sin + y * cos;

                    points.push(Point(
                        center.x + rotatedX,
                        center.y + rotatedY
                    ));
                }
                return points;
            }

            // Helper: Generate arc points for rendering
            function generateArcPoints(center, radius, startAngle, endAngle, segments = 30) {
                const points = [];
                let sweep = endAngle - startAngle;
                if (sweep < 0) sweep += Math.PI * 2;

                for (let i = 0; i <= segments; i++) {
                    const angle = startAngle + (i / segments) * sweep;
                    points.push(Point(
                        center.x + Math.cos(angle) * radius,
                        center.y + Math.sin(angle) * radius
                    ));
                }
                return points;
            }

            // Helper: Check if stroke is a point (< 1px movement)
            function checkIfPoint(stroke) {
                if (!stroke || stroke.length === 0) return false;

                // Calculate total movement
                let totalMovement = 0;
                for (let i = 1; i < stroke.length; i++) {
                    const dx = stroke[i].x - stroke[i - 1].x;
                    const dy = stroke[i].y - stroke[i - 1].y;
                    totalMovement += Math.sqrt(dx * dx + dy * dy);
                }

                // Also check bounding box
                const bounds = boundsFromPoints(pointsFromRaw(stroke));
                const width = bounds.maxX - bounds.minX;
                const height = bounds.maxY - bounds.minY;

                // Point if total movement < 1px OR bounding box < 1px
                return totalMovement < 1 || (width < 1 && height < 1);
            }

            // DAY 5: Bridge function - Create Shape from recognition result
            function createShapeFromRecognition(originalStroke, type, semantic, refinedStroke, fingerprint) {
                // Convert old semantic extraction to new Shape objects

                switch (type) {
                    case 'circle':
                        if (semantic && semantic.center && semantic.radius) {
                            return createCircleShape(
                                originalStroke,
                                semantic.center,
                                semantic.radius,
                                'circle',
                                true
                            );
                        }
                        break;

                    case 'line':
                        if (semantic && semantic.start && semantic.end) {
                            return createLineShape(
                                originalStroke,
                                semantic.start,
                                semantic.end,
                                'line',
                                true
                            );
                        }
                        break;

                    case 'rectangle':
                    case 'triangle':
                        if (semantic && semantic.corners) {
                            return createPolygonShape(
                                originalStroke,
                                semantic.corners,
                                type,
                                true
                            );
                        }
                        break;

                    case 'point':
                        if (semantic && semantic.x !== undefined && semantic.y !== undefined) {
                            return createPointShape(semantic.x, semantic.y, 'point', true);
                        }
                        break;

                    default:
                        // User-defined shape or unknown - create as curve
                        return createCurveShape(originalStroke, type, true);
                }

                // Fallback: create as curve
                return createCurveShape(originalStroke, type || 'unknown', true);
            }

            // DAY 5: Draw a Shape object to canvas
            function drawShape(shape, ctx, debugMode = false) {
                // Draw from geometric definition (refined rendering)

                ctx.strokeStyle = shape.accepted ? '#0066ff' : '#666666';
                ctx.fillStyle = shape.accepted ? '#0066ff' : '#666666';
                ctx.lineWidth = 3;
                ctx.lineCap = 'round';
                ctx.lineJoin = 'round';

                switch (shape.type) {
                    case 'point':
                        // Draw point as small filled circle
                        ctx.fillStyle = shape.accepted ? '#0066ff' : '#666666';
                        ctx.beginPath();
                        ctx.arc(shape.definition.x, shape.definition.y, 5, 0, Math.PI * 2);
                        ctx.fill();

                        if (debugMode) {
                            // VERBOSE: Show point coordinates with background
                            const coords = `Point: (${Math.round(shape.definition.x)}, ${Math.round(shape.definition.y)})`;
                            ctx.font = '12px monospace';
                            const metrics = ctx.measureText(coords);

                            ctx.fillStyle = 'rgba(0, 0, 0, 0.8)';
                            ctx.fillRect(shape.definition.x + 10 - 3, shape.definition.y - 12 - 3, metrics.width + 6, 16);

                            ctx.fillStyle = '#66B3FF';
                            ctx.fillText(coords, shape.definition.x + 10, shape.definition.y - 3);
                        }
                        break;

                    case 'circle':
                        // Draw from refined points (generated circle)
                        if (shape.rendering.refined && shape.rendering.refined.length > 0) {
                            ctx.beginPath();
                            shape.rendering.refined.forEach((point, i) => {
                                if (i === 0) ctx.moveTo(point.x, point.y);
                                else ctx.lineTo(point.x, point.y);
                            });
                            ctx.stroke();
                        }

                        if (debugMode) {
                            // VERBOSE: Show center, radius, and properties
                            const center = shape.definition.center;
                            const radius = shape.definition.radius;

                            // Center point
                            ctx.fillStyle = '#FF99FF'; // Light magenta
                            ctx.beginPath();
                            ctx.arc(center.x, center.y, 6, 0, Math.PI * 2);
                            ctx.fill();

                            // Radius line
                            ctx.strokeStyle = '#FF99FF';
                            ctx.lineWidth = 2;
                            ctx.setLineDash([5, 5]);
                            ctx.beginPath();
                            ctx.moveTo(center.x, center.y);
                            ctx.lineTo(center.x + radius, center.y);
                            ctx.stroke();
                            ctx.setLineDash([]);
                            ctx.lineWidth = 3; // Reset

                            // Center coordinates
                            const centerCoords = `Center: (${Math.round(center.x)}, ${Math.round(center.y)})`;
                            ctx.font = '12px monospace';
                            const centerMetrics = ctx.measureText(centerCoords);
                            ctx.fillStyle = 'rgba(0, 0, 0, 0.8)';
                            ctx.fillRect(center.x + 10 - 3, center.y - 12 - 3, centerMetrics.width + 6, 16);
                            ctx.fillStyle = '#FF99FF';
                            ctx.fillText(centerCoords, center.x + 10, center.y - 3);

                            // Radius value
                            const radiusText = `Radius: ${Math.round(radius)}px`;
                            const radiusMetrics = ctx.measureText(radiusText);
                            ctx.fillStyle = 'rgba(0, 0, 0, 0.8)';
                            ctx.fillRect(center.x + radius / 2 - radiusMetrics.width / 2 - 3, center.y - 22, radiusMetrics.width + 6, 14);
                            ctx.fillStyle = '#FFD966';
                            ctx.fillText(radiusText, center.x + radius / 2 - radiusMetrics.width / 2, center.y - 11);

                            // Circumference and area
                            const circumText = `Circumference: ${Math.round(shape.definition.circumference)}px`;
                            const areaText = `Area: ${Math.round(shape.definition.area)}px²`;

                            const circumMetrics = ctx.measureText(circumText);
                            ctx.fillStyle = 'rgba(0, 0, 0, 0.8)';
                            ctx.fillRect(center.x - circumMetrics.width / 2 - 3, center.y + 10, circumMetrics.width + 6, 14);
                            ctx.fillStyle = '#99FF99';
                            ctx.fillText(circumText, center.x - circumMetrics.width / 2, center.y + 21);

                            const areaMetrics = ctx.measureText(areaText);
                            ctx.fillStyle = 'rgba(0, 0, 0, 0.8)';
                            ctx.fillRect(center.x - areaMetrics.width / 2 - 3, center.y + 26, areaMetrics.width + 6, 14);
                            ctx.fillStyle = '#99FF99';
                            ctx.fillText(areaText, center.x - areaMetrics.width / 2, center.y + 37);
                        }
                        break;

                    case 'ellipse':
                        // Draw from refined points (generated ellipse)
                        if (shape.rendering.refined && shape.rendering.refined.length > 0) {
                            ctx.beginPath();
                            shape.rendering.refined.forEach((point, i) => {
                                if (i === 0) ctx.moveTo(point.x, point.y);
                                else ctx.lineTo(point.x, point.y);
                            });
                            ctx.stroke();
                        }

                        if (debugMode) {
                            const center = shape.definition.center;
                            const radiusX = shape.definition.radiusX;
                            const radiusY = shape.definition.radiusY;

                            // Center point
                            ctx.fillStyle = '#FF99FF';
                            ctx.beginPath();
                            ctx.arc(center.x, center.y, 6, 0, Math.PI * 2);
                            ctx.fill();

                            // Show radii
                            ctx.font = '12px monospace';
                            const radiiText = `RX: ${Math.round(radiusX)}px, RY: ${Math.round(radiusY)}px`;
                            const metrics = ctx.measureText(radiiText);
                            ctx.fillStyle = 'rgba(0, 0, 0, 0.8)';
                            ctx.fillRect(center.x + 10 - 3, center.y - 12 - 3, metrics.width + 6, 16);
                            ctx.fillStyle = '#FF99FF';
                            ctx.fillText(radiiText, center.x + 10, center.y - 3);

                            // Show area
                            const areaText = `Area: ${Math.round(shape.definition.area)}px²`;
                            const areaMetrics = ctx.measureText(areaText);
                            ctx.fillStyle = 'rgba(0, 0, 0, 0.8)';
                            ctx.fillRect(center.x - areaMetrics.width / 2 - 3, center.y + 10, areaMetrics.width + 6, 14);
                            ctx.fillStyle = '#99FF99';
                            ctx.fillText(areaText, center.x - areaMetrics.width / 2, center.y + 21);
                        }
                        break;

                    case 'arc':
                        // Draw from refined points (generated arc)
                        if (shape.rendering.refined && shape.rendering.refined.length > 0) {
                            ctx.beginPath();
                            shape.rendering.refined.forEach((point, i) => {
                                if (i === 0) ctx.moveTo(point.x, point.y);
                                else ctx.lineTo(point.x, point.y);
                            });
                            ctx.stroke();
                        }

                        if (debugMode) {
                            const center = shape.definition.center;
                            const radius = shape.definition.radius;
                            const startPt = shape.definition.startPoint;
                            const endPt = shape.definition.endPoint;

                            // Center point
                            ctx.fillStyle = '#FF99FF';
                            ctx.beginPath();
                            ctx.arc(center.x, center.y, 6, 0, Math.PI * 2);
                            ctx.fill();

                            // Start and end points
                            ctx.fillStyle = '#99FF99';
                            ctx.beginPath();
                            ctx.arc(startPt.x, startPt.y, 5, 0, Math.PI * 2);
                            ctx.fill();

                            ctx.fillStyle = '#FF9999';
                            ctx.beginPath();
                            ctx.arc(endPt.x, endPt.y, 5, 0, Math.PI * 2);
                            ctx.fill();

                            // Show arc length
                            ctx.font = '12px monospace';
                            const lengthText = `Arc: ${Math.round(shape.definition.arcLength)}px (${Math.round(shape.definition.sweep * 180 / Math.PI)}°)`;
                            const mid = shape.definition.midPoint;
                            const metrics = ctx.measureText(lengthText);
                            ctx.fillStyle = 'rgba(0, 0, 0, 0.8)';
                            ctx.fillRect(mid.x - metrics.width / 2 - 3, mid.y - 12 - 3, metrics.width + 6, 16);
                            ctx.fillStyle = '#66B3FF';
                            ctx.fillText(lengthText, mid.x - metrics.width / 2, mid.y - 3);
                        }
                        break;

                    case 'line':
                        // Draw from segment definition
                        ctx.beginPath();
                        ctx.moveTo(shape.definition.start.x, shape.definition.start.y);
                        ctx.lineTo(shape.definition.end.x, shape.definition.end.y);
                        ctx.stroke();

                        if (debugMode) {
                            // VERBOSE: Show start and end points with coordinates
                            const startCoords = `Start: (${Math.round(shape.definition.start.x)}, ${Math.round(shape.definition.start.y)})`;
                            const endCoords = `End: (${Math.round(shape.definition.end.x)}, ${Math.round(shape.definition.end.y)})`;

                            ctx.font = '12px monospace';

                            // Start point
                            ctx.fillStyle = '#99FF99'; // Light green
                            ctx.beginPath();
                            ctx.arc(shape.definition.start.x, shape.definition.start.y, 6, 0, Math.PI * 2);
                            ctx.fill();

                            const startMetrics = ctx.measureText(startCoords);
                            ctx.fillStyle = 'rgba(0, 0, 0, 0.8)';
                            ctx.fillRect(shape.definition.start.x + 10 - 3, shape.definition.start.y - 12 - 3, startMetrics.width + 6, 16);
                            ctx.fillStyle = '#99FF99';
                            ctx.fillText(startCoords, shape.definition.start.x + 10, shape.definition.start.y - 3);

                            // End point
                            ctx.fillStyle = '#FF9999'; // Light red
                            ctx.beginPath();
                            ctx.arc(shape.definition.end.x, shape.definition.end.y, 6, 0, Math.PI * 2);
                            ctx.fill();

                            const endMetrics = ctx.measureText(endCoords);
                            ctx.fillStyle = 'rgba(0, 0, 0, 0.8)';
                            ctx.fillRect(shape.definition.end.x + 10 - 3, shape.definition.end.y - 12 - 3, endMetrics.width + 6, 16);
                            ctx.fillStyle = '#FF9999';
                            ctx.fillText(endCoords, shape.definition.end.x + 10, shape.definition.end.y - 3);

                            // Show length and slope
                            const mid = shape.definition.midpoint;
                            const lengthText = `Length: ${Math.round(shape.definition.length)}px`;
                            const slopeText = `Slope: ${shape.definition.slope === Infinity ? '∞' : shape.definition.slope.toFixed(2)}`;

                            const lengthMetrics = ctx.measureText(lengthText);
                            ctx.fillStyle = 'rgba(0, 0, 0, 0.8)';
                            ctx.fillRect(mid.x - lengthMetrics.width / 2 - 3, mid.y - 22, lengthMetrics.width + 6, 14);
                            ctx.fillStyle = '#66B3FF';
                            ctx.fillText(lengthText, mid.x - lengthMetrics.width / 2, mid.y - 11);

                            const slopeMetrics = ctx.measureText(slopeText);
                            ctx.fillStyle = 'rgba(0, 0, 0, 0.8)';
                            ctx.fillRect(mid.x - slopeMetrics.width / 2 - 3, mid.y - 6, slopeMetrics.width + 6, 14);
                            ctx.fillStyle = '#FFD966';
                            ctx.fillText(slopeText, mid.x - slopeMetrics.width / 2, mid.y + 5);
                        }
                        break;

                    case 'polygon':
                        // Draw from vertices
                        const vertices = shape.definition.vertices;

                        if (vertices && vertices.length > 0) {
                            ctx.beginPath();
                            vertices.forEach((vertex, i) => {
                                if (i === 0) ctx.moveTo(vertex.x, vertex.y);
                                else ctx.lineTo(vertex.x, vertex.y);
                            });
                            if (shape.definition.closed) {
                                ctx.closePath();
                            }
                            ctx.stroke();
                        }

                        if (debugMode) {
                            // VERBOSE DEBUG MODE for polygons
                            ctx.font = '13px monospace'; // Larger, easier to read

                            // Show vertices with coordinates
                            vertices.forEach((vertex, i) => {
                                // Vertex dot (larger)
                                ctx.fillStyle = '#66B3FF'; // Neutral light blue
                                ctx.beginPath();
                                ctx.arc(vertex.x, vertex.y, 6, 0, Math.PI * 2);
                                ctx.fill();

                                // Vertex label with coordinates
                                const coords = `(${Math.round(vertex.x)}, ${Math.round(vertex.y)})`;
                                const label = `V${i}: ${coords}`;

                                // Background rectangle for readability
                                ctx.font = '12px monospace';
                                const metrics = ctx.measureText(label);
                                const textWidth = metrics.width;
                                const textHeight = 14;
                                const padding = 4;

                                ctx.fillStyle = 'rgba(0, 0, 0, 0.7)';
                                ctx.fillRect(
                                    vertex.x + 10 - padding,
                                    vertex.y - 10 - textHeight - padding,
                                    textWidth + padding * 2,
                                    textHeight + padding * 2
                                );

                                ctx.fillStyle = '#66B3FF';
                                ctx.fillText(label, vertex.x + 10, vertex.y - 10);
                            });

                            // Show angles at vertices
                            if (shape.definition.angles && shape.definition.angles.length > 0) {
                                shape.definition.angles.forEach((angle, i) => {
                                    const v = angle.vertex;
                                    const angleText = `${Math.round(angle.degrees)}° (${angle.classification})`;

                                    ctx.font = '11px monospace';
                                    const metrics = ctx.measureText(angleText);
                                    const textWidth = metrics.width;

                                    // Background
                                    ctx.fillStyle = 'rgba(0, 0, 0, 0.7)';
                                    ctx.fillRect(v.x + 10 - 2, v.y + 8 - 2, textWidth + 4, 14);

                                    ctx.fillStyle = '#FFD966'; // Neutral yellow
                                    ctx.fillText(angleText, v.x + 10, v.y + 18);
                                });
                            }

                            // Show side lengths
                            if (shape.definition.sides && shape.definition.sides.length > 0) {
                                shape.definition.sides.forEach((side, i) => {
                                    const midX = side.midpoint.x;
                                    const midY = side.midpoint.y;
                                    const lengthText = `${Math.round(side.length)}px`;

                                    ctx.font = '11px monospace';
                                    ctx.fillStyle = 'rgba(0, 0, 0, 0.8)';
                                    const metrics = ctx.measureText(lengthText);
                                    ctx.fillRect(midX - metrics.width / 2 - 3, midY - 8, metrics.width + 6, 14);

                                    ctx.fillStyle = '#99FF99'; // Neutral green
                                    ctx.fillText(lengthText, midX - metrics.width / 2, midY + 3);
                                });
                            }

                            // Show area and perimeter
                            if (shape.properties.area) {
                                const centroid = shape.definition.centroid;
                                const areaText = `Area: ${Math.round(shape.properties.area)}px²`;
                                const perimText = `Perimeter: ${Math.round(shape.properties.perimeter)}px`;

                                ctx.font = '12px monospace';

                                // Area
                                const areaMetrics = ctx.measureText(areaText);
                                ctx.fillStyle = 'rgba(0, 0, 0, 0.8)';
                                ctx.fillRect(centroid.x - areaMetrics.width / 2 - 3, centroid.y - 20, areaMetrics.width + 6, 14);
                                ctx.fillStyle = '#FF99FF'; // Neutral magenta
                                ctx.fillText(areaText, centroid.x - areaMetrics.width / 2, centroid.y - 9);

                                // Perimeter
                                const perimMetrics = ctx.measureText(perimText);
                                ctx.fillStyle = 'rgba(0, 0, 0, 0.8)';
                                ctx.fillRect(centroid.x - perimMetrics.width / 2 - 3, centroid.y - 4, perimMetrics.width + 6, 14);
                                ctx.fillStyle = '#FF99FF';
                                ctx.fillText(perimText, centroid.x - perimMetrics.width / 2, centroid.y + 7);
                            }

                            // Show convexity
                            if (shape.definition.isConvex !== null) {
                                const bounds = boundsFromPoints(vertices);
                                const convexText = shape.definition.isConvex ? 'CONVEX' : 'CONCAVE';
                                ctx.font = '11px monospace';
                                const metrics = ctx.measureText(convexText);

                                ctx.fillStyle = 'rgba(0, 0, 0, 0.8)';
                                ctx.fillRect(bounds.maxX - metrics.width - 8, bounds.minY - 3, metrics.width + 6, 14);
                                ctx.fillStyle = shape.definition.isConvex ? '#99FF99' : '#FF9999';
                                ctx.fillText(convexText, bounds.maxX - metrics.width - 5, bounds.minY + 8);
                            }
                        }
                        break;

                    case 'curve':
                    case 'stroke':
                        // Draw from refined boundary
                        const points = shape.rendering.refined || shape.rendering.original;
                        if (points && points.length > 0) {
                            ctx.beginPath();
                            points.forEach((point, i) => {
                                if (i === 0) ctx.moveTo(point.x, point.y);
                                else ctx.lineTo(point.x, point.y);
                            });
                            ctx.stroke();
                        }

                        if (debugMode && shape.definition.boundary) {
                            // Show simplified boundary points
                            shape.definition.boundary.forEach((point, i) => {
                                ctx.fillStyle = '#00FFFF';
                                ctx.beginPath();
                                ctx.arc(point.x, point.y, 3, 0, Math.PI * 2);
                                ctx.fill();
                            });
                        }
                        break;
                }

                // Show formalism level in debug mode
                if (debugMode) {
                    const bounds = shape.definition.bounds || boundsFromPoints(pointsFromRaw(shape.rendering.original));
                    if (bounds) {
                        ctx.fillStyle = '#FF00FF';
                        ctx.font = 'bold 10px sans-serif';
                        ctx.fillText(`[${shape.formalism}]`, bounds.maxX + 5, bounds.minY + 10);
                    }
                }
            }

            console.log('✓ Shape structure loaded');

            // ===== END SHAPE STRUCTURE =====

            // State
            const state = {
                // DAY 5: New unified geometry system
                shapes: [],               // NEW: Unified Shape objects with geometric definitions

                // Legacy arrays (parallel system during migration)
                strokes: [],              // Original strokes as drawn
                strokeIds: [],            // PHASE 5.5C: Unique IDs for each stroke (enables subset matching)
                refinedStrokes: [],       // Refined geometric versions (null if not refined)
                semanticData: [],         // Semantic representations (center/radius, endpoints, corners, etc.)
                tipDebugData: [],         // Tip points for triangle debug visualization
                cornerDebugData: [],      // Corner positions and angles for debug visualization

                currentStroke: [],
                context: [],
                nextStrokeId: 1,          // PHASE 5.5C: Counter for generating unique stroke IDs
                isDrawing: false,
                suggestions: [],
                selectedStrokeIndex: null,
                lastFingerprint: null,
                debugMode: false,         // Toggle debug indicators
                verboseMode: false,       // DAY 5: Toggle verbose console logging
                refinement: {             // Geometric manipulation settings
                    enabled: true,
                    smooth: 2,            // 0-10 smoothing iterations
                    simplify: 2,          // 0-10 simplification tolerance
                    normalize: false
                },

                // PHASE 5.5A: History system for undo/redo
                history: {
                    actions: [],          // Stack of actions
                    currentIndex: -1,     // Current position in history (-1 = no history)
                    maxSize: 100         // Limit history size
                },
                library: {
                    // Built-in primitives (always present)
                    // NOTE: Line and Arc are FITTING METHODS, not library shapes
                    // Users draw lines/arcs, but don't save "line" as a reusable shape
                    'circle': {
                        type: 'builtin-primitive',
                        shapeType: 'circle',
                        label: 'Circle',
                        usageCount: 0
                        // Can be elongated (aspectRatio ≠ 1) - becomes elliptical
                    },
                    'triangle': {
                        type: 'builtin-primitive',
                        shapeType: 'triangle',
                        label: 'Triangle',
                        usageCount: 0
                    },
                    'rectangle': {
                        type: 'builtin-primitive',
                        shapeType: 'rectangle',
                        label: 'Rectangle',
                        usageCount: 0
                    },
                    // Built-in compositions (multi-stroke patterns)
                    'arrow': {
                        type: 'builtin-composition',
                        label: 'Arrow',
                        componentCount: 2,
                        fingerprint: {
                            componentTypes: ['line', 'triangle'],
                            componentCount: 2,
                            typeHistogram: { line: 1, triangle: 1 },
                            // For arrow, accept either touching OR intersecting (hand-drawn flexibility)
                            relationshipHistogram: null,  // Don't check relationships strictly
                            topologyHash: 'line+triangle',  // Just type composition, not relationships
                            canonicalOrder: [0, 1]
                        },
                        usageCount: 0
                    }
                }
            };

            // DAY 5: Verbose logging helper - only logs when verboseMode is enabled
            function vlog(...args) {
                if (state.verboseMode) {
                    console.log(...args);
                }
            }

            // Elements
            const canvas = document.getElementById('canvas');
            const ctx = canvas.getContext('2d');
            const canvasInput = document.getElementById('canvasInput');
            const suggestionsDiv = document.getElementById('suggestions');
            const metricsContent = document.getElementById('metricsContent');
            const recognitionStatus = document.getElementById('recognitionStatus');
            const fuzzyMatchInput = document.getElementById('fuzzyMatchInput');
            const clearBtn = document.getElementById('clearBtn');
            const saveToLibraryBtn = document.getElementById('saveToLibraryBtn');
            const strokeCountSpan = document.getElementById('strokeCount');
            const acceptedCountSpan = document.getElementById('acceptedCount');
            const exportLibraryBtn = document.getElementById('exportLibraryBtn');
            const libraryGrid = document.getElementById('libraryGrid');
            
            // New UI elements
            const metricsPanel = document.getElementById('metricsPanel');
            const libraryRow = document.querySelector('.library-row');
            const showLibraryBtn = document.getElementById('showLibraryBtn');
            const showMetricsBtn = document.getElementById('showMetricsBtn');
            const debugToggleBtn = document.getElementById('debugToggleBtn');
            
            // Legacy compatibility - create hidden checkbox for debug state
            const debugCheckbox = { checked: false };
            const verboseCheckbox = { checked: false };  // DAY 5

            // Inline save primitive UI elements
            const savePrimitiveContainer = document.getElementById('savePrimitiveContainer');
            const primitiveNameInput = document.getElementById('primitiveNameInput');
            const confirmSaveBtn = document.getElementById('confirmSaveBtn');
            const cancelSaveBtn = document.getElementById('cancelSaveBtn');

            // Utility functions
            function countCorners(points, angleThreshold = Math.PI / 3) {
                // Count significant direction changes (corners)
                // Angle threshold = 60 degrees (π/3) - catches hand-drawn corners
                if (points.length < 15) return { count: 0, angles: [] };

                const cornerPositions = [];
                const windowSize = 8; // Smaller window to catch sharper corners

                // Sample every 4 points to catch corners better
                for (let i = windowSize; i < points.length - windowSize; i += 4) {
                    // Get vectors before and after this point
                    const before = {
                        x: points[i].x - points[i - windowSize].x,
                        y: points[i].y - points[i - windowSize].y
                    };
                    const after = {
                        x: points[i + windowSize].x - points[i].x,
                        y: points[i + windowSize].y - points[i].y
                    };

                    // Calculate angle between vectors
                    const dotProduct = before.x * after.x + before.y * after.y;
                    const magBefore = Math.sqrt(before.x * before.x + before.y * before.y);
                    const magAfter = Math.sqrt(after.x * after.x + after.y * after.y);

                    if (magBefore === 0 || magAfter === 0) continue;

                    const cosAngle = dotProduct / (magBefore * magAfter);
                    const angle = Math.acos(Math.max(-1, Math.min(1, cosAngle)));

                    // If angle > threshold (90 degrees), it's a sharp corner
                    if (angle > angleThreshold) {
                        cornerPositions.push({ index: i, angle: angle });
                    }
                }

                // Cluster corners - merge corners within 20 points of each other
                if (cornerPositions.length === 0) return { count: 0, angles: [] };

                const clusteredCorners = [cornerPositions[0]];
                for (let i = 1; i < cornerPositions.length; i++) {
                    const lastCorner = clusteredCorners[clusteredCorners.length - 1];
                    const distance = cornerPositions[i].index - lastCorner.index;

                    if (distance > 20) {
                        // Far enough away, it's a new corner
                        clusteredCorners.push(cornerPositions[i]);
                    } else if (cornerPositions[i].angle > lastCorner.angle) {
                        // Same cluster, but this corner is sharper - replace
                        clusteredCorners[clusteredCorners.length - 1] = cornerPositions[i];
                    }
                }

                return {
                    count: clusteredCorners.length,
                    angles: clusteredCorners.map(c => c.angle),  // Angle values for fingerprint
                    cornerData: clusteredCorners  // Full corner objects with {index, angle} for refinement
                };
            }

            function analyzeCornerAngles(angles) {
                // Analyze the distribution of corner angles
                // Returns metrics useful for distinguishing rectangles from triangles
                // Handle undefined or empty arrays gracefully
                if (!angles || angles.length === 0) {
                    return {
                        avgAngle: 0,
                        variance: 0,
                        consistency: 0,
                        rectangleLikeness: 0,
                        triangleLikeness: 0
                    };
                }

                const avgAngle = angles.reduce((sum, a) => sum + a, 0) / angles.length;
                const variance = angles.reduce((sum, a) => sum + Math.pow(a - avgAngle, 2), 0) / angles.length;
                const stdDev = Math.sqrt(variance);

                // Consistency: how similar are all the angles? (0-1, higher = more consistent)
                const consistency = angles.length > 1 ? Math.max(0, 1 - stdDev / (Math.PI / 4)) : 1;

                // Check how "rectangle-like" the angles are (close to 90° = π/2)
                const rectangleLikeness = angles.reduce((sum, angle) => {
                    const deviationFrom90 = Math.abs(angle - Math.PI / 2);
                    // Score each corner: perfect 90° = 1, off by 45° = 0
                    return sum + Math.max(0, 1 - deviationFrom90 / (Math.PI / 4));
                }, 0) / angles.length;

                // Check how "triangle-like" the angles are (more varied, typically sharper or wider than 90°)
                const triangleLikeness = angles.reduce((sum, angle) => {
                    // Triangles typically have angles != 90°, often 60° or 120° external
                    const deviationFrom90 = Math.abs(angle - Math.PI / 2);
                    // Score higher if NOT near 90°
                    return sum + Math.min(1, deviationFrom90 / (Math.PI / 6));
                }, 0) / angles.length;

                return {
                    avgAngle,
                    variance,
                    consistency,
                    rectangleLikeness,
                    triangleLikeness
                };
            }

            function checkOvershoot(points, threshold = 50) {
                // Check if stroke passes near start point at any point
                // (not just at the end)
                if (points.length < 10) return false;

                const start = points[0];

                // Check last 30% of stroke for proximity to start
                const checkStart = Math.floor(points.length * 0.7);

                for (let i = checkStart; i < points.length; i++) {
                    const distance = Math.sqrt(
                        Math.pow(points[i].x - start.x, 2) +
                        Math.pow(points[i].y - start.y, 2)
                    );

                    if (distance < threshold) {
                        return true;
                    }
                }

                return false;
            }

            function getBounds(points) {
                if (points.length === 0) return { minX: 0, maxX: 0, minY: 0, maxY: 0 };

                let minX = Infinity, maxX = -Infinity;
                let minY = Infinity, maxY = -Infinity;

                points.forEach(point => {
                    minX = Math.min(minX, point.x);
                    maxX = Math.max(maxX, point.x);
                    minY = Math.min(minY, point.y);
                    maxY = Math.max(maxY, point.y);
                });

                return { minX, maxX, minY, maxY };
            }

            function isStrokeClosed(points, threshold = 50) {
                if (points.length < 5) return false;

                const start = points[0];
                const end = points[points.length - 1];
                const distance = Math.sqrt(
                    Math.pow(end.x - start.x, 2) +
                    Math.pow(end.y - start.y, 2)
                );

                // Check direct closure
                if (distance < threshold) return true;

                // Also consider size-relative closure
                const bounds = getBounds(points);
                const width = bounds.maxX - bounds.minX;
                const height = bounds.maxY - bounds.minY;
                const size = Math.max(width, height);
                const relativeGap = size > 0 ? distance / size : 1;

                if (relativeGap < 0.15) return true;

                // Check for overshoot (passes near start somewhere in last 30%)
                return checkOvershoot(points, threshold);
            }

            function calculateStraightness(points) {
                if (points.length < 2) return 0;

                const start = points[0];
                const end = points[points.length - 1];

                const directDistance = Math.sqrt(
                    Math.pow(end.x - start.x, 2) +
                    Math.pow(end.y - start.y, 2)
                );

                let pathLength = 0;
                for (let i = 1; i < points.length; i++) {
                    const dx = points[i].x - points[i - 1].x;
                    const dy = points[i].y - points[i - 1].y;
                    pathLength += Math.sqrt(dx * dx + dy * dy);
                }

                if (pathLength === 0) return 0;
                return directDistance / pathLength;
            }

            function getFingerprint(points) {
                const bounds = getBounds(points);
                const width = bounds.maxX - bounds.minX;
                const height = bounds.maxY - bounds.minY;
                const start = points[0];
                const end = points[points.length - 1];
                const endDistance = Math.sqrt(
                    Math.pow(end.x - start.x, 2) +
                    Math.pow(end.y - start.y, 2)
                );

                // Get corner data (count + angles + positions)
                const cornerData = countCorners(points);
                const angleAnalysis = analyzeCornerAngles(cornerData.angles);

                return {
                    aspectRatio: height === 0 ? 1 : width / height,
                    straightness: calculateStraightness(points),
                    isClosed: isStrokeClosed(points),
                    closureDistance: endDistance,
                    corners: cornerData.count,
                    cornerAngles: cornerData.angles,
                    cornerData: cornerData.cornerData,  // Cache corner positions for refinement
                    angleAnalysis: angleAnalysis,
                    bounds: bounds,
                    size: Math.max(width, height),
                    pointCount: points.length
                };
            }

            // ===== GEOMETRIC MANIPULATION FUNCTIONS (Phase 1) =====

            function smoothStroke(points, iterations = 2) {
                // Chaikin's corner cutting algorithm with endpoint preservation
                // Each iteration smooths the stroke by replacing corners
                if (!points || points.length < 3) return points;

                let smoothed = [...points];
                const firstPoint = points[0];
                const lastPoint = points[points.length - 1];

                for (let iter = 0; iter < iterations; iter++) {
                    const newPoints = [];

                    // Always keep the first point
                    newPoints.push({ ...smoothed[0] });

                    for (let i = 0; i < smoothed.length - 1; i++) {
                        const p1 = smoothed[i];
                        const p2 = smoothed[i + 1];

                        // Quarter point closer to p1
                        const q = {
                            x: 0.75 * p1.x + 0.25 * p2.x,
                            y: 0.75 * p1.y + 0.25 * p2.y
                        };

                        // Quarter point closer to p2
                        const r = {
                            x: 0.25 * p1.x + 0.75 * p2.x,
                            y: 0.25 * p1.y + 0.75 * p2.y
                        };

                        newPoints.push(q);
                        newPoints.push(r);
                    }

                    // Always keep the last point
                    newPoints.push({ ...smoothed[smoothed.length - 1] });

                    smoothed = newPoints;
                }

                // Ensure original endpoints are preserved exactly
                smoothed[0] = firstPoint;
                smoothed[smoothed.length - 1] = lastPoint;

                return smoothed;
            }

            function simplifyStroke(points, tolerance = 2) {
                // Douglas-Peucker algorithm for point reduction
                // Removes points that don't significantly affect the shape
                if (!points || points.length <= 2) return points;

                function perpendicularDistance(point, lineStart, lineEnd) {
                    const dx = lineEnd.x - lineStart.x;
                    const dy = lineEnd.y - lineStart.y;
                    const mag = Math.sqrt(dx * dx + dy * dy);

                    if (mag === 0) return Math.sqrt(Math.pow(point.x - lineStart.x, 2) + Math.pow(point.y - lineStart.y, 2));

                    const u = ((point.x - lineStart.x) * dx + (point.y - lineStart.y) * dy) / (mag * mag);
                    const closestPoint = {
                        x: lineStart.x + u * dx,
                        y: lineStart.y + u * dy
                    };

                    return Math.sqrt(Math.pow(point.x - closestPoint.x, 2) + Math.pow(point.y - closestPoint.y, 2));
                }

                function simplifyDouglasPeucker(points, tolerance) {
                    if (points.length <= 2) return points;

                    let maxDistance = 0;
                    let maxIndex = 0;
                    const end = points.length - 1;

                    // Find point with maximum distance from line between first and last
                    for (let i = 1; i < end; i++) {
                        const distance = perpendicularDistance(points[i], points[0], points[end]);
                        if (distance > maxDistance) {
                            maxDistance = distance;
                            maxIndex = i;
                        }
                    }

                    // If max distance is greater than tolerance, recursively simplify
                    if (maxDistance > tolerance) {
                        const left = simplifyDouglasPeucker(points.slice(0, maxIndex + 1), tolerance);
                        const right = simplifyDouglasPeucker(points.slice(maxIndex), tolerance);

                        // Combine results (remove duplicate point at junction)
                        return left.slice(0, -1).concat(right);
                    } else {
                        // All points between first and last are within tolerance
                        return [points[0], points[end]];
                    }
                }

                return simplifyDouglasPeucker(points, tolerance);
            }

            function normalizeStroke(points, targetSize = 200) {
                // Scale stroke to standard size while maintaining canvas position
                if (!points || points.length === 0) return points;

                const bounds = getBounds(points);
                const width = bounds.maxX - bounds.minX;
                const height = bounds.maxY - bounds.minY;
                const maxDim = Math.max(width, height);

                if (maxDim === 0) return points;

                const scale = targetSize / maxDim;
                const originalCenterX = (bounds.minX + bounds.maxX) / 2;
                const originalCenterY = (bounds.minY + bounds.maxY) / 2;

                // Scale around the original center position to maintain location on canvas
                return points.map(p => ({
                    x: (p.x - originalCenterX) * scale + originalCenterX,
                    y: (p.y - originalCenterY) * scale + originalCenterY
                }));
            }

            function applyRefinement(points, options = {}) {
                // Apply refinement operations in sequence
                let refined = [...points];

                // Simplify first (reduce points)
                if (options.simplify > 0) {
                    refined = simplifyStroke(refined, options.simplify);
                }

                // Then smooth (multiple iterations)
                if (options.smooth > 0) {
                    refined = smoothStroke(refined, options.smooth);
                }

                // Normalize if requested
                if (options.normalize) {
                    refined = normalizeStroke(refined, options.normalizeSize || 200);
                }

                return refined;
            }

            // ===== END GEOMETRIC MANIPULATION =====

            // ===== GEOMETRIC SHAPE EXTRACTION (Day 5) =====
            // Extract formal geometric shapes from raw strokes
            // Returns Shape objects with full geometric definitions

            function extractCircleGeometric(stroke, label = 'circle', accepted = false) {
                // Extract center and radius/radii from circular/elliptical stroke
                // Intelligently chooses between Circle() and Ellipse() based on aspect ratio
                const bounds = getBounds(stroke);
                const centerX = (bounds.minX + bounds.maxX) / 2;
                const centerY = (bounds.minY + bounds.maxY) / 2;
                const center = { x: centerX, y: centerY };

                const width = bounds.maxX - bounds.minX;
                const height = bounds.maxY - bounds.minY;
                const aspectRatio = height === 0 ? 1 : width / height;

                // If aspect ratio is significantly non-circular, use Ellipse geometry
                if (Math.abs(aspectRatio - 1) > 0.4) {
                    // Elliptical - use radii along axes
                    const radiusX = width / 2;
                    const radiusY = height / 2;

                    // Estimate rotation using the farthest point
                    let maxDist = 0;
                    let farthestPoint = stroke[0];
                    stroke.forEach(point => {
                        const dist = distance(point, center);
                        if (dist > maxDist) {
                            maxDist = dist;
                            farthestPoint = point;
                        }
                    });

                    const rotation = Math.atan2(farthestPoint.y - centerY, farthestPoint.x - centerX);

                    // Use Ellipse geometry internally, but label as 'circle'
                    return createEllipseShape(stroke, center, radiusX, radiusY, rotation, label, accepted);
                } else {
                    // Circular - use average radius
                    let totalDistance = 0;
                    stroke.forEach(point => {
                        const dx = point.x - centerX;
                        const dy = point.y - centerY;
                        totalDistance += Math.sqrt(dx * dx + dy * dy);
                    });
                    const radius = totalDistance / stroke.length;

                    // Use Circle geometry
                    return createCircleShape(stroke, center, radius, label, accepted);
                }
            }

            function extractEllipseGeometric(stroke, label = 'ellipse', accepted = false) {
                // Extract center and radii from elliptical stroke
                const bounds = getBounds(stroke);
                const centerX = (bounds.minX + bounds.maxX) / 2;
                const centerY = (bounds.minY + bounds.maxY) / 2;

                // Calculate radii along x and y axes (simplified: use bounding box)
                // FUTURE: Proper ellipse fitting using covariance/PCA for rotation
                const radiusX = (bounds.maxX - bounds.minX) / 2;
                const radiusY = (bounds.maxY - bounds.minY) / 2;

                // Estimate rotation using the angle of the major axis
                // Find the two points farthest from center
                let maxDist = 0;
                let farthestPoint = stroke[0];
                stroke.forEach(point => {
                    const dist = distance(point, { x: centerX, y: centerY });
                    if (dist > maxDist) {
                        maxDist = dist;
                        farthestPoint = point;
                    }
                });

                const rotation = Math.atan2(farthestPoint.y - centerY, farthestPoint.x - centerX);

                // Create formal geometric Shape
                return createEllipseShape(stroke, { x: centerX, y: centerY }, radiusX, radiusY, rotation, label, accepted);
            }

            function extractArcGeometric(stroke, label = 'arc', accepted = false) {
                // Extract center, radius, and angle range from arc stroke
                const bounds = getBounds(stroke);

                // Find approximate center by finding point that minimizes variance of distances
                let bestCenter = { x: (bounds.minX + bounds.maxX) / 2, y: (bounds.minY + bounds.maxY) / 2 };
                let bestVariance = Infinity;

                // Try a few candidate centers
                const candidates = [
                    { x: (bounds.minX + bounds.maxX) / 2, y: (bounds.minY + bounds.maxY) / 2 },
                    { x: bounds.minX, y: (bounds.minY + bounds.maxY) / 2 },
                    { x: bounds.maxX, y: (bounds.minY + bounds.maxY) / 2 },
                    { x: (bounds.minX + bounds.maxX) / 2, y: bounds.minY },
                    { x: (bounds.minX + bounds.maxX) / 2, y: bounds.maxY }
                ];

                candidates.forEach(center => {
                    const distances = stroke.map(p => distance(p, center));
                    const avgDist = distances.reduce((sum, d) => sum + d, 0) / distances.length;
                    const variance = distances.reduce((sum, d) => sum + Math.pow(d - avgDist, 2), 0) / distances.length;

                    if (variance < bestVariance) {
                        bestVariance = variance;
                        bestCenter = center;
                    }
                });

                // Calculate radius
                const radius = stroke.reduce((sum, p) => sum + distance(p, bestCenter), 0) / stroke.length;

                // Calculate start and end angles
                const startPoint = stroke[0];
                const endPoint = stroke[stroke.length - 1];

                const startAngle = Math.atan2(startPoint.y - bestCenter.y, startPoint.x - bestCenter.x);
                const endAngle = Math.atan2(endPoint.y - bestCenter.y, endPoint.x - bestCenter.x);

                // Create formal geometric Shape
                return createArcShape(stroke, bestCenter, radius, startAngle, endAngle, label, accepted);
            }

            function extractLineGeometric(stroke, label = 'line', accepted = false) {
                // Extract start and end points from line stroke
                if (!stroke || stroke.length < 2) return null;

                const start = { x: stroke[0].x, y: stroke[0].y };
                const end = { x: stroke[stroke.length - 1].x, y: stroke[stroke.length - 1].y };

                // Create formal geometric Shape
                return createLineShape(stroke, start, end, label, accepted);
            }

            function extractPolygonGeometric(stroke, fingerprint, vertexCount, label, accepted = false) {
                // Extract corners for rectangles (4) and triangles (3)
                // Uses robust convex hull + corner detection

                let vertices;

                // Always use robust geometric fitting
                if (vertexCount === 4) {
                    // Rectangle: use convex hull + corner fitting
                    vertices = fitRectangle(stroke);
                } else if (vertexCount === 3) {
                    // Triangle: use convex hull + corner fitting
                    vertices = fitTriangle(stroke);
                } else {
                    // Generic polygon: use convex hull
                    const hull = convexHull(stroke);
                    vertices = hull.length <= vertexCount ? hull : findCorners(hull, vertexCount);
                }

                // Create semi-formal geometric Shape
                return createPolygonShape(stroke, vertices, label, accepted);
            }

            function extractCurveGeometric(stroke, label, accepted = false) {
                // For unrecognized or user-defined shapes
                return createCurveShape(stroke, label, accepted);
            }

            function extractGeometricShape(stroke, shapeType, fingerprint = null, label = null, accepted = false) {
                // Route to appropriate geometric extractor
                // Returns formal Shape object

                const shapeLabel = label || shapeType;

                switch (shapeType) {
                    case 'circle':
                        // Handles both circular and elliptical shapes (unified primitive)
                        return extractCircleGeometric(stroke, shapeLabel, accepted);
                    case 'arc':
                        // Curve fitting method (not in library, but used for stroke analysis)
                        return extractArcGeometric(stroke, shapeLabel, accepted);
                    case 'line':
                        // Straight fitting method (not in library, but used for stroke analysis)
                        return extractLineGeometric(stroke, shapeLabel, accepted);
                    case 'rectangle':
                        return extractPolygonGeometric(stroke, fingerprint, 4, shapeLabel, accepted);
                    case 'triangle':
                        return extractPolygonGeometric(stroke, fingerprint, 3, shapeLabel, accepted);
                    default:
                        return extractCurveGeometric(stroke, shapeLabel, accepted);
                }
            }

            // ===== END GEOMETRIC SHAPE EXTRACTION =====

            // PHASE 5.5B: Deleted old Day 4 createCompositionFingerprint() and helpers
            // Now using Phase 3C canonical fingerprint (see line ~4328)
            // Migration shim below handles backward compatibility with old saved compositions

            // PHASE 5.5B: Migration shim for backward compatibility
            // Detects old Day 4 nested fingerprints vs new Phase 3C flat fingerprints
            // Delegates to new matchCompositionFingerprints() for new-style data
            // Falls back to old comparison logic for legacy saved compositions
            function compareCompositionFingerprints(fingerprintA, fingerprintB, tolerances = {}) {
                // Multi-level comparison: topology → geometry → semantics
                // Returns confidence score [0, 1] and breakdown of scores

                if (!fingerprintA || !fingerprintB) {
                    return { match: false, confidence: 0, breakdown: {} };
                }

                // PHASE 3C: Detect if these are new-style fingerprints (flat structure)
                // If so, delegate to the new comparison function
                const isNewStyleA = !fingerprintA.topology && fingerprintA.componentTypes;
                const isNewStyleB = !fingerprintB.topology && fingerprintB.componentTypes;

                if (isNewStyleA || isNewStyleB) {
                    // Use new comparison function
                    const result = matchCompositionFingerprints(fingerprintA, fingerprintB, 0.8);
                    return {
                        match: result.matches,
                        confidence: result.score,
                        breakdown: result.breakdown || {}
                    };
                }

                // OLD DAY 4 COMPARISON (for legacy saved compositions)

                // Default tolerances
                const tol = {
                    componentCount: tolerances.componentCount || 0,  // Must match exactly
                    typeHistogram: tolerances.typeHistogram || 0.1,  // 10% tolerance
                    graphDensity: tolerances.graphDensity || 0.2,    // 20% tolerance
                    aspectRatio: tolerances.aspectRatio || 0.3,      // 30% tolerance
                    positionTolerance: tolerances.positionTolerance || 0.15,  // 15% of canvas
                    angleHistogram: tolerances.angleHistogram || 0.2  // 20% tolerance
                };

                const scores = {};

                // 1. TOPOLOGY COMPARISON (fast rejection)
                const topoA = fingerprintA.topology;
                const topoB = fingerprintB.topology;

                // Safety check
                if (!topoA || !topoB) {
                    return { match: false, confidence: 0, breakdown: { reason: 'missing topology data' } };
                }

                // Component count must match exactly
                if (topoA.componentCount !== topoB.componentCount) {
                    return { match: false, confidence: 0, breakdown: { reason: 'component count mismatch' } };
                }
                scores.componentCount = 1.0;

                // Type histogram similarity
                scores.typeHistogram = compareTypeHistograms(topoA.typeHistogram, topoB.typeHistogram);
                if (scores.typeHistogram < (1.0 - tol.typeHistogram)) {
                    return { match: false, confidence: 0, breakdown: { reason: 'type histogram mismatch', scores } };
                }

                // Graph structure similarity
                scores.graphDensity = 1.0 - Math.min(1.0, Math.abs(topoA.graphDensity - topoB.graphDensity) / 0.5);
                if (scores.graphDensity < (1.0 - tol.graphDensity)) {
                    return { match: false, confidence: 0, breakdown: { reason: 'graph density mismatch', scores } };
                }

                // 2. GEOMETRY COMPARISON (scale-invariant)
                const geoA = fingerprintA.geometry;
                const geoB = fingerprintB.geometry;

                // Aspect ratio similarity
                const aspectDiff = Math.abs(geoA.aspectRatio - geoB.aspectRatio);
                scores.aspectRatio = 1.0 - Math.min(1.0, aspectDiff / 2.0);
                if (scores.aspectRatio < (1.0 - tol.aspectRatio)) {
                    return { match: false, confidence: 0.2, breakdown: { reason: 'aspect ratio mismatch', scores } };
                }

                // Component position similarity (using Hungarian algorithm approximation)
                scores.componentPositions = compareComponentPositions(
                    geoA.normalizedComponents,
                    geoB.normalizedComponents,
                    tol.positionTolerance
                );
                if (scores.componentPositions < 0.7) {
                    return { match: false, confidence: 0.3, breakdown: { reason: 'position mismatch', scores } };
                }

                // Connection geometry similarity
                scores.connectionGeometry = compareConnectionGeometry(
                    geoA.connectionGeometry,
                    geoB.connectionGeometry,
                    tol.angleHistogram
                );
                if (scores.connectionGeometry < 0.6) {
                    return { match: false, confidence: 0.4, breakdown: { reason: 'connection geometry mismatch', scores } };
                }

                // 3. CALCULATE OVERALL CONFIDENCE
                const weights = {
                    componentCount: 0.15,
                    typeHistogram: 0.15,
                    graphDensity: 0.10,
                    aspectRatio: 0.10,
                    componentPositions: 0.30,
                    connectionGeometry: 0.20
                };

                let confidence = 0;
                Object.keys(weights).forEach(key => {
                    confidence += (scores[key] || 0) * weights[key];
                });

                return {
                    match: confidence >= 0.75,  // 75% threshold for match
                    confidence: confidence,
                    breakdown: scores
                };
            }

            function compareTypeHistograms(histA, histB) {
                // Compare two type histograms using cosine similarity
                const allTypes = new Set([...Object.keys(histA), ...Object.keys(histB)]);

                let dotProduct = 0;
                let magA = 0;
                let magB = 0;

                allTypes.forEach(type => {
                    const valA = histA[type] || 0;
                    const valB = histB[type] || 0;
                    dotProduct += valA * valB;
                    magA += valA * valA;
                    magB += valB * valB;
                });

                const magnitude = Math.sqrt(magA) * Math.sqrt(magB);
                if (magnitude === 0) return 0;

                return dotProduct / magnitude;
            }

            function compareComponentPositions(componentsA, componentsB, tolerance) {
                // Simple greedy matching (approximation of Hungarian algorithm)
                // Match components by type first, then by proximity

                if (componentsA.length !== componentsB.length) return 0;
                if (componentsA.length === 0) return 1;

                const matched = new Set();
                let totalScore = 0;

                // For each component in A, find best match in B
                componentsA.forEach((compA, i) => {
                    let bestScore = 0;
                    let bestIdx = -1;

                    componentsB.forEach((compB, j) => {
                        if (matched.has(j)) return;  // Already matched

                        // Type must match
                        if (compA.type !== compB.type) return;

                        // Calculate position distance
                        const dx = compA.center.x - compB.center.x;
                        const dy = compA.center.y - compB.center.y;
                        const distance = Math.sqrt(dx * dx + dy * dy);

                        // Score decreases with distance
                        const score = Math.max(0, 1.0 - (distance / tolerance));

                        if (score > bestScore) {
                            bestScore = score;
                            bestIdx = j;
                        }
                    });

                    if (bestIdx !== -1) {
                        matched.add(bestIdx);
                        totalScore += bestScore;
                    }
                });

                return totalScore / componentsA.length;
            }

            function compareConnectionGeometry(geoA, geoB, tolerance) {
                // Compare connection geometry using angle histograms and average distance

                if (!geoA || !geoB) return 0;

                // Safety checks for histogram arrays
                if (!geoA.angleHistogram || !geoB.angleHistogram) return 0.5;  // Neutral score if no histograms
                if (geoA.angleHistogram.length !== geoB.angleHistogram.length) return 0;

                // Compare angle histograms (rotation-variant)
                let histogramDiff = 0;
                for (let i = 0; i < geoA.angleHistogram.length; i++) {
                    histogramDiff += Math.abs((geoA.angleHistogram[i] || 0) - (geoB.angleHistogram[i] || 0));
                }
                const histogramScore = 1.0 - (histogramDiff / 2.0);  // Max diff is 2.0

                // Compare average distances
                const distanceDiff = Math.abs((geoA.avgDistance || 0) - (geoB.avgDistance || 0));
                const distanceScore = 1.0 - Math.min(1.0, distanceDiff / 0.5);

                // Weighted combination
                return histogramScore * 0.6 + distanceScore * 0.4;
            }

            // ===== END COMPOSITION FINGERPRINTING =====

            // ===== COMPOSITION MATCHING (Day 4) =====

            // PHASE 5.5D: Deleted old findCompositionMatches() - now using unified checkCanvasForCompositions()

            function updateCanvasLooksLike() {
                // PHASE 5.5D: Now uses unified checkCanvasForCompositions()
                // Update the "Canvas looks like:" UI with current matches
                const looksLikeList = document.getElementById('looksLikeList');
                if (!looksLikeList) {
                    console.error('❌ looksLikeList element not found!');
                    return;
                }

                // Use the unified composition checker
                const matches = checkCanvasForCompositions();

                if (matches.length === 0) {
                    looksLikeList.textContent = '—';
                    looksLikeList.className = 'looks-like-list empty';
                    return;
                }

                // Show top 3 matches
                const topMatches = matches.slice(0, 3);
                const html = topMatches.map(match => {
                    const confidencePercent = Math.round(match.confidence * 100);
                    return `<span class="match-item">${match.label} <span class="match-confidence">${confidencePercent}%</span></span>`;
                }).join(' ');

                looksLikeList.innerHTML = html;
                looksLikeList.className = 'looks-like-list';
            }

            // ===== END COMPOSITION MATCHING =====

            // ===== SPATIAL UTILITY FUNCTIONS (Day 3) =====
            // Two-tier distance system: AABB for fast rejection, stroke distance for accuracy

            function flattenStroke(stroke) {
                // Convert segment-based strokes to flat point arrays
                // Segment-based: [[{x,y}, ...], [{x,y}, ...]] (rectangles/triangles)
                // Single stroke: [{x,y}, {x,y}, ...] (circles/lines)
                if (!stroke || stroke.length === 0) return [];

                // Check if this is a segment-based stroke
                const isSegmentBased = Array.isArray(stroke[0]) &&
                    typeof stroke[0][0] === 'object' &&
                    typeof stroke[0][0].x !== 'undefined';

                if (isSegmentBased) {
                    // Flatten all segments into single array
                    return stroke.reduce((acc, segment) => acc.concat(segment), []);
                }

                // Already flat
                return stroke;
            }

            function aabbsNear(boundsA, boundsB, threshold = 50) {
                // Fast check: Are bounding boxes within threshold distance?
                // Used for quick rejection before expensive stroke distance calculation
                let dx = 0;
                let dy = 0;

                // Horizontal distance
                if (boundsA.maxX < boundsB.minX) {
                    dx = boundsB.minX - boundsA.maxX;
                } else if (boundsB.maxX < boundsA.minX) {
                    dx = boundsA.minX - boundsB.maxX;
                }

                // Vertical distance
                if (boundsA.maxY < boundsB.minY) {
                    dy = boundsB.minY - boundsA.maxY;
                } else if (boundsB.maxY < boundsA.minY) {
                    dy = boundsA.minY - boundsB.maxY;
                }

                const distance = Math.sqrt(dx * dx + dy * dy);
                return distance <= threshold;
            }

            function calculateMinStrokeDistance(strokeA, strokeB, sampleRate = 5) {
                // Calculate minimum distance between two strokes
                // Uses sampling for performance with large strokes
                if (!strokeA || !strokeB || strokeA.length === 0 || strokeB.length === 0) {
                    return Infinity;
                }

                let minDistance = Infinity;

                // Sample points from strokeA
                for (let i = 0; i < strokeA.length; i += sampleRate) {
                    const pointA = strokeA[i];

                    // Check against sample points from strokeB
                    for (let j = 0; j < strokeB.length; j += sampleRate) {
                        const pointB = strokeB[j];
                        const dx = pointB.x - pointA.x;
                        const dy = pointB.y - pointA.y;
                        const distance = Math.sqrt(dx * dx + dy * dy);

                        if (distance < minDistance) {
                            minDistance = distance;
                        }

                        // Early exit if we found overlapping points
                        if (minDistance < 1) return minDistance;
                    }
                }

                // Always check endpoints (most important for accuracy)
                const endpoints = [
                    [strokeA[0], strokeB[0]],
                    [strokeA[0], strokeB[strokeB.length - 1]],
                    [strokeA[strokeA.length - 1], strokeB[0]],
                    [strokeA[strokeA.length - 1], strokeB[strokeB.length - 1]]
                ];

                endpoints.forEach(([pA, pB]) => {
                    const dx = pB.x - pA.x;
                    const dy = pB.y - pA.y;
                    const distance = Math.sqrt(dx * dx + dy * dy);
                    if (distance < minDistance) {
                        minDistance = distance;
                    }
                });

                return minDistance;
            }

            function checkOverlap(boundsA, boundsB) {
                // Check if two bounding boxes overlap
                // Returns true if they share any area

                // Safety check: ensure both bounds exist
                if (!boundsA || !boundsB) {
                    return false;
                }

                const noOverlap =
                    boundsA.maxX < boundsB.minX || // A is to the left of B
                    boundsA.minX > boundsB.maxX || // A is to the right of B
                    boundsA.maxY < boundsB.minY || // A is above B
                    boundsA.minY > boundsB.maxY;   // A is below B

                return !noOverlap;
            }

            function checkTouching(strokeA, strokeB, boundsA, boundsB, threshold = 50) {
                // Two-tier check: AABB first, then accurate stroke distance
                // threshold: maximum distance to consider touching (default 50px for hand-drawn variability)

                // Tier 1: Fast rejection using expanded AABB
                if (!aabbsNear(boundsA, boundsB, threshold)) {
                    return false; // Too far apart
                }

                // Tier 2: Accurate stroke distance
                const minDistance = calculateMinStrokeDistance(strokeA, strokeB);
                const isTouching = minDistance <= threshold;

                return isTouching;
            }

            function checkContainment(boundsOuter, boundsInner) {
                // Check if boundsInner is completely contained within boundsOuter
                // Adding small tolerance for hand-drawn shapes (5px)

                // Safety check: ensure both bounds exist
                if (!boundsOuter || !boundsInner) {
                    return false;
                }

                const tolerance = 5;

                const contained = (boundsInner.minX >= boundsOuter.minX - tolerance) &&
                    (boundsInner.maxX <= boundsOuter.maxX + tolerance) &&
                    (boundsInner.minY >= boundsOuter.minY - tolerance) &&
                    (boundsInner.maxY <= boundsOuter.maxY + tolerance);

                return contained;
            }

            function checkProximity(boundsA, boundsB) {
                // Determine directional relationships between two bounding boxes
                // Returns object with directional flags: {left, right, above, below, overlapping}

                // Safety check: ensure both bounds exist
                if (!boundsA || !boundsB) {
                    return { overlapping: false, left: false, right: false, above: false, below: false, distance: Infinity };
                }

                const centerA = {
                    x: (boundsA.minX + boundsA.maxX) / 2,
                    y: (boundsA.minY + boundsA.maxY) / 2
                };
                const centerB = {
                    x: (boundsB.minX + boundsB.maxX) / 2,
                    y: (boundsB.minY + boundsB.maxY) / 2
                };

                const dx = centerB.x - centerA.x;
                const dy = centerB.y - centerA.y;

                // Determine primary direction based on center positions
                const proximity = {
                    overlapping: checkOverlap(boundsA, boundsB),
                    left: dx < -20,    // B is significantly left of A
                    right: dx > 20,    // B is significantly right of A
                    above: dy < -20,   // B is significantly above A
                    below: dy > 20,    // B is significantly below A
                    distance: Math.sqrt(dx * dx + dy * dy)
                };

                return proximity;
            }

            // ===== GEOMETRIC INTERSECTION DETECTION (Phase 3A) =====

            function intersectLineLine(line1Start, line1End, line2Start, line2End) {
                // Check if two line segments intersect
                // Returns intersection point if they intersect, null otherwise

                const x1 = line1Start.x, y1 = line1Start.y;
                const x2 = line1End.x, y2 = line1End.y;
                const x3 = line2Start.x, y3 = line2Start.y;
                const x4 = line2End.x, y4 = line2End.y;

                const denom = (x1 - x2) * (y3 - y4) - (y1 - y2) * (x3 - x4);

                // Lines are parallel or coincident
                if (Math.abs(denom) < 0.0001) return null;

                const t = ((x1 - x3) * (y3 - y4) - (y1 - y3) * (x3 - x4)) / denom;
                const u = -((x1 - x2) * (y1 - y3) - (y1 - y2) * (x1 - x3)) / denom;

                // Check if intersection is within both line segments
                if (t >= 0 && t <= 1 && u >= 0 && u <= 1) {
                    return {
                        x: x1 + t * (x2 - x1),
                        y: y1 + t * (y2 - y1),
                        t: t,  // Position along line1 (0-1)
                        u: u   // Position along line2 (0-1)
                    };
                }

                return null;
            }

            function intersectLineCircle(lineStart, lineEnd, circleCenter, circleRadius) {
                // Check if line segment intersects circle
                // Returns array of intersection points (0, 1, or 2 points)

                const dx = lineEnd.x - lineStart.x;
                const dy = lineEnd.y - lineStart.y;
                const fx = lineStart.x - circleCenter.x;
                const fy = lineStart.y - circleCenter.y;

                const a = dx * dx + dy * dy;
                const b = 2 * (fx * dx + fy * dy);
                const c = (fx * fx + fy * fy) - circleRadius * circleRadius;

                let discriminant = b * b - 4 * a * c;

                // No intersection
                if (discriminant < 0) return [];

                discriminant = Math.sqrt(discriminant);

                const t1 = (-b - discriminant) / (2 * a);
                const t2 = (-b + discriminant) / (2 * a);

                const intersections = [];

                // Check if intersections are within line segment (t between 0 and 1)
                if (t1 >= 0 && t1 <= 1) {
                    intersections.push({
                        x: lineStart.x + t1 * dx,
                        y: lineStart.y + t1 * dy,
                        t: t1
                    });
                }

                if (t2 >= 0 && t2 <= 1 && Math.abs(t2 - t1) > 0.0001) {
                    intersections.push({
                        x: lineStart.x + t2 * dx,
                        y: lineStart.y + t2 * dy,
                        t: t2
                    });
                }

                return intersections;
            }

            function intersectCircleCircle(center1, radius1, center2, radius2) {
                // Check if two circles intersect
                // Returns array of intersection points (0, 1, or 2 points)

                const dx = center2.x - center1.x;
                const dy = center2.y - center1.y;
                const dist = Math.sqrt(dx * dx + dy * dy);

                // Circles don't intersect (too far apart or one contains the other)
                if (dist > radius1 + radius2 || dist < Math.abs(radius1 - radius2)) {
                    return [];
                }

                // Circles are coincident (infinite intersections)
                if (dist < 0.0001 && Math.abs(radius1 - radius2) < 0.0001) {
                    return [];
                }

                // One intersection point (circles are tangent)
                if (Math.abs(dist - (radius1 + radius2)) < 0.0001 ||
                    Math.abs(dist - Math.abs(radius1 - radius2)) < 0.0001) {
                    const t = radius1 / dist;
                    return [{
                        x: center1.x + t * dx,
                        y: center1.y + t * dy
                    }];
                }

                // Two intersection points
                const a = (radius1 * radius1 - radius2 * radius2 + dist * dist) / (2 * dist);
                const h = Math.sqrt(radius1 * radius1 - a * a);

                const px = center1.x + (a / dist) * dx;
                const py = center1.y + (a / dist) * dy;

                return [
                    {
                        x: px + (h / dist) * dy,
                        y: py - (h / dist) * dx
                    },
                    {
                        x: px - (h / dist) * dy,
                        y: py + (h / dist) * dx
                    }
                ];
            }

            function pointInCircle(point, center, radius) {
                // Check if point is inside circle
                const dx = point.x - center.x;
                const dy = point.y - center.y;
                return (dx * dx + dy * dy) <= radius * radius;
            }

            function pointInPolygon(point, vertices) {
                // Ray casting algorithm to check if point is inside polygon
                let inside = false;

                for (let i = 0, j = vertices.length - 1; i < vertices.length; j = i++) {
                    const xi = vertices[i].x, yi = vertices[i].y;
                    const xj = vertices[j].x, yj = vertices[j].y;

                    const intersect = ((yi > point.y) !== (yj > point.y)) &&
                        (point.x < (xj - xi) * (point.y - yi) / (yj - yi) + xi);

                    if (intersect) inside = !inside;
                }

                return inside;
            }

            function detectIntersections(shapeA, shapeB) {
                // High-level intersection detection between two shapes
                // Returns { intersects: boolean, points: [], type: 'line-line'|'line-circle'|'circle-circle' }

                if (!shapeA || !shapeB || !shapeA.definition || !shapeB.definition) {
                    return { intersects: false, points: [], type: null };
                }

                const typeA = shapeA.definition.type;
                const typeB = shapeB.definition.type;

                // Helper: get circle info (handles both circle and ellipse)
                function getCircleInfo(shape) {
                    if (shape.definition.type === 'circle') {
                        return {
                            center: shape.definition.center,
                            radius: shape.definition.radius
                        };
                    } else if (shape.definition.type === 'ellipse') {
                        return {
                            center: shape.definition.center,
                            radius: (shape.definition.radiusX + shape.definition.radiusY) / 2
                        };
                    }
                    return null;
                }

                // Circle-Circle intersection (handles circle, ellipse, or mix)
                if ((typeA === 'circle' || typeA === 'ellipse') && (typeB === 'circle' || typeB === 'ellipse')) {
                    const circleA = getCircleInfo(shapeA);
                    const circleB = getCircleInfo(shapeB);

                    if (circleA && circleB) {
                        const points = intersectCircleCircle(
                            circleA.center,
                            circleA.radius,
                            circleB.center,
                            circleB.radius
                        );
                        return { intersects: points.length > 0, points, type: 'circle-circle' };
                    }
                }

                // Line-Line intersection
                if (typeA === 'segment' && typeB === 'segment') {
                    const intersection = intersectLineLine(
                        shapeA.definition.start,
                        shapeA.definition.end,
                        shapeB.definition.start,
                        shapeB.definition.end
                    );
                    const points = intersection ? [intersection] : [];
                    return { intersects: points.length > 0, points, type: 'line-line' };
                }

                // Line-Circle intersection (or Line-Ellipse)
                if (typeA === 'segment' && (typeB === 'circle' || typeB === 'ellipse')) {
                    const circleB = getCircleInfo(shapeB);
                    if (circleB) {
                        const points = intersectLineCircle(
                            shapeA.definition.start,
                            shapeA.definition.end,
                            circleB.center,
                            circleB.radius
                        );
                        return { intersects: points.length > 0, points, type: 'line-circle' };
                    }
                }

                if ((typeA === 'circle' || typeA === 'ellipse') && typeB === 'segment') {
                    // Swap and call recursively
                    return detectIntersections(shapeB, shapeA);
                }

                // Line-Polygon intersection
                if (typeA === 'segment' && typeB === 'polygon') {
                    const points = [];
                    const vertices = shapeB.definition.vertices;

                    for (let i = 0; i < vertices.length; i++) {
                        const v1 = vertices[i];
                        const v2 = vertices[(i + 1) % vertices.length];
                        const intersection = intersectLineLine(
                            shapeA.definition.start,
                            shapeA.definition.end,
                            v1,
                            v2
                        );
                        if (intersection) points.push(intersection);
                    }

                    return { intersects: points.length > 0, points, type: 'line-polygon' };
                }

                if (typeA === 'polygon' && typeB === 'segment') {
                    // Swap and call recursively
                    return detectIntersections(shapeB, shapeA);
                }

                // Polygon-Polygon intersection (check each edge pair)
                if (typeA === 'polygon' && typeB === 'polygon') {
                    const verticesA = shapeA.definition.vertices;
                    const verticesB = shapeB.definition.vertices;
                    const points = [];

                    for (let i = 0; i < verticesA.length; i++) {
                        const a1 = verticesA[i];
                        const a2 = verticesA[(i + 1) % verticesA.length];

                        for (let j = 0; j < verticesB.length; j++) {
                            const b1 = verticesB[j];
                            const b2 = verticesB[(j + 1) % verticesB.length];

                            const intersection = intersectLineLine(a1, a2, b1, b2);
                            if (intersection) points.push(intersection);
                        }
                    }

                    return { intersects: points.length > 0, points, type: 'polygon-polygon' };
                }

                // Circle-Polygon intersection (check circle against each polygon edge)
                if ((typeA === 'circle' || typeA === 'ellipse') && typeB === 'polygon') {
                    const center = shapeA.definition.center;
                    const radius = typeA === 'circle' ? shapeA.definition.radius :
                        (shapeA.definition.radiusX + shapeA.definition.radiusY) / 2;
                    const vertices = shapeB.definition.vertices;
                    const points = [];

                    for (let i = 0; i < vertices.length; i++) {
                        const v1 = vertices[i];
                        const v2 = vertices[(i + 1) % vertices.length];
                        const intersections = intersectLineCircle(v1, v2, center, radius);
                        points.push(...intersections);
                    }

                    return { intersects: points.length > 0, points, type: 'circle-polygon' };
                }

                if (typeA === 'polygon' && (typeB === 'circle' || typeB === 'ellipse')) {
                    // Swap and call recursively
                    return detectIntersections(shapeB, shapeA);
                }

                // Default: no intersection detected
                return { intersects: false, points: [], type: null };
            }

            // ===== END GEOMETRIC INTERSECTION DETECTION =====

            // ===== GEOMETRIC CONTAINMENT DETECTION (Phase 3A) =====

            function detectContainment(shapeOuter, shapeInner) {
                // Check if shapeInner is contained within shapeOuter
                // Returns { contained: boolean, type: 'circle-in-circle'|'polygon-in-polygon'|etc }

                if (!shapeOuter || !shapeInner || !shapeOuter.definition || !shapeInner.definition) {
                    return { contained: false, type: null };
                }

                const typeOuter = shapeOuter.definition.type;
                const typeInner = shapeInner.definition.type;

                // Circle contains circle
                if (typeOuter === 'circle' && typeInner === 'circle') {
                    const centerDist = distance(shapeOuter.definition.center, shapeInner.definition.center);
                    const radiusDiff = shapeOuter.definition.radius - shapeInner.definition.radius;
                    const contained = centerDist + shapeInner.definition.radius <= shapeOuter.definition.radius;
                    return { contained, type: 'circle-in-circle', centerDistance: centerDist, radiusDiff };
                }

                // Circle contains ellipse (approximate)
                if (typeOuter === 'circle' && typeInner === 'ellipse') {
                    const centerDist = distance(shapeOuter.definition.center, shapeInner.definition.center);
                    const maxInnerRadius = Math.max(shapeInner.definition.radiusX, shapeInner.definition.radiusY);
                    const contained = centerDist + maxInnerRadius <= shapeOuter.definition.radius;
                    return { contained, type: 'circle-in-ellipse', centerDistance: centerDist };
                }

                // Polygon contains point (test all vertices of inner shape)
                if (typeOuter === 'polygon' && typeInner === 'polygon') {
                    const outerVertices = shapeOuter.definition.vertices;
                    const innerVertices = shapeInner.definition.vertices;

                    // Check if all vertices of inner polygon are inside outer polygon
                    const allInside = innerVertices.every(vertex => pointInPolygon(vertex, outerVertices));
                    return { contained: allInside, type: 'polygon-in-polygon' };
                }

                // Polygon contains circle (check if center + radius are within polygon)
                if (typeOuter === 'polygon' && (typeInner === 'circle' || typeInner === 'ellipse')) {
                    const outerVertices = shapeOuter.definition.vertices;
                    const center = shapeInner.definition.center;

                    // Check if center is inside
                    if (!pointInPolygon(center, outerVertices)) {
                        return { contained: false, type: 'polygon-in-circle' };
                    }

                    // Check if all edge points are inside (sample 8 points around circle)
                    const radius = typeInner === 'circle' ? shapeInner.definition.radius :
                        Math.max(shapeInner.definition.radiusX, shapeInner.definition.radiusY);

                    for (let i = 0; i < 8; i++) {
                        const angle = (i / 8) * Math.PI * 2;
                        const testPoint = {
                            x: center.x + radius * Math.cos(angle),
                            y: center.y + radius * Math.sin(angle)
                        };
                        if (!pointInPolygon(testPoint, outerVertices)) {
                            return { contained: false, type: 'polygon-in-circle' };
                        }
                    }

                    return { contained: true, type: 'polygon-in-circle' };
                }

                // Circle contains polygon (check if all vertices are within circle)
                if ((typeOuter === 'circle' || typeOuter === 'ellipse') && typeInner === 'polygon') {
                    const center = shapeOuter.definition.center;
                    const radius = typeOuter === 'circle' ? shapeOuter.definition.radius :
                        Math.min(shapeOuter.definition.radiusX, shapeOuter.definition.radiusY);
                    const innerVertices = shapeInner.definition.vertices;

                    const allInside = innerVertices.every(vertex => pointInCircle(vertex, center, radius));
                    return { contained: allInside, type: 'circle-in-polygon' };
                }

                // Default: use bounding box containment as fallback
                const outerBounds = shapeOuter.rendering?.bounds;
                const innerBounds = shapeInner.rendering?.bounds;

                // Safety check: ensure bounds exist
                if (!outerBounds || !innerBounds) {
                    return { contained: false, type: 'bounds-unavailable' };
                }

                const contained = checkContainment(outerBounds, innerBounds);
                return { contained, type: 'bounds-based' };
            }

            // ===== END GEOMETRIC CONTAINMENT DETECTION =====

            // ===== PHASE 3B: PARALLEL/PERPENDICULAR DETECTION =====

            // Normalize angle to 0-180° range (lines don't have direction)
            function normalizeAngle(radians) {
                let degrees = (radians * 180 / Math.PI) % 180;
                if (degrees < 0) degrees += 180;
                return degrees;
            }

            // Calculate smallest angle difference between two angles
            function angleDifference(angle1Deg, angle2Deg) {
                const diff = Math.abs(angle1Deg - angle2Deg);
                // Handle wrap-around: 179° and 1° are only 2° apart
                return Math.min(diff, 180 - diff);
            }

            // Build angle buckets for efficient parallel detection
            function buildAngleBuckets(components) {
                const bucketSize = 5; // 5° buckets
                const buckets = {};

                components.forEach((comp, idx) => {
                    const shape = comp.geometricShape;
                    if (!shape || !shape.definition) return;

                    let angle = null;

                    // Extract angle from different shape types
                    if (shape.definition.type === 'segment') {
                        // Line segment - use its angle
                        angle = shape.definition.angle;
                    } else if (shape.definition.type === 'polygon' && shape.definition.sides) {
                        // Polygon - extract angles from all sides
                        shape.definition.sides.forEach(side => {
                            const sideAngle = normalizeAngle(side.angle);
                            const bucketKey = Math.floor(sideAngle / bucketSize) * bucketSize;
                            if (!buckets[bucketKey]) buckets[bucketKey] = [];
                            buckets[bucketKey].push({
                                componentIdx: idx,
                                angle: sideAngle,
                                type: 'polygon-edge',
                                side: side
                            });
                        });
                        return; // Don't add to bucket again below
                    }

                    if (angle !== null) {
                        const normalizedAngle = normalizeAngle(angle);
                        const bucketKey = Math.floor(normalizedAngle / bucketSize) * bucketSize;
                        if (!buckets[bucketKey]) buckets[bucketKey] = [];
                        buckets[bucketKey].push({
                            componentIdx: idx,
                            angle: normalizedAngle,
                            type: 'line'
                        });
                    }
                });

                return buckets;
            }

            // Detect parallel clusters within ±1°
            function detectParallelClusters(angleBuckets, components) {
                const PARALLEL_TOLERANCE = 1.0; // ±1° for parallel
                const clusters = [];
                const processed = new Set();

                Object.entries(angleBuckets).forEach(([bucketKey, items]) => {
                    if (items.length < 2) return;

                    // Also check adjacent buckets (angles near bucket boundaries)
                    const adjacentBuckets = [
                        angleBuckets[parseInt(bucketKey) - 5] || [],
                        items,
                        angleBuckets[parseInt(bucketKey) + 5] || []
                    ].flat();

                    items.forEach(item => {
                        if (processed.has(item.componentIdx)) return;

                        const cluster = [item];
                        const baseAngle = item.angle;

                        adjacentBuckets.forEach(other => {
                            if (other.componentIdx === item.componentIdx) return;
                            if (processed.has(other.componentIdx)) return;

                            const diff = angleDifference(baseAngle, other.angle);
                            if (diff <= PARALLEL_TOLERANCE) {
                                // Additional spatial check: use existing overlap detection
                                const boundsA = components[item.componentIdx].bounds;
                                const boundsB = components[other.componentIdx].bounds;

                                // Only cluster if shapes are reasonably close (not on opposite sides of canvas)
                                const distanceCheck = checkProximity(boundsA, boundsB);
                                const isClose = distanceCheck.above.length > 0 ||
                                    distanceCheck.below.length > 0 ||
                                    distanceCheck.left.length > 0 ||
                                    distanceCheck.right.length > 0 ||
                                    checkOverlap(boundsA, boundsB);

                                if (isClose) {
                                    cluster.push(other);
                                }
                            }
                        });

                        if (cluster.length >= 2) {
                            cluster.forEach(c => processed.add(c.componentIdx));

                            const angles = cluster.map(c => c.angle);
                            const avgAngle = angles.reduce((sum, a) => sum + a, 0) / angles.length;
                            const maxDiff = Math.max(...angles.map(a => angleDifference(a, avgAngle)));

                            clusters.push({
                                shapes: cluster.map(c => c.componentIdx),
                                angle: avgAngle,
                                maxAngleDiff: maxDiff,
                                items: cluster // keep reference to items for debugging
                            });
                        }
                    });
                });

                return clusters;
            }

            // Detect perpendicular relationships between clusters (or individual shapes)
            function detectPerpendicularPairs(parallelClusters, components) {
                const PERPENDICULAR_TOLERANCE = 1.0; // ±1° from perfect 90°
                const pairs = [];

                // Check all cluster pairs
                for (let i = 0; i < parallelClusters.length; i++) {
                    for (let j = i + 1; j < parallelClusters.length; j++) {
                        const clusterA = parallelClusters[i];
                        const clusterB = parallelClusters[j];

                        const angleDiff = angleDifference(clusterA.angle, clusterB.angle);
                        const perpDiff = Math.abs(angleDiff - 90);

                        if (perpDiff <= PERPENDICULAR_TOLERANCE) {
                            // Check spatial proximity: at least one pair of shapes should be close
                            let hasCloseShapes = false;

                            for (const idxA of clusterA.shapes) {
                                for (const idxB of clusterB.shapes) {
                                    const boundsA = components[idxA].bounds;
                                    const boundsB = components[idxB].bounds;

                                    const distanceCheck = checkProximity(boundsA, boundsB);
                                    const isClose = distanceCheck.above.length > 0 ||
                                        distanceCheck.below.length > 0 ||
                                        distanceCheck.left.length > 0 ||
                                        distanceCheck.right.length > 0 ||
                                        checkOverlap(boundsA, boundsB);

                                    if (isClose) {
                                        hasCloseShapes = true;
                                        break;
                                    }
                                }
                                if (hasCloseShapes) break;
                            }

                            if (hasCloseShapes) {
                                pairs.push({
                                    clusterA: i,
                                    clusterB: j,
                                    angle1: clusterA.angle,
                                    angle2: clusterB.angle,
                                    angleDiff: angleDiff,
                                    perpDiff: perpDiff
                                });
                            }
                        }
                    }
                }

                return pairs;
            }

            // ===== END PHASE 3B: PARALLEL/PERPENDICULAR DETECTION =====

            // ===== PHASE 3C: ORDER-INVARIANT COMPOSITION MATCHING =====

            // Canonicalize components for order-invariant matching
            function canonicalizeComponents(components) {
                // Sort by: type (alphabetical) → size (largest first) → position (top-left to bottom-right)
                return components.map((comp, idx) => ({
                    originalIndex: idx,
                    type: comp.recognizedAs || 'unknown',
                    size: (comp.bounds.maxX - comp.bounds.minX) * (comp.bounds.maxY - comp.bounds.minY),
                    centerX: (comp.bounds.minX + comp.bounds.maxX) / 2,
                    centerY: (comp.bounds.minY + comp.bounds.maxY) / 2,
                    bounds: comp.bounds,
                    component: comp
                })).sort((a, b) => {
                    // Primary: type (alphabetical)
                    if (a.type !== b.type) return a.type.localeCompare(b.type);
                    // Secondary: size (largest first)
                    if (Math.abs(a.size - b.size) > 100) return b.size - a.size;
                    // Tertiary: position (top-left to bottom-right)
                    if (Math.abs(a.centerY - b.centerY) > 50) return a.centerY - b.centerY;
                    return a.centerX - b.centerX;
                });
            }

            // Create order-invariant composition fingerprint
            function createCompositionFingerprint(components, spatialGraph) {
                const canonical = canonicalizeComponents(components);

                // PHASE 6C FIX: Normalize artN types to generic "art" for matching
                // This allows "art0", "art1" from saved compositions to match new "art0" from canvas
                const normalizedCanonical = canonical.map(c => ({
                    ...c,
                    type: c.type.startsWith('art') ? 'art' : c.type
                }));

                // Component histogram (type counts) - use normalized types
                const typeHistogram = {};
                normalizedCanonical.forEach(c => {
                    typeHistogram[c.type] = (typeHistogram[c.type] || 0) + 1;
                });

                // Relationship histogram (unordered counts)
                const relationshipHistogram = {
                    touching: spatialGraph.connections.filter(c => c.relationship === 'touching').length,
                    intersecting: spatialGraph.connections.filter(c => c.relationship === 'intersecting').length,
                    containment: spatialGraph.containment.length
                };

                // Topology hash (canonical string representation) - use normalized types
                const typeString = normalizedCanonical.map(c => c.type).join('+');
                const relString = Object.entries(relationshipHistogram)
                    .filter(([k, v]) => v > 0)
                    .map(([k, v]) => `${v}${k}`)
                    .join('-');
                const topologyHash = `${typeString}${relString ? '-' + relString : ''}`;

                return {
                    componentTypes: normalizedCanonical.map(c => c.type),
                    componentCount: components.length,
                    typeHistogram,
                    relationshipHistogram,
                    topologyHash,
                    canonicalOrder: canonical.map(c => c.originalIndex)
                };
            }

            // Compare geometric fingerprints for similarity (used for "art" type matching)
            function compareGeometricFingerprints(fp1, fp2) {
                // Returns similarity score 0-1 based on geometric features

                // DAY 5 FIX: VETO CHECK - reject fundamentally incompatible shapes
                // If straightness differs by > 0.5, shapes are too different (straight vs curvy)
                const straightnessDiff = Math.abs(fp1.straightness - fp2.straightness);
                if (straightnessDiff > 0.5) {
                    console.log(`  ❌ Geometric veto: straightness too different (${straightnessDiff.toFixed(2)} > 0.5)`);
                    return 0; // Reject match
                }

                let totalScore = 0;
                let weights = 0;

                // Straightness similarity (weight: 0.3)
                const straightnessScore = Math.max(0, 1 - straightnessDiff);
                totalScore += straightnessScore * 0.3;
                weights += 0.3;

                // Aspect ratio similarity (weight: 0.25)
                const aspectRatio1 = Math.min(fp1.aspectRatio, 1 / fp1.aspectRatio); // Normalize to 0-1
                const aspectRatio2 = Math.min(fp2.aspectRatio, 1 / fp2.aspectRatio);
                const aspectDiff = Math.abs(aspectRatio1 - aspectRatio2);
                const aspectScore = Math.max(0, 1 - aspectDiff * 2); // More sensitive
                totalScore += aspectScore * 0.25;
                weights += 0.25;

                // Corner count similarity (weight: 0.2)
                const cornerDiff = Math.abs(fp1.corners - fp2.corners);
                const cornerScore = Math.max(0, 1 - cornerDiff / 4); // Allow up to 4 corner difference
                totalScore += cornerScore * 0.2;
                weights += 0.2;

                // Closure similarity (weight: 0.15)
                const closureMatch = (fp1.isClosed === fp2.isClosed) ? 1.0 : 0.0;
                totalScore += closureMatch * 0.15;
                weights += 0.15;

                // Size similarity (weight: 0.1) - normalized by relative difference
                const sizeDiff = Math.abs(fp1.size - fp2.size) / Math.max(fp1.size, fp2.size);
                const sizeScore = Math.max(0, 1 - sizeDiff);
                totalScore += sizeScore * 0.1;
                weights += 0.1;

                return totalScore / weights;
            }

            // Match two composition fingerprints
            function matchCompositionFingerprints(fp1, fp2, threshold = 0.8, components1 = null, components2 = null) {
                // Safety checks
                if (!fp1 || !fp2) {
                    console.error('matchCompositionFingerprints: null fingerprint', { fp1, fp2 });
                    return { matches: false, score: 0 };
                }
                if (!fp1.componentCount || !fp2.componentCount) {
                    console.error('matchCompositionFingerprints: missing componentCount', { fp1, fp2 });
                    return { matches: false, score: 0 };
                }

                // Quick reject: different component counts
                if (fp1.componentCount !== fp2.componentCount) return { matches: false, score: 0 };

                // Flexible topology hash check - if template hash doesn't include relationships, just check types
                const hash1Base = fp1.topologyHash.split('-')[0]; // Get "line+triangle" part
                const hash2Base = fp2.topologyHash.split('-')[0];
                if (hash1Base !== hash2Base) return { matches: false, score: 0 };

                // Detailed matching
                let score = 1.0;

                // Type histogram match
                const allTypes = new Set([...Object.keys(fp1.typeHistogram), ...Object.keys(fp2.typeHistogram)]);
                let typeMatches = 0;
                let typeMismatches = 0;
                allTypes.forEach(type => {
                    const count1 = fp1.typeHistogram[type] || 0;
                    const count2 = fp2.typeHistogram[type] || 0;
                    if (count1 === count2) typeMatches++;
                    else typeMismatches += Math.abs(count1 - count2);
                });
                const typeScore = typeMatches / (typeMatches + typeMismatches);
                score *= typeScore;

                // Relationship match - now supports fuzzy matching!
                let relScore = 1.0;
                if (fp2.relationshipHistogram !== null) {
                    const relKeys = ['touching', 'intersecting', 'containment'];

                    if (fp2.fuzzyRelationships) {
                        // FUZZY MODE: Proportional scoring with tolerance
                        let totalScore = 0;
                        const relDetails = {};

                        // Check if saved composition has ANY relationships
                        const savedHasRelationships = relKeys.some(key => (fp2.relationshipHistogram[key] || 0) > 0);
                        const canvasHasRelationships = relKeys.some(key => (fp1.relationshipHistogram[key] || 0) > 0);

                        // CRITICAL: If saved has relationships, canvas MUST have some too
                        if (savedHasRelationships && !canvasHasRelationships) {
                            console.log('🔍 Fuzzy relationship FAIL: Saved has relationships but canvas has none');
                            return { matches: false, score: 0, typeScore, relScore: 0 };
                        }

                        relKeys.forEach(key => {
                            const val1 = fp1.relationshipHistogram[key] || 0;
                            const val2 = fp2.relationshipHistogram[key] || 0;
                            const diff = Math.abs(val1 - val2);

                            // Score based on difference: 0 diff = 1.0, 1 diff = 0.7, 2 diff = 0.4, 3+ diff = 0.0
                            let keyScore = 1.0;
                            if (diff === 1) keyScore = 0.7;
                            else if (diff === 2) keyScore = 0.4;
                            else if (diff >= 3) keyScore = 0.0;

                            totalScore += keyScore;
                            relDetails[key] = { canvas: val1, saved: val2, diff: diff, score: keyScore };
                        });

                        relScore = totalScore / relKeys.length;
                        console.log('🔍 Fuzzy relationship scoring:', relDetails, `Score: ${relScore.toFixed(3)}`);
                        score *= relScore;
                    } else {
                        // STRICT MODE: Exact match required
                        let relMatches = 0;
                        const relDetails = {};
                        relKeys.forEach(key => {
                            const val1 = fp1.relationshipHistogram[key] || 0;
                            const val2 = fp2.relationshipHistogram[key] || 0;
                            relDetails[key] = { canvas: val1, saved: val2, match: val1 === val2 };
                            if (val1 === val2) relMatches++;
                        });
                        relScore = relMatches / relKeys.length;
                        console.log('🔍 Strict relationship comparison:', relDetails, `Score: ${relMatches}/${relKeys.length} = ${relScore}`);
                        score *= relScore;
                    }
                } else {
                    console.log('🔍 Null relationships (ignored)');
                }
                // Otherwise: relationship doesn't affect score (flexible matching)

                // Geometric similarity for "art" types (unrecognized shapes)
                let geometricScore = 1.0;
                if (components1 && components2) {
                    // Both have components - check geometric similarity for "art" types
                    const artComponents1 = components1.filter(c => c.type === 'art');
                    const artComponents2 = components2.filter(c => c.type === 'art');

                    if (artComponents1.length > 0 && artComponents1.length === artComponents2.length) {
                        // Compare each art component's geometric fingerprint
                        let totalGeomScore = 0;
                        for (let i = 0; i < artComponents1.length; i++) {
                            const fp1 = artComponents1[i].fingerprint;
                            const fp2 = artComponents2[i].fingerprint;
                            const geomSimilarity = compareGeometricFingerprints(fp1, fp2);
                            totalGeomScore += geomSimilarity;
                            console.log(`🔍 Art component ${i} geometric similarity:`, geomSimilarity.toFixed(3));
                        }
                        geometricScore = totalGeomScore / artComponents1.length;
                        console.log('🔍 Overall geometric score:', geometricScore.toFixed(3));
                        score *= geometricScore;
                    }
                }

                return {
                    matches: score >= threshold,
                    score,
                    typeScore,
                    relScore,
                    geometricScore
                };
            }

            // ===== END PHASE 3C: ORDER-INVARIANT COMPOSITION MATCHING =====

            // ===== END SPATIAL UTILITIES =====

            function buildSpatialGraph(components) {
                // Build a comprehensive spatial graph from an array of components
                // Each component should have: {bounds, recognizedAs, originalStroke, fingerprint, geometricShape}
                // Returns: {connections, containment, proximity, intersections}
                // Phase 3A: Enhanced with geometric intersection and containment detection

                const graph = {
                    connections: [],   // [{a, b, relationship}, ...] - strokes that touch/overlap
                    containment: [],   // [{outer, inner, type}, ...] - inner stroke is inside outer stroke
                    proximity: {},      // {i: {left: [j], right: [k], ...}} - directional relationships
                    intersections: []   // [{a, b, points, type}, ...] - geometric intersections (Phase 3A)
                };

                // Analyze all pairs of components
                for (let i = 0; i < components.length; i++) {
                    const compA = components[i];
                    graph.proximity[i] = { left: [], right: [], above: [], below: [] };

                    for (let j = i + 1; j < components.length; j++) {
                        const compB = components[j];

                        // Get strokes (prefer refined if available, fall back to original)
                        const strokeA = flattenStroke(compA.refinedStroke || compA.originalStroke);
                        const strokeB = flattenStroke(compB.refinedStroke || compB.originalStroke);

                        // PHASE 3A: Geometric intersection detection
                        if (compA.geometricShape && compB.geometricShape) {
                            const intersection = detectIntersections(compA.geometricShape, compB.geometricShape);

                            if (intersection.intersects) {
                                graph.intersections.push({
                                    a: i,
                                    b: j,
                                    points: intersection.points,
                                    type: intersection.type
                                });
                                // Also mark as connected (intersecting shapes are connected)
                                graph.connections.push({ a: i, b: j, relationship: 'intersecting' });
                            }
                        }

                        // Legacy: Check for connections (touching or overlapping) using accurate distance
                        // This catches cases where shapes are close but may not geometrically intersect
                        // Increased threshold to 50px to account for hand-drawn variability and refinement gaps
                        if (checkTouching(strokeA, strokeB, compA.bounds, compB.bounds, 50)) {
                            // Only add if not already marked as intersecting
                            const alreadyConnected = graph.connections.some(c =>
                                (c.a === i && c.b === j) || (c.a === j && c.b === i)
                            );
                            if (!alreadyConnected) {
                                graph.connections.push({ a: i, b: j, relationship: 'touching' });
                            }
                        }

                        // PHASE 3A: Geometric containment detection
                        if (compA.geometricShape && compB.geometricShape) {
                            const containsB = detectContainment(compA.geometricShape, compB.geometricShape);
                            if (containsB.contained) {
                                graph.containment.push({ outer: i, inner: j, type: containsB.type });
                            }

                            const containsA = detectContainment(compB.geometricShape, compA.geometricShape);
                            if (containsA.contained) {
                                graph.containment.push({ outer: j, inner: i, type: containsA.type });
                            }
                        } else {
                            // Fallback to bounding box containment
                            if (checkContainment(compA.bounds, compB.bounds)) {
                                graph.containment.push({ outer: i, inner: j, type: 'bounds-based' });
                            } else if (checkContainment(compB.bounds, compA.bounds)) {
                                graph.containment.push({ outer: j, inner: i, type: 'bounds-based' });
                            }
                        }

                        // Check proximity/directional relationships (only if not connected)
                        // Use distance-based check to differentiate overlap from proximity
                        const minDistance = aabbsNear(compA.bounds, compB.bounds, 100)
                            ? calculateMinStrokeDistance(strokeA, strokeB)
                            : Infinity;

                        const proximity = checkProximity(compA.bounds, compB.bounds);

                        // Only record proximity if shapes are near but NOT touching
                        if (minDistance > 50 && minDistance < 100) {
                            // Add directional relationships from A's perspective
                            if (proximity.left) graph.proximity[i].left.push(j);
                            if (proximity.right) graph.proximity[i].right.push(j);
                            if (proximity.above) graph.proximity[i].above.push(j);
                            if (proximity.below) graph.proximity[i].below.push(j);

                            // Add inverse relationships from B's perspective
                            if (!graph.proximity[j]) {
                                graph.proximity[j] = { left: [], right: [], above: [], below: [] };
                            }
                            if (proximity.right) graph.proximity[j].left.push(i);
                            if (proximity.left) graph.proximity[j].right.push(i);
                            if (proximity.below) graph.proximity[j].above.push(i);
                            if (proximity.above) graph.proximity[j].below.push(i);
                        }
                    }
                }

                // PHASE 3B: Parallel and perpendicular detection using angle clustering
                const angleBuckets = buildAngleBuckets(components);
                const parallelClusters = detectParallelClusters(angleBuckets, components);
                const perpendicularPairs = detectPerpendicularPairs(parallelClusters, components);

                graph.parallelClusters = parallelClusters;
                graph.perpendicularPairs = perpendicularPairs;

                return graph;
            }

            function analyzeStrokeDetailed(points) {
                const fp = getFingerprint(points);
                const results = [];
                const checks = [];

                // STRATEGY: Test shapes in priority order (specific → generic)
                // Priority Order:
                // 1. Line (open + straight) - FITTING METHOD, not in library
                // 2. Arc (open + curved) - FITTING METHOD, not in library
                // 3. Triangle (3 corners + closed) - library primitive
                // 4. Rectangle (4 corners + closed) - library primitive
                // 5. Circle (closed + curved, any aspect ratio) - library primitive, catch-all for curves
                //
                // Note: Line and Arc are curve fitting methods, not reusable shapes
                // Circle handles both circular and elliptical (aspect ratio is a parameter)

                // Check for overshoot once (used by circle/ellipse/arc)
                const hasOvershoot = checkOvershoot(points);

                // 1. LINE checks (test first - open + straight)
                const lineChecks = {
                    isStraight: fp.straightness > 0.65,
                    notClosed: !fp.isClosed && !hasOvershoot,
                    fewCorners: fp.corners <= 2
                };

                checks.push({
                    shape: 'Line',
                    passed: lineChecks.isStraight && lineChecks.notClosed && lineChecks.fewCorners,
                    conditions: [
                        { test: 'Is straight?', pass: lineChecks.isStraight, detail: `Straightness: ${fp.straightness.toFixed(2)} (need: >0.65)` },
                        { test: 'Not closed?', pass: lineChecks.notClosed, detail: `End distance: ${fp.closureDistance.toFixed(1)}px` },
                        { test: 'Few corners?', pass: lineChecks.fewCorners, detail: `Corners: ${fp.corners} (need: ≤2)` }
                    ]
                });

                if (lineChecks.isStraight && lineChecks.notClosed && lineChecks.fewCorners) {
                    results.push({ type: 'line', confidence: 0.9, label: 'Line' });
                }

                // 2. ARC checks (open + curved)
                const arcChecks = {
                    notClosed: !fp.isClosed && !hasOvershoot,
                    fewCorners: fp.corners <= 1,
                    isCurved: fp.straightness < 0.6
                };

                checks.push({
                    shape: 'Arc',
                    passed: arcChecks.notClosed && arcChecks.fewCorners && arcChecks.isCurved,
                    conditions: [
                        { test: 'Not closed?', pass: arcChecks.notClosed, detail: `End distance: ${fp.closureDistance.toFixed(1)}px` },
                        { test: 'Few corners?', pass: arcChecks.fewCorners, detail: `Corners: ${fp.corners} (need: ≤1)` },
                        { test: 'Is curved?', pass: arcChecks.isCurved, detail: `Straightness: ${fp.straightness.toFixed(2)} (need: <0.6)` }
                    ]
                });

                if (arcChecks.notClosed && arcChecks.fewCorners && arcChecks.isCurved) {
                    results.push({ type: 'arc', confidence: 0.7, label: 'Arc' });
                }

                // 3. Triangle checks
                const triangleChecks = {
                    isClosed: fp.isClosed,
                    hasThreeCorners: fp.corners >= 2 && fp.corners <= 3,  // 2-3 corners (hand-drawn may miss one)
                    reasonableShape: fp.aspectRatio >= 0.3 && fp.aspectRatio <= 3.0
                };

                checks.push({
                    shape: 'Triangle',
                    passed: triangleChecks.isClosed && triangleChecks.hasThreeCorners && triangleChecks.reasonableShape,
                    conditions: [
                        { test: 'Is closed?', pass: triangleChecks.isClosed, detail: `End distance: ${fp.closureDistance.toFixed(1)}px (checks overshoot too)` },
                        { test: 'Has 3 corners?', pass: triangleChecks.hasThreeCorners, detail: `Corners: ${fp.corners} (need: 2-3)` },
                        { test: 'Reasonable shape?', pass: triangleChecks.reasonableShape, detail: `Aspect: ${fp.aspectRatio.toFixed(2)} (need: 0.3-3.0)` }
                    ]
                });

                if (triangleChecks.isClosed && triangleChecks.hasThreeCorners && triangleChecks.reasonableShape) {
                    results.push({ type: 'triangle', confidence: 0.85, label: 'Triangle' });
                }

                // Rectangle checks
                const rectangleChecks = {
                    isClosed: fp.isClosed,
                    hasFourCorners: fp.corners >= 3 && fp.corners <= 4,  // 3-4 corners (hand-drawn may miss one)
                    aspectRatioOk: fp.aspectRatio > 0.3 && fp.aspectRatio < 3.0
                };

                checks.push({
                    shape: 'Rectangle',
                    passed: rectangleChecks.isClosed && rectangleChecks.hasFourCorners && rectangleChecks.aspectRatioOk,
                    conditions: [
                        { test: 'Is closed?', pass: rectangleChecks.isClosed, detail: `End distance: ${fp.closureDistance.toFixed(1)}px` },
                        { test: 'Has 4 corners?', pass: rectangleChecks.hasFourCorners, detail: `Corners: ${fp.corners} (need: 3-4)` },
                        { test: 'Reasonable shape?', pass: rectangleChecks.aspectRatioOk, detail: `Aspect: ${fp.aspectRatio.toFixed(2)} (need: 0.3-3.0)` }
                    ]
                });

                if (rectangleChecks.isClosed && rectangleChecks.hasFourCorners && rectangleChecks.aspectRatioOk) {
                    results.push({ type: 'rectangle', confidence: 0.8, label: 'Rectangle' });
                }

                // 5. CIRCLE checks (closed + curved, any aspect ratio) - GENERIC CATCH-ALL for curves
                // Note: Circle can be circular (aspectRatio ~1) or elliptical (aspectRatio ≠ 1)
                // Both are the same primitive, just with different aspectRatio parameter
                const circleChecks = {
                    isClosed: fp.isClosed || hasOvershoot,
                    fewCorners: fp.corners <= 1,
                    notStraight: fp.straightness < 0.5,
                    reasonableRatio: fp.aspectRatio >= 0.3 && fp.aspectRatio <= 3.0  // Accept any reasonable aspect ratio
                };

                checks.push({
                    shape: 'Circle',
                    passed: circleChecks.isClosed && circleChecks.fewCorners && circleChecks.notStraight && circleChecks.reasonableRatio,
                    conditions: [
                        { test: 'Is closed?', pass: circleChecks.isClosed, detail: `End: ${fp.closureDistance.toFixed(1)}px ${hasOvershoot ? '(overshoot ✓)' : ''}` },
                        { test: 'Few corners?', pass: circleChecks.fewCorners, detail: `Corners: ${fp.corners} (need: ≤1)` },
                        { test: 'Is curved?', pass: circleChecks.notStraight, detail: `Straightness: ${fp.straightness.toFixed(2)} (need: <0.5)` },
                        { test: 'Reasonable ratio?', pass: circleChecks.reasonableRatio, detail: `Ratio: ${fp.aspectRatio.toFixed(2)} (0.3-3.0)${Math.abs(fp.aspectRatio - 1) > 0.4 ? ' [elliptical]' : ' [circular]'}` }
                    ]
                });

                if (circleChecks.isClosed && circleChecks.fewCorners && circleChecks.notStraight && circleChecks.reasonableRatio) {
                    results.push({ type: 'circle', confidence: 0.8, label: 'Circle' });
                }

                // FEATURE-BASED WEIGHTED SCORING SYSTEM
                // Each shape scored on: Corner Match (40%) + Straightness (40%) + Aspect Ratio (20%)
                // Disqualifying features eliminate shapes entirely
                // Note: hasOvershoot already declared above for circle checks
                const scoredResults = [];
                const scoringDetails = { circle: {}, triangle: {}, rectangle: {}, line: {} };

                // Helper function to calculate component scores
                // New 4-component system: Corner Count (25%) + Angle Quality (25%) + Straightness (30%) + Aspect Ratio (20%)
                function calculateScore(cornerScore, angleScore, straightnessScore, aspectScore) {
                    return Math.round(cornerScore * 0.25 + angleScore * 0.25 + straightnessScore * 0.30 + aspectScore * 0.20);
                }

                // Continuous scoring functions - map raw values to 0-100 smoothly
                function scoreCurviness(straightness) {
                    // For circles: lower straightness = higher score
                    // Ideal: 0 (completely curved) = 100
                    // Disqualify: 0.3+ (too straight)
                    if (straightness >= 0.3) return 0;
                    return 100 * (1 - straightness / 0.3);
                }

                function scoreStraightness(straightness) {
                    // For lines: higher straightness = higher score
                    // Ideal: 1.0 (perfectly straight) = 100
                    // Disqualify: <0.65 (too curved)
                    if (straightness < 0.65) return 0;
                    return 100 * ((straightness - 0.65) / (1.0 - 0.65));
                }

                function scoreRoundness(aspectRatio) {
                    // For circles: closer to 1.0 = higher score
                    // Ideal: 1.0 (perfect circle) = 100
                    // Maximum deviation: 0.8 (score drops to 0)
                    const deviation = Math.abs(aspectRatio - 1.0);
                    if (deviation >= 0.8) return 0;
                    return 100 * (1 - deviation / 0.8);
                }

                function scoreAspectRange(aspectRatio, minRatio, maxRatio) {
                    // For shapes with acceptable aspect ranges
                    // Penalty for being outside the comfortable range
                    if (aspectRatio < minRatio) {
                        // Too thin
                        const deviation = minRatio - aspectRatio;
                        return Math.max(0, 100 - deviation * 100);
                    } else if (aspectRatio > maxRatio) {
                        // Too wide
                        const deviation = aspectRatio - maxRatio;
                        return Math.max(0, 100 - deviation * 100);
                    }
                    return 100;
                }

                function scoreLineElongation(aspectRatio) {
                    // For lines: more elongated = higher score
                    // Ideal: very elongated (>5) = 100
                    // Minimum acceptable: 2.0
                    if (aspectRatio < 2.0) return 0;
                    if (aspectRatio >= 5.0) return 100;
                    // Linear scale from 2.0 to 5.0
                    return ((aspectRatio - 2.0) / (5.0 - 2.0)) * 100;
                }

                // ===== CIRCLE SCORING =====
                let circleCornerScore = 0;
                let circleAngleScore = 0;
                let circleStraightnessScore = 0;
                let circleAspectScore = 0;
                let circleDisqualified = false;

                // 1. DISQUALIFYING: Must be closed
                scoringDetails.circle.closed = fp.isClosed || hasOvershoot;
                if (!scoringDetails.circle.closed) {
                    circleDisqualified = true;
                    scoringDetails.circle.closedPoints = 'DISQUALIFIED (not closed)';
                } else {
                    scoringDetails.circle.closedPoints = '✓ closed';
                }

                // 2. CORNER COUNT SCORE (25%): 0-100 based on corner count
                if (fp.corners === 0) {
                    circleCornerScore = 100;
                    scoringDetails.circle.cornerScore = '100 (no corners)';
                } else if (fp.corners === 1) {
                    circleCornerScore = 70;
                    scoringDetails.circle.cornerScore = '70 (1 corner)';
                } else {
                    circleCornerScore = 0;
                    circleDisqualified = true;
                    scoringDetails.circle.cornerScore = `0 (${fp.corners} corners)`;
                }

                // 3. ANGLE QUALITY SCORE (25%): For circles, no angles should exist
                if (fp.corners === 0) {
                    circleAngleScore = 100;
                    scoringDetails.circle.angleScore = '100 (smooth, no angles)';
                } else if (fp.corners === 1) {
                    circleAngleScore = 50;
                    scoringDetails.circle.angleScore = '50 (one angle detected)';
                } else {
                    circleAngleScore = 0;
                    scoringDetails.circle.angleScore = '0 (multiple angles)';
                }

                // 4. STRAIGHTNESS SCORE (30%): Must be curved (continuous scoring)
                circleStraightnessScore = scoreCurviness(fp.straightness);
                if (circleStraightnessScore === 0) {
                    circleDisqualified = true;
                    scoringDetails.circle.straightnessScore = `0 (too straight: ${fp.straightness.toFixed(3)})`;
                } else {
                    scoringDetails.circle.straightnessScore = `${Math.round(circleStraightnessScore)} (straightness: ${fp.straightness.toFixed(3)})`;
                }

                // 5. ASPECT RATIO SCORE (20%): Roundness (continuous scoring)
                circleAspectScore = scoreRoundness(fp.aspectRatio);
                scoringDetails.circle.aspectScore = `${Math.round(circleAspectScore)} (ratio: ${fp.aspectRatio.toFixed(2)})`;

                const circleFinalScore = circleDisqualified ? 0 : calculateScore(circleCornerScore, circleAngleScore, circleStraightnessScore, circleAspectScore);
                scoringDetails.circle.total = circleFinalScore;
                scoringDetails.circle.breakdown = `(${Math.round(circleCornerScore)}×25% + ${Math.round(circleAngleScore)}×25% + ${Math.round(circleStraightnessScore)}×30% + ${Math.round(circleAspectScore)}×20%)`;

                scoredResults.push({
                    type: 'circle',
                    confidence: circleFinalScore / 100,
                    label: 'Circle',
                    score: circleFinalScore
                });

                // ===== TRIANGLE SCORING =====
                let triangleCornerScore = 0;
                let triangleAngleScore = 0;
                let triangleStraightnessScore = 0;
                let triangleAspectScore = 0;
                let triangleDisqualified = false;

                // 1. DISQUALIFYING: Must be closed
                scoringDetails.triangle.closed = fp.isClosed;
                if (!fp.isClosed) {
                    triangleDisqualified = true;
                    scoringDetails.triangle.closedPoints = 'DISQUALIFIED (not closed)';
                } else {
                    scoringDetails.triangle.closedPoints = '✓ closed';
                }

                // 2. CORNER COUNT SCORE (25%): 0-100 based on corner count
                if (fp.corners === 3) {
                    triangleCornerScore = 100;
                    scoringDetails.triangle.cornerScore = `100 (exactly 3)`;
                } else if (fp.corners === 2) {
                    triangleCornerScore = 85;
                    scoringDetails.triangle.cornerScore = `85 (2 corners)`;
                } else if (fp.corners === 4) {
                    triangleCornerScore = 40;
                    scoringDetails.triangle.cornerScore = `40 (4 corners)`;
                } else {
                    triangleCornerScore = 0;
                    triangleDisqualified = true;
                    scoringDetails.triangle.cornerScore = `0 (${fp.corners} corners)`;
                }

                // 3. ANGLE QUALITY SCORE (25%): Should NOT be 90° angles (triangle-like)
                if (!triangleDisqualified && fp.corners >= 2 && fp.corners <= 4) {
                    // Base score from triangle-likeness (0-1 → 0-100)
                    const baseLikeness = fp.angleAnalysis.triangleLikeness * 100;
                    // Penalty from rectangle-likeness
                    const rectPenalty = fp.angleAnalysis.rectangleLikeness * 30;
                    triangleAngleScore = Math.max(0, Math.min(100, baseLikeness - rectPenalty));

                    const avgAngleDeg = (fp.angleAnalysis.avgAngle * 180 / Math.PI).toFixed(0);
                    scoringDetails.triangle.angleScore = `${Math.round(triangleAngleScore)} (avg: ${avgAngleDeg}°, tri-like: ${fp.angleAnalysis.triangleLikeness.toFixed(2)})`;
                } else {
                    triangleAngleScore = 0;
                    scoringDetails.triangle.angleScore = '0 (no valid angles)';
                }

                // 4. STRAIGHTNESS SCORE (30%): Corners imply straight edges
                if (fp.corners >= 2 && fp.corners <= 3) {
                    // Has corners = has straight edges
                    triangleStraightnessScore = 100;
                    scoringDetails.triangle.straightnessScore = '100 (has corners = straight edges)';
                } else if (fp.straightness >= 0.3 && fp.straightness <= 0.7) {
                    triangleStraightnessScore = 100;
                    scoringDetails.triangle.straightnessScore = '100 (straight enough)';
                } else if (fp.straightness > 0.7) {
                    triangleStraightnessScore = 70;
                    scoringDetails.triangle.straightnessScore = '70 (too straight - line-like)';
                } else {
                    triangleStraightnessScore = 0;
                    triangleDisqualified = true;
                    scoringDetails.triangle.straightnessScore = `0 (too curved: ${fp.straightness.toFixed(3)})`;
                }

                // 5. ASPECT RATIO SCORE (20%): Reasonable shape (continuous scoring)
                triangleAspectScore = scoreAspectRange(fp.aspectRatio, 0.3, 3.0);
                scoringDetails.triangle.aspectScore = `${Math.round(triangleAspectScore)} (ratio: ${fp.aspectRatio.toFixed(2)})`;

                const triangleFinalScore = triangleDisqualified ? 0 : calculateScore(triangleCornerScore, triangleAngleScore, triangleStraightnessScore, triangleAspectScore);
                scoringDetails.triangle.total = triangleFinalScore;
                scoringDetails.triangle.breakdown = `(${Math.round(triangleCornerScore)}×25% + ${Math.round(triangleAngleScore)}×25% + ${Math.round(triangleStraightnessScore)}×30% + ${Math.round(triangleAspectScore)}×20%)`;

                scoredResults.push({
                    type: 'triangle',
                    confidence: triangleFinalScore / 100,
                    label: 'Triangle',
                    score: triangleFinalScore
                });

                // ===== RECTANGLE SCORING =====
                let rectangleCornerScore = 0;
                let rectangleAngleScore = 0;
                let rectangleStraightnessScore = 0;
                let rectangleAspectScore = 0;
                let rectangleDisqualified = false;

                // 1. DISQUALIFYING: Must be closed
                scoringDetails.rectangle.closed = fp.isClosed;
                if (!fp.isClosed) {
                    rectangleDisqualified = true;
                    scoringDetails.rectangle.closedPoints = 'DISQUALIFIED (not closed)';
                } else {
                    scoringDetails.rectangle.closedPoints = '✓ closed';
                }

                // 2. CORNER COUNT SCORE (25%): 0-100 based on corner count
                if (fp.corners === 4) {
                    rectangleCornerScore = 100;
                    scoringDetails.rectangle.cornerScore = `100 (exactly 4)`;
                } else if (fp.corners === 3) {
                    rectangleCornerScore = 85;
                    scoringDetails.rectangle.cornerScore = `85 (3 corners)`;
                } else if (fp.corners === 5) {
                    rectangleCornerScore = 40;
                    scoringDetails.rectangle.cornerScore = `40 (5 corners)`;
                } else {
                    rectangleCornerScore = 0;
                    rectangleDisqualified = true;
                    scoringDetails.rectangle.cornerScore = `0 (${fp.corners} corners)`;
                }

                // 3. ANGLE QUALITY SCORE (25%): Should be ~90° angles (rectangle-like)
                if (!rectangleDisqualified && fp.corners >= 3 && fp.corners <= 5) {
                    // Base score from rectangle-likeness (0-1 → 0-100)
                    const baseLikeness = fp.angleAnalysis.rectangleLikeness * 100;
                    // Penalty from triangle-likeness
                    const triPenalty = fp.angleAnalysis.triangleLikeness * 30;
                    rectangleAngleScore = Math.max(0, Math.min(100, baseLikeness - triPenalty));

                    const avgAngleDeg = (fp.angleAnalysis.avgAngle * 180 / Math.PI).toFixed(0);
                    scoringDetails.rectangle.angleScore = `${Math.round(rectangleAngleScore)} (avg: ${avgAngleDeg}°, rect-like: ${fp.angleAnalysis.rectangleLikeness.toFixed(2)})`;
                } else {
                    rectangleAngleScore = 0;
                    scoringDetails.rectangle.angleScore = '0 (no valid angles)';
                }

                // 4. STRAIGHTNESS SCORE (30%): Corners imply straight edges
                if (fp.corners >= 3 && fp.corners <= 4) {
                    // Has corners = has straight edges
                    rectangleStraightnessScore = 100;
                    scoringDetails.rectangle.straightnessScore = '100 (has corners = straight edges)';
                } else if (fp.straightness >= 0.4 && fp.straightness <= 0.8) {
                    rectangleStraightnessScore = 100;
                    scoringDetails.rectangle.straightnessScore = '100 (straight enough)';
                } else if (fp.straightness > 0.8) {
                    rectangleStraightnessScore = 70;
                    scoringDetails.rectangle.straightnessScore = '70 (too straight - line-like)';
                } else {
                    rectangleStraightnessScore = 0;
                    rectangleDisqualified = true;
                    scoringDetails.rectangle.straightnessScore = `0 (too curved: ${fp.straightness.toFixed(3)})`;
                }

                // 5. ASPECT RATIO SCORE (20%): Reasonable shape (continuous scoring)
                rectangleAspectScore = scoreAspectRange(fp.aspectRatio, 0.3, 3.0);
                scoringDetails.rectangle.aspectScore = `${Math.round(rectangleAspectScore)} (ratio: ${fp.aspectRatio.toFixed(2)})`;

                const rectangleFinalScore = rectangleDisqualified ? 0 : calculateScore(rectangleCornerScore, rectangleAngleScore, rectangleStraightnessScore, rectangleAspectScore);
                scoringDetails.rectangle.total = rectangleFinalScore;
                scoringDetails.rectangle.breakdown = `(${Math.round(rectangleCornerScore)}×25% + ${Math.round(rectangleAngleScore)}×25% + ${Math.round(rectangleStraightnessScore)}×30% + ${Math.round(rectangleAspectScore)}×20%)`;

                scoredResults.push({
                    type: 'rectangle',
                    confidence: rectangleFinalScore / 100,
                    label: 'Rectangle',
                    score: rectangleFinalScore
                });

                // ===== LINE SCORING =====
                let lineCornerScore = 0;
                let lineAngleScore = 0;
                let lineStraightnessScore = 0;
                let lineAspectScore = 0;
                let lineDisqualified = false;

                // 1. DISQUALIFYING: Must NOT be closed
                scoringDetails.line.notClosed = !fp.isClosed;
                if (fp.isClosed) {
                    lineDisqualified = true;
                    scoringDetails.line.closedPoints = 'DISQUALIFIED (lines must be open)';
                } else {
                    scoringDetails.line.closedPoints = '✓ not closed';
                }

                // 2. CORNER COUNT SCORE (25%): 0-100 based on corner count
                if (fp.corners === 0) {
                    lineCornerScore = 100;
                    scoringDetails.line.cornerScore = '100 (no corners)';
                } else if (fp.corners <= 2) {
                    lineCornerScore = 80;
                    scoringDetails.line.cornerScore = `80 (${fp.corners} corners)`;
                } else {
                    lineCornerScore = 0;
                    lineDisqualified = true;
                    scoringDetails.line.cornerScore = `0 (${fp.corners} corners)`;
                }

                // 3. ANGLE QUALITY SCORE (25%): Lines shouldn't have sharp angles
                if (fp.corners === 0) {
                    lineAngleScore = 100;
                    scoringDetails.line.angleScore = '100 (perfectly smooth)';
                } else if (fp.corners <= 2) {
                    // Slight penalty for any angles
                    lineAngleScore = 60;
                    scoringDetails.line.angleScore = '60 (minor bends)';
                } else {
                    lineAngleScore = 0;
                    scoringDetails.line.angleScore = '0 (too many angles)';
                }

                // 4. STRAIGHTNESS SCORE (30%): MUST be very straight (continuous scoring)
                lineStraightnessScore = scoreStraightness(fp.straightness);
                if (lineStraightnessScore === 0) {
                    lineDisqualified = true;
                    scoringDetails.line.straightnessScore = `0 (too curved: ${fp.straightness.toFixed(3)})`;
                } else {
                    scoringDetails.line.straightnessScore = `${Math.round(lineStraightnessScore)} (straightness: ${fp.straightness.toFixed(3)})`;
                }

                // 5. ASPECT RATIO SCORE (20%): Lines should be elongated (continuous scoring)
                lineAspectScore = scoreLineElongation(fp.aspectRatio);
                scoringDetails.line.aspectScore = `${Math.round(lineAspectScore)} (ratio: ${fp.aspectRatio.toFixed(2)})`;

                const lineFinalScore = lineDisqualified ? 0 : calculateScore(lineCornerScore, lineAngleScore, lineStraightnessScore, lineAspectScore);
                scoringDetails.line.total = lineFinalScore;
                scoringDetails.line.breakdown = `(${Math.round(lineCornerScore)}×25% + ${Math.round(lineAngleScore)}×25% + ${Math.round(lineStraightnessScore)}×30% + ${Math.round(lineAspectScore)}×20%)`;

                scoredResults.push({
                    type: 'line',
                    confidence: lineFinalScore / 100,
                    label: 'Line',
                    score: lineFinalScore
                });

                // ===== USER PRIMITIVE MATCHING =====
                // Check against saved user primitives (single-stroke only)
                Object.keys(state.library).forEach(key => {
                    const item = state.library[key];
                    if (item.type === 'user-primitive' && item.fingerprint) {
                        const similarity = compareFingerprints(fp, item.fingerprint);
                        const score = Math.round(similarity * 100);

                        if (score >= 60) { // 60% similarity threshold
                            scoredResults.push({
                                type: key,
                                confidence: similarity,
                                label: `${item.label} (Library)`,
                                score: score,
                                isUserPrimitive: true
                            });
                        }
                    }
                });

                // Sort by score - show ALL shapes ranked, filter only scores > 20 for suggestions
                const finalResults = scoredResults.sort((a, b) => b.score - a.score);

                return {
                    results: finalResults.length > 0 ? finalResults : results,
                    fingerprint: fp,
                    checks: checks,
                    scoringDetails: scoringDetails
                };
            }

            function updateMetrics(analysis) {
                if (!analysis) {
                    metricsContent.innerHTML = '<div class="no-stroke-message">Draw a stroke to see metrics...</div>';
                    return;
                }

                const fp = analysis.fingerprint;

                let html = '<div class="metrics-section">';
                html += '<h3>Fingerprint Data</h3>';
                html += `<div class="metric-item"><span class="metric-label">Aspect Ratio</span><span class="metric-value">${fp.aspectRatio.toFixed(3)}</span></div>`;
                html += `<div class="metric-item"><span class="metric-label">Straightness</span><span class="metric-value">${fp.straightness.toFixed(3)}</span></div>`;
                html += `<div class="metric-item"><span class="metric-label">Corners</span><span class="metric-value">${fp.corners}</span></div>`;

                // Show corner angle details if corners exist
                if (fp.corners > 0 && fp.cornerAngles && fp.cornerAngles.length > 0) {
                    const anglesDeg = fp.cornerAngles.map(a => (a * 180 / Math.PI).toFixed(0) + '°').join(', ');
                    html += `<div class="metric-item"><span class="metric-label">Corner Angles</span><span class="metric-value">${anglesDeg}</span></div>`;
                    html += `<div class="metric-item"><span class="metric-label">Avg Angle</span><span class="metric-value">${(fp.angleAnalysis.avgAngle * 180 / Math.PI).toFixed(0)}°</span></div>`;
                    html += `<div class="metric-item"><span class="metric-label">Rect-like</span><span class="metric-value">${fp.angleAnalysis.rectangleLikeness.toFixed(2)}</span></div>`;
                    html += `<div class="metric-item"><span class="metric-label">Tri-like</span><span class="metric-value">${fp.angleAnalysis.triangleLikeness.toFixed(2)}</span></div>`;
                }

                html += `<div class="metric-item"><span class="metric-label">Is Closed</span><span class="metric-value">${fp.isClosed ? 'Yes' : 'No'}</span></div>`;
                html += `<div class="metric-item"><span class="metric-label">End Distance</span><span class="metric-value">${fp.closureDistance.toFixed(1)}px</span></div>`;
                html += `<div class="metric-item"><span class="metric-label">Size</span><span class="metric-value">${fp.size.toFixed(0)}px</span></div>`;
                html += `<div class="metric-item"><span class="metric-label">Points</span><span class="metric-value">${fp.pointCount}</span></div>`;
                html += '</div>';

                html += '<div class="metrics-section">';
                html += '<h3>Weighted Scoring System</h3>';
                html += '<p style="font-size: 11px; color: #666; margin: 0 0 12px 0;">Each shape scored on: Corner Count (25%) + Angle Quality (25%) + Straightness (30%) + Aspect Ratio (20%)</p>';

                // Store scoring details for display
                if (analysis.scoringDetails) {
                    const details = analysis.scoringDetails;

                    // Circle details
                    html += `<div class="condition-check" style="margin-bottom: 12px; background: #f9f9f9;">`;
                    html += `<div class="shape-name" style="font-weight: bold; color: #333;">Circle: ${details.circle.total}/100</div>`;
                    html += `<div class="reason" style="font-size: 11px;">`;
                    html += `• Closed: ${details.circle.closedPoints}<br>`;
                    html += `• Corner Count (25%): ${details.circle.cornerScore}<br>`;
                    html += `• Angle Quality (25%): ${details.circle.angleScore}<br>`;
                    html += `• Straightness (30%): ${details.circle.straightnessScore}<br>`;
                    html += `• Aspect Ratio (20%): ${details.circle.aspectScore}<br>`;
                    html += `<span style="color: #666; font-size: 10px;">${details.circle.breakdown}</span>`;
                    html += `</div></div>`;

                    // Triangle details
                    html += `<div class="condition-check" style="margin-bottom: 12px; background: #f9f9f9;">`;
                    html += `<div class="shape-name" style="font-weight: bold; color: #333;">Triangle: ${details.triangle.total}/100</div>`;
                    html += `<div class="reason" style="font-size: 11px;">`;
                    html += `• Closed: ${details.triangle.closedPoints}<br>`;
                    html += `• Corner Count (25%): ${details.triangle.cornerScore}<br>`;
                    html += `• Angle Quality (25%): ${details.triangle.angleScore}<br>`;
                    html += `• Straightness (30%): ${details.triangle.straightnessScore}<br>`;
                    html += `• Aspect Ratio (20%): ${details.triangle.aspectScore}<br>`;
                    html += `<span style="color: #666; font-size: 10px;">${details.triangle.breakdown}</span>`;
                    html += `</div></div>`;

                    // Rectangle details
                    html += `<div class="condition-check" style="margin-bottom: 12px; background: #f9f9f9;">`;
                    html += `<div class="shape-name" style="font-weight: bold; color: #333;">Rectangle: ${details.rectangle.total}/100</div>`;
                    html += `<div class="reason" style="font-size: 11px;">`;
                    html += `• Closed: ${details.rectangle.closedPoints}<br>`;
                    html += `• Corner Count (25%): ${details.rectangle.cornerScore}<br>`;
                    html += `• Angle Quality (25%): ${details.rectangle.angleScore}<br>`;
                    html += `• Straightness (30%): ${details.rectangle.straightnessScore}<br>`;
                    html += `• Aspect Ratio (20%): ${details.rectangle.aspectScore}<br>`;
                    html += `<span style="color: #666; font-size: 10px;">${details.rectangle.breakdown}</span>`;
                    html += `</div></div>`;

                    // Line details
                    html += `<div class="condition-check" style="margin-bottom: 12px; background: #f9f9f9;">`;
                    html += `<div class="shape-name" style="font-weight: bold; color: #333;">Line: ${details.line.total}/100</div>`;
                    html += `<div class="reason" style="font-size: 11px;">`;
                    html += `• Not closed: ${details.line.closedPoints}<br>`;
                    html += `• Corner Count (25%): ${details.line.cornerScore}<br>`;
                    html += `• Angle Quality (25%): ${details.line.angleScore}<br>`;
                    html += `• Straightness (30%): ${details.line.straightnessScore}<br>`;
                    html += `• Aspect Ratio (20%): ${details.line.aspectScore}<br>`;
                    html += `<span style="color: #666; font-size: 10px;">${details.line.breakdown}</span>`;
                    html += `</div></div>`;
                }

                html += '</div>';

                metricsContent.innerHTML = html;
            }

            // ===== GEOMETRY REFINEMENT FUNCTIONS =====
            // Convert recognized strokes into perfect geometric shapes

            function refineCircle(originalStroke) {
                const bounds = getBounds(originalStroke);
                const centerX = (bounds.minX + bounds.maxX) / 2;
                const centerY = (bounds.minY + bounds.maxY) / 2;
                const radiusX = (bounds.maxX - bounds.minX) / 2;
                const radiusY = (bounds.maxY - bounds.minY) / 2;
                const radius = (radiusX + radiusY) / 2; // Average for perfect circle

                // Generate perfect circle points
                const points = [];
                const numPoints = 60;
                for (let i = 0; i <= numPoints; i++) {
                    const angle = (i / numPoints) * Math.PI * 2;
                    points.push({
                        x: centerX + Math.cos(angle) * radius,
                        y: centerY + Math.sin(angle) * radius
                    });
                }
                return points;
            }

            function refineLine(originalStroke) {
                // Keep exact start and end, make perfectly straight
                const start = originalStroke[0];
                const end = originalStroke[originalStroke.length - 1];
                return [
                    { x: start.x, y: start.y },
                    { x: end.x, y: end.y }
                ];
            }

            function refineRectangle(originalStroke, fingerprint = null) {
                // LINE-BASED APPROACH: Return 4 separate line segments using actual detected corners
                // This shows composability and is more accurate than bounding-box approach

                // Use cached corner data from fingerprint if available, otherwise compute
                let cornerData;
                if (fingerprint && fingerprint.cornerData) {
                    cornerData = {
                        count: fingerprint.corners,
                        angles: fingerprint.cornerAngles,
                        cornerData: fingerprint.cornerData
                    };
                } else {
                    cornerData = countCorners(originalStroke, Math.PI / 3);
                }

                // Get actual corner positions from the stroke
                let corners = [];

                if (cornerData.cornerData && cornerData.cornerData.length >= 3) {
                    // Use detected corners - take 4 sharpest if we have more
                    corners = cornerData.cornerData
                        .sort((a, b) => a.angle - b.angle) // Sort by sharpness
                        .slice(0, 4)
                        .sort((a, b) => a.index - b.index) // Sort by order in stroke
                        .map(c => originalStroke[c.index])
                        .filter(p => p && typeof p.x !== 'undefined' && typeof p.y !== 'undefined');
                }

                // Fallback: if not enough corners detected, use bounding box
                if (corners.length < 4) {
                    const bounds = getBounds(originalStroke);

                    // Try to detect rotation by sampling 4 points
                    const len = originalStroke.length;
                    if (len >= 4) {
                        const p1 = originalStroke[0];
                        const p2 = originalStroke[Math.floor(len * 0.25)];
                        const p3 = originalStroke[Math.floor(len * 0.5)];
                        const p4 = originalStroke[Math.floor(len * 0.75)];

                        // Calculate dominant edge angle (from p1 to p2)
                        const dx = p2.x - p1.x;
                        const dy = p2.y - p1.y;
                        const angle = Math.atan2(dy, dx);

                        // Create rotated rectangle
                        const width = bounds.maxX - bounds.minX;
                        const height = bounds.maxY - bounds.minY;
                        const centerX = bounds.minX + width / 2;
                        const centerY = bounds.minY + height / 2;

                        const halfW = width / 2;
                        const halfH = height / 2;

                        const cos = Math.cos(angle);
                        const sin = Math.sin(angle);

                        // Generate 4 corners rotated around center
                        const unrotated = [
                            { x: -halfW, y: -halfH },  // Top-left
                            { x: halfW, y: -halfH },   // Top-right
                            { x: halfW, y: halfH },    // Bottom-right
                            { x: -halfW, y: halfH }    // Bottom-left
                        ];

                        corners = unrotated.map(corner => ({
                            x: centerX + (corner.x * cos - corner.y * sin),
                            y: centerY + (corner.x * sin + corner.y * cos)
                        }));
                    } else {
                        // Ultimate fallback: axis-aligned rectangle
                        corners = [
                            { x: bounds.minX, y: bounds.minY },
                            { x: bounds.maxX, y: bounds.minY },
                            { x: bounds.maxX, y: bounds.maxY },
                            { x: bounds.minX, y: bounds.maxY }
                        ];
                    }
                }

                // Final validation: ensure we have exactly 4 valid corners
                if (corners.length !== 4) {
                    console.error('Rectangle refinement failed: invalid corners count', corners.length, corners);
                    return null;
                }

                // Validate all corners have x and y
                for (let i = 0; i < 4; i++) {
                    if (!corners[i] || typeof corners[i].x === 'undefined' || typeof corners[i].y === 'undefined') {
                        console.error('Rectangle refinement failed: invalid corner at index', i, corners[i]);
                        return null;
                    }
                }

                // Get the actual corner indices in the original stroke
                let cornerIndices = [];
                if (cornerData.cornerData && cornerData.cornerData.length >= 3) {
                    cornerIndices = cornerData.cornerData
                        .sort((a, b) => a.angle - b.angle)
                        .slice(0, 4)
                        .map(c => c.index)
                        .sort((a, b) => a - b); // Sort by position in stroke
                }

                // Rectangles need 4 corners - add start/end point if we only detected 3
                if (cornerIndices.length === 3) {
                    cornerIndices.push(0); // Add start point as 4th corner
                    cornerIndices.sort((a, b) => a - b); // Re-sort by position
                } else if (cornerIndices.length < 3) {
                    // CREATE rectangle geometry from bounding box, don't try to find it in stroke
                    const bounds = getBounds(originalStroke);

                    // Create synthetic rectangle corners
                    const corner0 = { x: bounds.minX, y: bounds.minY };  // Top-left
                    const corner1 = { x: bounds.maxX, y: bounds.minY };  // Top-right
                    const corner2 = { x: bounds.maxX, y: bounds.maxY };  // Bottom-right
                    const corner3 = { x: bounds.minX, y: bounds.maxY };  // Bottom-left

                    // Return synthetic corners directly as line segments
                    const lineSegments = [
                        [corner0, corner1],
                        [corner1, corner2],
                        [corner2, corner3],
                        [corner3, corner0]
                    ];

                    return lineSegments;
                }

                // Extract corner points from stroke and create straight lines between them
                const corner0 = originalStroke[cornerIndices[0]];
                const corner1 = originalStroke[cornerIndices[1]];
                const corner2 = originalStroke[cornerIndices[2]];
                const corner3 = originalStroke[cornerIndices[3]];

                // Create 4 straight line segments connecting the corners
                const lineSegments = [
                    [corner0, corner1],  // Line from corner 0 to corner 1
                    [corner1, corner2],  // Line from corner 1 to corner 2
                    [corner2, corner3],  // Line from corner 2 to corner 3
                    [corner3, corner0]   // Line from corner 3 back to corner 0 (close)
                ];

                // Return 4 stroke segments (each is an array of points)
                return lineSegments;
            }

            function detectTriangleTipDirection(originalStroke) {
                // Strategy: Find the SHARPEST corner (smallest angle) - that's the tip
                // Works for multiple drawing patterns:
                // - Pattern A: Tip → Corner1 → Corner2 → Tip
                // - Pattern B: Corner1 → Tip → Corner2 → Corner1 (best for arrows!)
                // - Pattern C: Corner1 → Corner2 → Tip → Corner1
                // Also works for arrow heads (1 corner) and messy triangles (2 corners)

                const bounds = getBounds(originalStroke);
                const centerX = (bounds.minX + bounds.maxX) / 2;
                const centerY = (bounds.minY + bounds.maxY) / 2;

                // Find all corners
                const cornerData = countCorners(originalStroke, Math.PI / 3);

                let tipPoint = null;
                let tipIndex = 0;

                if (cornerData.cornerData && cornerData.cornerData.length > 0) {
                    // Find the sharpest angle (smallest value) - that's the tip
                    let sharpestAngle = Math.PI;

                    cornerData.cornerData.forEach(angleData => {
                        if (angleData.angle < sharpestAngle) {
                            sharpestAngle = angleData.angle;
                            tipIndex = angleData.index;
                        }
                    });

                    // Validate tipIndex is within bounds
                    if (tipIndex >= 0 && tipIndex < originalStroke.length) {
                        tipPoint = originalStroke[tipIndex];
                    }
                }

                // Fallback: No corners detected or invalid tipPoint, use start point
                if (!tipPoint) {
                    tipPoint = originalStroke[0];
                    tipIndex = 0;
                }

                // Safety check - ensure tipPoint is valid
                if (!tipPoint || typeof tipPoint.x === 'undefined' || typeof tipPoint.y === 'undefined') {
                    console.error('Invalid tipPoint:', tipPoint);
                    // Ultimate fallback
                    tipPoint = { x: centerX, y: centerY };
                }

                // Calculate direction from centroid to tip
                const dx = tipPoint.x - centerX;
                const dy = tipPoint.y - centerY;

                const angle = Math.atan2(dy, dx);
                const degrees = angle * 180 / Math.PI;

                // Classify into 4 directions based on angle
                let direction;
                if (degrees >= -45 && degrees < 45) direction = 'right';
                else if (degrees >= 45 && degrees < 135) direction = 'down';
                else if (degrees >= 135 || degrees < -135) direction = 'left';
                else direction = 'up';

                return { direction, tipPoint, tipIndex };
            }

            function refineTriangle(originalStroke, fingerprint = null) {
                // LINE-BASED APPROACH: Return 3 separate line segments using actual detected corners
                // This shows composability and is more accurate than bounding-box approach

                const tipData = detectTriangleTipDirection(originalStroke);

                // Use cached corner data from fingerprint if available, otherwise compute
                let cornerData;
                if (fingerprint && fingerprint.cornerData) {
                    cornerData = {
                        count: fingerprint.corners,
                        angles: fingerprint.cornerAngles,
                        cornerData: fingerprint.cornerData
                    };
                } else {
                    cornerData = countCorners(originalStroke, Math.PI / 3);
                }

                // Get actual corner positions from the stroke
                let corners = [];

                if (cornerData.cornerData && cornerData.cornerData.length >= 2) {
                    // Use detected corners
                    corners = cornerData.cornerData
                        .map(c => originalStroke[c.index])
                        .filter(p => p && typeof p.x !== 'undefined' && typeof p.y !== 'undefined');

                    // If we have more than 3 corners, take the 3 sharpest
                    if (corners.length > 3) {
                        corners = cornerData.cornerData
                            .sort((a, b) => a.angle - b.angle) // Sort by sharpness (smaller angle = sharper)
                            .slice(0, 3)
                            .map(c => originalStroke[c.index])
                            .filter(p => p && typeof p.x !== 'undefined' && typeof p.y !== 'undefined');
                    }
                }

                // Fallback: if not enough corners detected, use bounding box approach
                if (corners.length < 2) {
                    const bounds = getBounds(originalStroke);
                    const width = bounds.maxX - bounds.minX;
                    const height = bounds.maxY - bounds.minY;
                    const centerX = bounds.minX + width / 2;
                    const centerY = bounds.minY + height / 2;

                    const direction = tipData.direction;

                    switch (direction) {
                        case 'up':
                            corners = [
                                { x: centerX, y: bounds.minY },      // Top (tip)
                                { x: bounds.minX, y: bounds.maxY },  // Bottom-left
                                { x: bounds.maxX, y: bounds.maxY }   // Bottom-right
                            ];
                            break;
                        case 'down':
                            corners = [
                                { x: centerX, y: bounds.maxY },      // Bottom (tip)
                                { x: bounds.maxX, y: bounds.minY },  // Top-right
                                { x: bounds.minX, y: bounds.minY }   // Top-left
                            ];
                            break;
                        case 'left':
                            corners = [
                                { x: bounds.minX, y: centerY },      // Left (tip)
                                { x: bounds.maxX, y: bounds.minY },  // Top-right
                                { x: bounds.maxX, y: bounds.maxY }   // Bottom-right
                            ];
                            break;
                        case 'right':
                            corners = [
                                { x: bounds.maxX, y: centerY },      // Right (tip)
                                { x: bounds.minX, y: bounds.maxY },  // Bottom-left
                                { x: bounds.minX, y: bounds.minY }   // Top-left
                            ];
                            break;
                    }
                } else if (corners.length === 2) {
                    // Add tip as third corner
                    corners.push(tipData.tipPoint);
                }

                // Final validation: ensure we have exactly 3 valid corners
                if (corners.length !== 3) {
                    console.error('Triangle refinement failed: invalid corners count', corners.length, corners);
                    return null;
                }

                // Validate all corners have x and y
                for (let i = 0; i < 3; i++) {
                    if (!corners[i] || typeof corners[i].x === 'undefined' || typeof corners[i].y === 'undefined') {
                        console.error('Triangle refinement failed: invalid corner at index', i, corners[i]);
                        return null;
                    }
                }

                // Get the actual corner indices in the original stroke
                let cornerIndices = [];
                if (cornerData.cornerData && cornerData.cornerData.length >= 2) {
                    cornerIndices = cornerData.cornerData
                        .sort((a, b) => a.angle - b.angle)
                        .slice(0, 3)
                        .map(c => c.index)
                        .filter(idx => typeof idx !== 'undefined' && idx >= 0) // Remove undefined indices
                        .sort((a, b) => a - b); // Sort by position in stroke
                }

                // Corner indices found from detected corners

                // Triangles need 3 corners - add start/end point if we only detected 2
                if (cornerIndices.length === 2) {
                    cornerIndices.push(0); // Add start point as 3rd corner
                    cornerIndices.sort((a, b) => a - b); // Re-sort by position
                } else if (cornerIndices.length === 1) {
                    // Find the point farthest from the detected corner
                    const cornerPt = originalStroke[cornerIndices[0]];
                    let maxDist = 0;
                    let farthestIdx = 0;
                    originalStroke.forEach((pt, idx) => {
                        const dist = Math.sqrt(Math.pow(pt.x - cornerPt.x, 2) + Math.pow(pt.y - cornerPt.y, 2));
                        if (dist > maxDist) {
                            maxDist = dist;
                            farthestIdx = idx;
                        }
                    });
                    cornerIndices = [0, cornerIndices[0], farthestIdx].sort((a, b) => a - b);
                } else if (cornerIndices.length === 0) {
                    // Use stroke start and end as two corners, use detected tip as third corner
                    const startPt = originalStroke[0];
                    const endPt = originalStroke[originalStroke.length - 1];
                    const thirdCorner = tipData.tipPoint;  // Use the detected tip point!

                    // Return line segments using stroke endpoints + tip point
                    const lineSegments = [
                        [startPt, endPt],
                        [endPt, thirdCorner],
                        [thirdCorner, startPt]
                    ];

                    return lineSegments;
                }

                // Extract corner points from stroke and create straight lines between them
                const corner0 = originalStroke[cornerIndices[0]];
                const corner1 = originalStroke[cornerIndices[1]];
                const corner2 = originalStroke[cornerIndices[2]];

                // Create 3 straight line segments connecting the corners
                const lineSegments = [
                    [corner0, corner1],  // Line from corner 0 to corner 1
                    [corner1, corner2],  // Line from corner 1 to corner 2
                    [corner2, corner0]   // Line from corner 2 back to corner 0 (close)
                ];

                // Return 3 stroke segments (each is an array of points)
                return lineSegments;
            }

            function refineStroke(originalStroke, recognizedAs, fingerprint = null) {
                switch (recognizedAs) {
                    case 'circle':
                        return refineCircle(originalStroke);
                    case 'line':
                        return refineLine(originalStroke);
                    case 'rectangle':
                        return refineRectangle(originalStroke, fingerprint);
                    case 'triangle':
                        return refineTriangle(originalStroke, fingerprint);
                    default:
                        return null; // No refinement for unrecognized shapes
                }
            }

            // Rendering
            function render() {
                ctx.clearRect(0, 0, canvas.width, canvas.height);

                // Draw completed strokes (use refined if available)
                state.strokes.forEach((stroke, idx) => {
                    const isAccepted = state.context[idx] && state.context[idx] !== '';

                    // DAY 5: Prefer drawing from Shape object if available
                    const shape = state.shapes[idx];
                    if (shape && shape.accepted) {
                        drawShape(shape, ctx, state.debugMode);
                        return; // Skip legacy rendering
                    }

                    // Legacy rendering (for unaccepted or migrating shapes)
                    const refinedStroke = state.refinedStrokes[idx];

                    ctx.strokeStyle = isAccepted ? '#0066ff' : '#666666';
                    ctx.lineWidth = refinedStroke ? 3 : 2; // Thicker for refined shapes
                    ctx.lineCap = 'round';
                    ctx.lineJoin = 'round';

                    // Check if refined stroke is segment-based (array of stroke segments)
                    // Segment-based: [[{x,y}, {x,y}, ...], [{x,y}, {x,y}, ...], ...]
                    // Single stroke: [{x,y}, {x,y}, {x,y}, ...]
                    const isSegmentBased = refinedStroke &&
                        Array.isArray(refinedStroke[0]) &&
                        typeof refinedStroke[0][0] === 'object' &&
                        typeof refinedStroke[0][0].x !== 'undefined';

                    if (isSegmentBased) {
                        // Draw each stroke segment separately
                        const corners = new Set();

                        refinedStroke.forEach((segment, segIdx) => {
                            // Safety check
                            if (segment && segment.length > 0) {
                                ctx.beginPath();
                                segment.forEach((point, i) => {
                                    if (i === 0) ctx.moveTo(point.x, point.y);
                                    else ctx.lineTo(point.x, point.y);
                                });
                                ctx.stroke();

                                // Collect corner points (start and end of each segment)
                                if (segment[0]) corners.add(JSON.stringify(segment[0]));
                                if (segment[segment.length - 1]) corners.add(JSON.stringify(segment[segment.length - 1]));
                            }
                        });

                        // Draw debug indicators (corners with numbers and angles)
                        if (state.debugMode && isAccepted) {
                            const cornerArray = Array.from(corners).map(s => JSON.parse(s));
                            cornerArray.forEach((corner, i) => {
                                // Dark grey dot
                                ctx.fillStyle = '#444';
                                ctx.beginPath();
                                ctx.arc(corner.x, corner.y, 5, 0, Math.PI * 2);
                                ctx.fill();

                                // Corner number
                                ctx.fillStyle = '#444';
                                ctx.font = 'bold 14px sans-serif';
                                ctx.fillText(`#${i}`, corner.x + 10, corner.y - 5);

                                // Show angle if available from corner debug data
                                const cornerDebug = state.cornerDebugData[idx];
                                if (cornerDebug && cornerDebug[i]) {
                                    const angleDeg = Math.round(cornerDebug[i].angle * 180 / Math.PI);
                                    ctx.font = '12px sans-serif';
                                    ctx.fillText(`${angleDeg}°`, corner.x + 10, corner.y + 10);
                                }
                            });
                        }
                    } else {
                        // Draw as single stroke (original or refined circle/line)
                        const displayStroke = refinedStroke || stroke;

                        ctx.beginPath();
                        displayStroke.forEach((point, i) => {
                            if (i === 0) ctx.moveTo(point.x, point.y);
                            else ctx.lineTo(point.x, point.y);
                        });
                        ctx.stroke();
                    }

                    // Draw tip debug indicator for triangles
                    if (state.debugMode) {
                        const tipPoint = state.tipDebugData[idx];
                        if (tipPoint && isAccepted) {
                            ctx.fillStyle = '#444'; // Dark grey dot for tip
                            ctx.beginPath();
                            ctx.arc(tipPoint.x, tipPoint.y, 5, 0, Math.PI * 2);
                            ctx.fill();

                            // Add a small label
                            ctx.fillStyle = '#444';
                            ctx.font = 'bold 14px sans-serif';
                            ctx.fillText('TIP', tipPoint.x + 10, tipPoint.y - 5);
                        }
                    }
                });

                // Draw current stroke
                if (state.currentStroke.length > 0) {
                    ctx.strokeStyle = '#666666';
                    ctx.lineWidth = 2;
                    ctx.lineCap = 'round';
                    ctx.lineJoin = 'round';

                    ctx.beginPath();
                    state.currentStroke.forEach((point, i) => {
                        if (i === 0) ctx.moveTo(point.x, point.y);
                        else ctx.lineTo(point.x, point.y);
                    });
                    ctx.stroke();
                }

                // Draw spatial graph visualization (Day 3)
                if (state.debugMode && state.strokes.length > 1) {
                    // Build a temporary spatial graph for current canvas strokes
                    const tempComponents = state.strokes.map((stroke, idx) => {
                        const refinedStroke = state.refinedStrokes[idx];
                        // Use refined stroke for bounds if available and accepted
                        const strokeForBounds = refinedStroke ? flattenStroke(refinedStroke) : stroke;

                        // Get geometric shape for intersection/containment detection
                        const geometricShape = state.shapes[idx] || null;

                        return {
                            originalStroke: stroke,
                            refinedStroke: refinedStroke,
                            bounds: getBounds(strokeForBounds),
                            recognizedAs: state.context[idx] || `art${idx}`,
                            fingerprint: getFingerprint(stroke),
                            geometricShape: geometricShape
                        };
                    });

                    const tempGraph = buildSpatialGraph(tempComponents);

                    // PHASE 3A: Draw intersection points
                    tempGraph.intersections.forEach((intersection) => {
                        intersection.points.forEach((point, pointIdx) => {
                            // Draw intersection point as bright red/yellow dot
                            ctx.fillStyle = '#FF3333';
                            ctx.beginPath();
                            ctx.arc(point.x, point.y, 6, 0, Math.PI * 2);
                            ctx.fill();

                            // White center
                            ctx.fillStyle = '#FFFF00';
                            ctx.beginPath();
                            ctx.arc(point.x, point.y, 3, 0, Math.PI * 2);
                            ctx.fill();
                        });

                        // Draw intersection count badge near first point
                        if (intersection.points.length > 0) {
                            const firstPoint = intersection.points[0];
                            const count = intersection.points.length;

                            ctx.fillStyle = '#FF3333';
                            ctx.font = 'bold 9px monospace';
                            const badge = `⨯${count}`;
                            const badgeMetrics = ctx.measureText(badge);

                            // Background
                            ctx.fillStyle = 'rgba(0, 0, 0, 0.8)';
                            ctx.fillRect(firstPoint.x + 8, firstPoint.y - 12, badgeMetrics.width + 4, 11);

                            // Text
                            ctx.fillStyle = '#FFFF00';
                            ctx.fillText(badge, firstPoint.x + 10, firstPoint.y - 4);
                        }
                    });

                    // Draw connections (distinguish touching vs intersecting)
                    tempGraph.connections.forEach((conn) => {
                        const i = conn.a;
                        const j = conn.b;
                        const boundsA = tempComponents[i].bounds;
                        const boundsB = tempComponents[j].bounds;
                        const centerA = {
                            x: (boundsA.minX + boundsA.maxX) / 2,
                            y: (boundsA.minY + boundsA.maxY) / 2
                        };
                        const centerB = {
                            x: (boundsB.minX + boundsB.maxX) / 2,
                            y: (boundsB.minY + boundsB.maxY) / 2
                        };

                        const isIntersecting = conn.relationship === 'intersecting';

                        // Draw connection line
                        ctx.strokeStyle = isIntersecting ? '#FF3333' : '#4CAF50'; // Red for intersecting, green for touching
                        ctx.lineWidth = 2;
                        ctx.setLineDash(isIntersecting ? [] : [5, 5]); // Solid for intersecting, dashed for touching
                        ctx.beginPath();
                        ctx.moveTo(centerA.x, centerA.y);
                        ctx.lineTo(centerB.x, centerB.y);
                        ctx.stroke();
                        ctx.setLineDash([]); // Reset dash

                        // Draw connection label (use offset to avoid overlaps)
                        const midX = (centerA.x + centerB.x) / 2;
                        const midY = (centerA.y + centerB.y) / 2;

                        // Offset based on connection index to avoid overlaps
                        const offset = (i + j) % 3 * 10;

                        ctx.fillStyle = isIntersecting ? '#FF3333' : '#4CAF50';
                        ctx.font = 'bold 10px monospace';
                        const emoji = isIntersecting ? '⨯' : '🔗';
                        ctx.fillText(emoji, midX - 5, midY - 3 + offset);
                    });

                    // PHASE 3A: Draw containment relationships with type labels
                    const containmentLabelOffsets = {}; // Track label positions to avoid overlap
                    tempGraph.containment.forEach((cont, contIdx) => {
                        const outer = cont.outer;
                        const inner = cont.inner;
                        const boundsOuter = tempComponents[outer].bounds;
                        const boundsInner = tempComponents[inner].bounds;
                        const type = cont.type || 'bounds-based';

                        // Color code by containment type
                        let color = '#FF9800'; // Default orange
                        if (type.includes('circle')) color = '#2196F3'; // Blue for circle containment
                        if (type.includes('polygon')) color = '#FF9800'; // Orange for polygon containment
                        if (type === 'bounds-based') color = '#9E9E9E'; // Gray for fallback

                        // Draw containment box around outer
                        ctx.strokeStyle = color;
                        ctx.lineWidth = 2;
                        ctx.setLineDash([3, 3]);
                        ctx.strokeRect(
                            boundsOuter.minX - 5,
                            boundsOuter.minY - 5,
                            (boundsOuter.maxX - boundsOuter.minX) + 10,
                            (boundsOuter.maxY - boundsOuter.minY) + 10
                        );
                        ctx.setLineDash([]);

                        // Label with type (stack vertically to avoid overlap)
                        const labelKey = `${outer}`;
                        const yOffset = (containmentLabelOffsets[labelKey] || 0) * 11;
                        containmentLabelOffsets[labelKey] = (containmentLabelOffsets[labelKey] || 0) + 1;

                        ctx.fillStyle = color;
                        ctx.font = 'bold 9px monospace';
                        const typeShort = type.replace('circle-in-', 'C⊃').replace('polygon-in-', 'P⊃').replace('bounds-based', 'BB');
                        ctx.fillText(`${outer}⊃${inner} [${typeShort}]`, boundsOuter.minX, boundsOuter.minY - 8 - yOffset);
                    });

                    // PHASE 3B: Draw parallel clusters
                    if (tempGraph.parallelClusters && tempGraph.parallelClusters.length > 0) {
                        tempGraph.parallelClusters.forEach((cluster, clusterIdx) => {
                            if (cluster.shapes.length < 2) return;

                            // Draw connection line between first two shapes in cluster
                            const idx1 = cluster.shapes[0];
                            const idx2 = cluster.shapes[1];
                            const bounds1 = tempComponents[idx1].bounds;
                            const bounds2 = tempComponents[idx2].bounds;
                            const center1 = {
                                x: (bounds1.minX + bounds1.maxX) / 2,
                                y: (bounds1.minY + bounds1.maxY) / 2
                            };
                            const center2 = {
                                x: (bounds2.minX + bounds2.maxX) / 2,
                                y: (bounds2.minY + bounds2.maxY) / 2
                            };

                            // Purple dashed line for parallel
                            ctx.strokeStyle = '#9C27B0';
                            ctx.lineWidth = 2;
                            ctx.setLineDash([8, 4]);
                            ctx.beginPath();
                            ctx.moveTo(center1.x, center1.y);
                            ctx.lineTo(center2.x, center2.y);
                            ctx.stroke();
                            ctx.setLineDash([]);

                            // Draw parallel symbol at midpoint
                            const midX = (center1.x + center2.x) / 2;
                            const midY = (center1.y + center2.y) / 2;

                            ctx.font = 'bold 11px monospace';
                            const label = cluster.shapes.length > 2
                                ? `${cluster.shapes.length}∥`
                                : '∥';
                            const labelMetrics = ctx.measureText(label);

                            // Background
                            ctx.fillStyle = 'rgba(0, 0, 0, 0.85)';
                            ctx.fillRect(midX - labelMetrics.width / 2 - 3, midY - 12, labelMetrics.width + 6, 14);

                            // Purple text
                            ctx.fillStyle = '#9C27B0';
                            ctx.fillText(label, midX - labelMetrics.width / 2, midY - 2);

                            // Show angle and deviation
                            const angleText = `${cluster.angle.toFixed(1)}° (±${cluster.maxAngleDiff.toFixed(2)}°)`;
                            const angleMetrics = ctx.measureText(angleText);
                            ctx.font = '9px monospace';
                            ctx.fillStyle = 'rgba(0, 0, 0, 0.85)';
                            ctx.fillRect(midX - angleMetrics.width / 2 - 2, midY + 2, angleMetrics.width + 4, 11);
                            ctx.fillStyle = '#9C27B0';
                            ctx.fillText(angleText, midX - angleMetrics.width / 2, midY + 10);
                        });
                    }

                    // PHASE 3B: Draw perpendicular relationships
                    if (tempGraph.perpendicularPairs && tempGraph.perpendicularPairs.length > 0) {
                        tempGraph.perpendicularPairs.forEach((pair) => {
                            const clusterA = tempGraph.parallelClusters[pair.clusterA];
                            const clusterB = tempGraph.parallelClusters[pair.clusterB];

                            // Draw connection between first shape of each cluster
                            const idxA = clusterA.shapes[0];
                            const idxB = clusterB.shapes[0];
                            const boundsA = tempComponents[idxA].bounds;
                            const boundsB = tempComponents[idxB].bounds;
                            const centerA = {
                                x: (boundsA.minX + boundsA.maxX) / 2,
                                y: (boundsA.minY + boundsA.maxY) / 2
                            };
                            const centerB = {
                                x: (boundsB.minX + boundsB.maxX) / 2,
                                y: (boundsB.minY + boundsB.maxY) / 2
                            };

                            // Teal dashed line for perpendicular
                            ctx.strokeStyle = '#009688';
                            ctx.lineWidth = 2;
                            ctx.setLineDash([4, 4]);
                            ctx.beginPath();
                            ctx.moveTo(centerA.x, centerA.y);
                            ctx.lineTo(centerB.x, centerB.y);
                            ctx.stroke();
                            ctx.setLineDash([]);

                            // Draw perpendicular symbol
                            const midX = (centerA.x + centerB.x) / 2;
                            const midY = (centerA.y + centerB.y) / 2;

                            ctx.font = 'bold 11px monospace';
                            const label = '⊥';
                            const labelMetrics = ctx.measureText(label);

                            // Background
                            ctx.fillStyle = 'rgba(0, 0, 0, 0.85)';
                            ctx.fillRect(midX - labelMetrics.width / 2 - 3, midY - 12, labelMetrics.width + 6, 14);

                            // Teal text
                            ctx.fillStyle = '#009688';
                            ctx.fillText(label, midX - labelMetrics.width / 2, midY - 2);

                            // Show actual angle
                            const angleText = `${pair.angleDiff.toFixed(1)}° (${pair.perpDiff.toFixed(2)}° from 90°)`;
                            const angleMetrics = ctx.measureText(angleText);
                            ctx.font = '9px monospace';
                            ctx.fillStyle = 'rgba(0, 0, 0, 0.85)';
                            ctx.fillRect(midX - angleMetrics.width / 2 - 2, midY + 2, angleMetrics.width + 4, 11);
                            ctx.fillStyle = '#009688';
                            ctx.fillText(angleText, midX - angleMetrics.width / 2, midY + 10);
                        });
                    }

                    // Draw bounding boxes for all strokes (use same bounds as spatial graph)
                    tempComponents.forEach((component, idx) => {
                        const bounds = component.bounds;
                        ctx.strokeStyle = '#999';
                        ctx.lineWidth = 1;
                        ctx.setLineDash([2, 2]);
                        ctx.strokeRect(
                            bounds.minX,
                            bounds.minY,
                            bounds.maxX - bounds.minX,
                            bounds.maxY - bounds.minY
                        );
                        ctx.setLineDash([]);

                        // Draw stroke index
                        ctx.fillStyle = '#999';
                        ctx.font = '9px monospace';
                        ctx.fillText(`[${idx}]`, bounds.minX, bounds.minY - 2);

                        // PHASE 3A: Show idealized geometry used for intersection detection
                        // Draw semi-transparent overlay showing what the intersection algorithm "sees"
                        const geomShape = component.geometricShape;
                        if (geomShape && geomShape.definition) {
                            ctx.strokeStyle = 'rgba(255, 0, 255, 0.4)'; // Magenta = idealized geometry
                            ctx.lineWidth = 1;
                            ctx.setLineDash([3, 3]);

                            const def = geomShape.definition;

                            if (def.type === 'circle') {
                                // Draw the circle used for intersections
                                ctx.beginPath();
                                ctx.arc(def.center.x, def.center.y, def.radius, 0, Math.PI * 2);
                                ctx.stroke();
                            } else if (def.type === 'ellipse') {
                                // Draw ellipse (approximated as circle with avg radius)
                                const avgRadius = (def.radiusX + def.radiusY) / 2;
                                ctx.beginPath();
                                ctx.arc(def.center.x, def.center.y, avgRadius, 0, Math.PI * 2);
                                ctx.stroke();
                            } else if (def.type === 'polygon' && def.vertices) {
                                // Draw the polygon edges used for intersections
                                ctx.beginPath();
                                def.vertices.forEach((v, i) => {
                                    if (i === 0) ctx.moveTo(v.x, v.y);
                                    else ctx.lineTo(v.x, v.y);
                                });
                                ctx.closePath();
                                ctx.stroke();

                                // Draw vertices as small dots
                                ctx.fillStyle = 'rgba(255, 0, 255, 0.6)';
                                def.vertices.forEach(v => {
                                    ctx.beginPath();
                                    ctx.arc(v.x, v.y, 3, 0, Math.PI * 2);
                                    ctx.fill();
                                });
                            } else if (def.type === 'segment') {
                                // Draw line segment
                                ctx.beginPath();
                                ctx.moveTo(def.start.x, def.start.y);
                                ctx.lineTo(def.end.x, def.end.y);
                                ctx.stroke();
                            }

                            ctx.setLineDash([]);
                        }
                    });

                    // PHASE 3A: Readable spatial graph summary along canvas edge
                    const summary = [];
                    const totalShapes = tempComponents.length;
                    const intersectingCount = tempGraph.connections.filter(c => c.relationship === 'intersecting').length;
                    const touchingCount = tempGraph.connections.filter(c => c.relationship === 'touching').length;
                    const totalIntersectionPoints = tempGraph.intersections.reduce((sum, i) => sum + i.points.length, 0);

                    summary.push(`Spatial Graph: ${totalShapes} shapes (magenta=ideal geometry)`);

                    if (tempGraph.connections.length > 0) {
                        const connParts = [];
                        if (intersectingCount > 0) connParts.push(`${intersectingCount} intersecting`);
                        if (touchingCount > 0) connParts.push(`${touchingCount} touching`);
                        summary.push(`${tempGraph.connections.length} connections (${connParts.join(', ')})`);
                    }

                    if (tempGraph.intersections.length > 0) {
                        summary.push(`${tempGraph.intersections.length} intersection pairs (${totalIntersectionPoints} points)`);
                    }

                    if (tempGraph.containment.length > 0) {
                        const containmentTypes = {};
                        tempGraph.containment.forEach(c => {
                            const type = c.type || 'bounds-based';
                            containmentTypes[type] = (containmentTypes[type] || 0) + 1;
                        });
                        const typeStr = Object.entries(containmentTypes)
                            .map(([type, count]) => {
                                const short = type.replace('circle-in-circle', 'C⊃C')
                                    .replace('circle-in-polygon', 'C⊃P')
                                    .replace('polygon-in-circle', 'P⊃C')
                                    .replace('polygon-in-polygon', 'P⊃P')
                                    .replace('bounds-based', 'BB');
                                return `${count}×${short}`;
                            })
                            .join(', ');
                        summary.push(`${tempGraph.containment.length} containment (${typeStr})`);
                    }

                    // PHASE 3B: Add parallel/perpendicular summary
                    if (tempGraph.parallelClusters && tempGraph.parallelClusters.length > 0) {
                        const totalParallelShapes = tempGraph.parallelClusters.reduce((sum, c) => sum + c.shapes.length, 0);
                        summary.push(`${tempGraph.parallelClusters.length} parallel clusters (${totalParallelShapes} shapes ∥)`);
                    }

                    if (tempGraph.perpendicularPairs && tempGraph.perpendicularPairs.length > 0) {
                        summary.push(`${tempGraph.perpendicularPairs.length} perpendicular pairs (⊥)`);
                    }

                    // Store summary for later rendering (draw last so it's on top)
                    window._spatialGraphSummary = summary.join(' · ');
                }

                // Draw semantic data visualization (Day 4)
                if (state.debugMode) {
                    state.semanticData.forEach((semantic, idx) => {
                        if (!semantic) return; // Skip unaccepted shapes

                        const isAccepted = state.context[idx] && state.context[idx] !== '';
                        if (!isAccepted) return;

                        // Draw semantic representation based on type
                        if (semantic.type === 'circle') {
                            // Draw center point
                            ctx.fillStyle = '#FF00FF'; // Magenta for semantic data
                            ctx.beginPath();
                            ctx.arc(semantic.center.x, semantic.center.y, 6, 0, Math.PI * 2);
                            ctx.fill();

                            // Draw radius indicator
                            ctx.strokeStyle = '#FF00FF';
                            ctx.lineWidth = 1;
                            ctx.setLineDash([3, 3]);
                            ctx.beginPath();
                            ctx.moveTo(semantic.center.x, semantic.center.y);
                            ctx.lineTo(semantic.center.x + semantic.radius, semantic.center.y);
                            ctx.stroke();
                            ctx.setLineDash([]);

                            // Label
                            ctx.fillStyle = '#FF00FF';
                            ctx.font = 'bold 11px sans-serif';
                            ctx.fillText(`r=${Math.round(semantic.radius)}`, semantic.center.x + 10, semantic.center.y - 10);

                        } else if (semantic.type === 'line') {
                            // Draw start point
                            ctx.fillStyle = '#00FF00'; // Green for start
                            ctx.beginPath();
                            ctx.arc(semantic.start.x, semantic.start.y, 5, 0, Math.PI * 2);
                            ctx.fill();

                            // Draw end point
                            ctx.fillStyle = '#FF0000'; // Red for end
                            ctx.beginPath();
                            ctx.arc(semantic.end.x, semantic.end.y, 5, 0, Math.PI * 2);
                            ctx.fill();

                            // Labels
                            ctx.fillStyle = '#00FF00';
                            ctx.font = 'bold 10px sans-serif';
                            ctx.fillText('S', semantic.start.x + 8, semantic.start.y - 8);
                            ctx.fillStyle = '#FF0000';
                            ctx.fillText('E', semantic.end.x + 8, semantic.end.y - 8);

                        } else if (semantic.type === 'rectangle' || semantic.type === 'triangle') {
                            // Draw corners
                            semantic.corners.forEach((corner, i) => {
                                ctx.fillStyle = '#FFFF00'; // Yellow for corners
                                ctx.beginPath();
                                ctx.arc(corner.x, corner.y, 5, 0, Math.PI * 2);
                                ctx.fill();

                                // Corner number
                                ctx.fillStyle = '#FFFF00';
                                ctx.font = 'bold 10px sans-serif';
                                ctx.fillText(`C${i}`, corner.x + 8, corner.y - 8);

                                // Angle if available
                                if (corner.angle !== undefined) {
                                    const angleDeg = Math.round(corner.angle * 180 / Math.PI);
                                    ctx.font = '9px sans-serif';
                                    ctx.fillText(`${angleDeg}°`, corner.x + 8, corner.y + 15);
                                }
                            });

                        } else if (semantic.type === 'user-shape') {
                            // Draw center point
                            ctx.fillStyle = '#00FFFF'; // Cyan for user shapes
                            ctx.beginPath();
                            ctx.arc(semantic.center.x, semantic.center.y, 5, 0, Math.PI * 2);
                            ctx.fill();

                            // Draw simplified boundary
                            if (semantic.boundary && semantic.boundary.length > 0) {
                                ctx.strokeStyle = '#00FFFF';
                                ctx.lineWidth = 1;
                                ctx.setLineDash([2, 2]);
                                ctx.beginPath();
                                semantic.boundary.forEach((point, i) => {
                                    if (i === 0) ctx.moveTo(point.x, point.y);
                                    else ctx.lineTo(point.x, point.y);
                                });
                                ctx.stroke();
                                ctx.setLineDash([]);
                            }
                        }

                        // Show semantic type label
                        const bounds = getBounds(state.strokes[idx]);
                        ctx.fillStyle = '#FF00FF';
                        ctx.font = 'bold 11px sans-serif';
                        ctx.fillText(`[${semantic.type}]`, bounds.maxX + 5, bounds.minY + 10);
                    });
                }

                // PHASE 3A: Draw spatial graph summary LAST (on top of everything)
                if (state.debugMode && window._spatialGraphSummary) {
                    const summaryText = window._spatialGraphSummary;

                    // Draw black background bar
                    ctx.fillStyle = 'rgba(0, 0, 0, 0.85)';
                    ctx.fillRect(0, canvas.height - 22, canvas.width, 22);

                    // Draw summary text
                    ctx.fillStyle = '#FFFF00'; // Yellow for visibility
                    ctx.font = 'bold 10px monospace';

                    // Word wrap if needed
                    const maxWidth = canvas.width - 20;
                    const words = summaryText.split(' ');
                    let line = '';
                    let y = canvas.height - 8;

                    for (let i = 0; i < words.length; i++) {
                        const testLine = line + (line ? ' ' : '') + words[i];
                        const metrics = ctx.measureText(testLine);

                        if (metrics.width > maxWidth && line) {
                            ctx.fillText(line, 10, y);
                            line = words[i];
                            y += 11;
                            if (y > canvas.height - 2) break; // Don't overflow
                        } else {
                            line = testLine;
                        }
                    }
                    if (y <= canvas.height - 2) {
                        ctx.fillText(line, 10, y);
                    }
                }

                // Update counters
                strokeCountSpan.textContent = state.strokes.length;
                acceptedCountSpan.textContent = state.context.filter(c => c && c !== '').length;
            }

            // ===== PHASE 5.5A: HISTORY & UNDO SYSTEM =====

            function recordAction(actionType, before, after, metadata = {}) {
                // Record an action for undo/redo
                // Trim history if we're not at the end (user undid then made new action)
                if (state.history.currentIndex < state.history.actions.length - 1) {
                    state.history.actions = state.history.actions.slice(0, state.history.currentIndex + 1);
                }

                const action = {
                    type: actionType,
                    timestamp: Date.now(),
                    before: before,
                    after: after,
                    metadata: metadata
                };

                state.history.actions.push(action);
                state.history.currentIndex++;

                // Trim to max size
                if (state.history.actions.length > state.history.maxSize) {
                    state.history.actions.shift();
                    state.history.currentIndex--;
                }
            }

            function captureState() {
                // Capture current state for history
                // Deep clone important arrays
                return {
                    strokes: state.strokes.map(s => [...s]),
                    strokeIds: [...state.strokeIds],  // PHASE 5.5C
                    context: [...state.context],
                    shapes: state.shapes.map(s => ({ ...s })),
                    refinedStrokes: state.refinedStrokes.map(s => s ? (Array.isArray(s[0]) ? s.map(seg => [...seg]) : [...s]) : null),
                    semanticData: state.semanticData.map(d => d ? { ...d } : null),
                    selectedStrokeIndex: state.selectedStrokeIndex,
                    suggestions: [...state.suggestions]
                };
            }

            function restoreState(snapshot) {
                // Restore state from snapshot
                state.strokes = snapshot.strokes.map(s => [...s]);
                state.strokeIds = [...(snapshot.strokeIds || [])];  // PHASE 5.5C: backward compatible
                state.context = [...snapshot.context];
                state.shapes = snapshot.shapes.map(s => ({ ...s }));
                state.refinedStrokes = snapshot.refinedStrokes.map(s => s ? (Array.isArray(s[0]) ? s.map(seg => [...seg]) : [...s]) : null);
                state.semanticData = snapshot.semanticData.map(d => d ? { ...d } : null);
                state.selectedStrokeIndex = snapshot.selectedStrokeIndex;
                state.suggestions = [...snapshot.suggestions];
            }

            function undo() {
                if (state.history.currentIndex < 0) {
                    console.log('Nothing to undo');
                    return false;
                }

                const action = state.history.actions[state.history.currentIndex];
                console.log('⏪ Undoing:', action.type);

                // Restore the before state
                restoreState(action.before);

                // Move pointer back
                state.history.currentIndex--;

                // Update UI - Re-analyze if we have a selected stroke
                if (state.selectedStrokeIndex !== null && state.strokes[state.selectedStrokeIndex]) {
                    // Re-analyze the stroke to show fresh suggestions
                    const stroke = state.strokes[state.selectedStrokeIndex];
                    const analysis = analyzeStrokeDetailed(stroke);
                    state.lastFingerprint = analysis.fingerprint;
                    updateMetrics(analysis);
                    showSuggestions(analysis);
                } else {
                    // No selected stroke, just clear suggestions
                    showSuggestions(null);
                    metricsContent.innerHTML = '<div class="no-stroke-message">Draw a stroke to see metrics...</div>';
                }

                updateCanvasLooksLike();
                render();

                return true;
            }

            function redo() {
                if (state.history.currentIndex >= state.history.actions.length - 1) {
                    console.log('Nothing to redo');
                    return false;
                }

                // Move pointer forward
                state.history.currentIndex++;

                const action = state.history.actions[state.history.currentIndex];
                console.log('⏩ Redoing:', action.type);

                // Restore the after state
                restoreState(action.after);

                // Update UI - Re-analyze if we have a selected stroke
                if (state.selectedStrokeIndex !== null && state.strokes[state.selectedStrokeIndex]) {
                    // Re-analyze the stroke to show fresh suggestions
                    const stroke = state.strokes[state.selectedStrokeIndex];
                    const analysis = analyzeStrokeDetailed(stroke);
                    state.lastFingerprint = analysis.fingerprint;
                    updateMetrics(analysis);
                    showSuggestions(analysis);
                } else {
                    // No selected stroke, just clear suggestions
                    showSuggestions(null);
                    metricsContent.innerHTML = '<div class="no-stroke-message">Draw a stroke to see metrics...</div>';
                }

                updateCanvasLooksLike();
                render();

                return true;
            }

            // ===== END HISTORY SYSTEM =====

            // PHASE 6C: Spatial clustering helper
            function spatialCluster(components, proximityThreshold) {
                // Group components that are close together
                // Uses simple union-find approach based on bounding box proximity

                if (components.length === 0) return [];
                if (components.length === 1) return [components];

                const clusters = [];
                const assigned = new Set();

                components.forEach((comp, idx) => {
                    if (assigned.has(idx)) return;

                    // Start new cluster
                    const cluster = [comp];
                    assigned.add(idx);

                    // Find all components close to any member of this cluster
                    let changed = true;
                    while (changed) {
                        changed = false;
                        components.forEach((other, otherIdx) => {
                            if (assigned.has(otherIdx)) return;

                            // Check if other is close to any member of current cluster
                            for (const member of cluster) {
                                const dist = boundingBoxDistance(member.bounds, other.bounds);
                                if (dist < proximityThreshold) {
                                    cluster.push(other);
                                    assigned.add(otherIdx);
                                    changed = true;
                                    break;
                                }
                            }
                        });
                    }

                    clusters.push(cluster);
                });

                return clusters;
            }

            function boundingBoxDistance(bounds1, bounds2) {
                // Calculate minimum distance between two bounding boxes
                // Returns 0 if they overlap or touch

                const leftDist = bounds1.minX - bounds2.maxX;
                const rightDist = bounds2.minX - bounds1.maxX;
                const topDist = bounds1.minY - bounds2.maxY;
                const bottomDist = bounds2.minY - bounds1.maxY;

                const horizDist = Math.max(leftDist, rightDist, 0);
                const vertDist = Math.max(topDist, bottomDist, 0);

                return Math.sqrt(horizDist * horizDist + vertDist * vertDist);
            }

            // PHASE 6C: Find subsets within cluster that match composition
            function findSubsetMatches(clusterComponents, libItem, compositionKey, threshold = 0.8) {
                // Greedy subset matching: find components within cluster that match composition

                const requiredCount = libItem.fingerprint.componentCount;
                const requiredTypes = libItem.fingerprint.componentTypes;

                vlog(`  🔎 Subset search for "${compositionKey}": need ${requiredCount} components of types [${requiredTypes.join(', ')}]`);

                // Quick rejection
                if (clusterComponents.length < requiredCount) {
                    vlog(`  ❌ Cluster too small (${clusterComponents.length} < ${requiredCount})`);
                    return [];
                }

                // Single-component compositions: try each matching component
                if (requiredCount === 1) {
                    const matches = [];
                    clusterComponents.forEach(comp => {
                        if (requiredTypes.includes(comp.type)) {
                            const subset = [comp];
                            const spatialGraph = buildSpatialGraph(subset);
                            const fingerprint = createCompositionFingerprint(subset, spatialGraph);

                            const matchResult = matchCompositionFingerprints(
                                fingerprint,
                                libItem.fingerprint,
                                threshold,
                                subset,
                                libItem.components
                            );

                            if (matchResult.matches) {
                                vlog(`  ✅ Single-component match! Score: ${matchResult.score.toFixed(2)}`);
                                matches.push({
                                    components: subset,
                                    score: matchResult.score,
                                    matchDetails: matchResult
                                });
                            }
                        }
                    });
                    return matches;
                }

                // Multi-component: use greedy spatial search
                // Build type-to-components mapping
                const typeMap = {};
                clusterComponents.forEach(comp => {
                    if (!typeMap[comp.type]) typeMap[comp.type] = [];
                    typeMap[comp.type].push(comp);
                });

                // Count required types
                const typeCounts = {};
                requiredTypes.forEach(t => {
                    typeCounts[t] = (typeCounts[t] || 0) + 1;
                });

                // Check if we have all required types
                for (const [type, count] of Object.entries(typeCounts)) {
                    if (!typeMap[type] || typeMap[type].length < count) {
                        vlog(`  ❌ Missing required type "${type}" (need ${count}, have ${typeMap[type]?.length || 0})`);
                        return [];
                    }
                }

                vlog(`  📋 Type availability:`, Object.entries(typeMap).map(([t, cs]) => `${t}:${cs.length}`).join(', '));

                // Generate combinations using recursive backtracking
                const matches = [];
                let combinationsTested = 0;
                const maxCombinations = 1000;

                function testCombination(subset) {
                    combinationsTested++;

                    // Build fingerprint for this subset
                    const spatialGraph = buildSpatialGraph(subset);
                    const fingerprint = createCompositionFingerprint(subset, spatialGraph);

                    const matchResult = matchCompositionFingerprints(
                        fingerprint,
                        libItem.fingerprint,
                        threshold,
                        subset,
                        libItem.components
                    );

                    vlog(`  🧪 Test combo ${combinationsTested}: [${subset.map(c => c.type).join(', ')}] → ${matchResult.matches ? '✅' : '❌'} (score: ${matchResult.score.toFixed(2)})`);

                    if (matchResult.matches) {
                        matches.push({
                            components: subset,
                            score: matchResult.score,
                            matchDetails: matchResult
                        });
                        return true; // Found a match
                    }
                    return false;
                }

                function generateCombinations(currentSubset, requiredTypesRemaining) {
                    if (combinationsTested >= maxCombinations) return;
                    if (matches.length > 0) return; // Greedy: stop after first match

                    if (requiredTypesRemaining.length === 0) {
                        testCombination(currentSubset);
                        return;
                    }

                    const nextType = requiredTypesRemaining[0];
                    const candidates = typeMap[nextType] || [];

                    for (let i = 0; i < candidates.length; i++) {
                        const candidate = candidates[i];

                        // Skip if already in subset
                        if (currentSubset.some(c => c.index === candidate.index)) continue;

                        // If subset has components, check spatial proximity (within same cluster)
                        if (currentSubset.length > 0) {
                            const isNearby = currentSubset.some(c => {
                                const dist = boundingBoxDistance(c.bounds, candidate.bounds);
                                // DAY 5 FIX: Reduced from 200px to 35px for tighter matching
                                return dist < 35;
                            });
                            if (!isNearby) continue;
                        }

                        generateCombinations(
                            [...currentSubset, candidate],
                            requiredTypesRemaining.slice(1)
                        );
                    }
                }

                // Start recursive search
                vlog(`  🔍 Starting combination search...`);
                generateCombinations([], requiredTypes);
                vlog(`  📊 Tested ${combinationsTested} combinations, found ${matches.length} matches`);

                return matches;
            }

            // Phase 3C: Check canvas for composition matches
            function checkCanvasForCompositions() {
                // PHASE 5.5D: Unified composition checker - checks ALL compositions (built-in + user)
                // PHASE 6C: Now with subset matching - finds multiple compositions on canvas

                // Auto-name unaccepted strokes temporarily for matching (don't persist)
                const tempContext = [...state.context];
                let artCounter = 0;
                state.strokes.forEach((stroke, idx) => {
                    if (!tempContext[idx] || tempContext[idx] === '') {
                        tempContext[idx] = `art${artCounter}`;
                        artCounter++;
                    }
                });

                // Need at least 1 stroke to check
                if (state.strokes.length < 1) return [];

                // PHASE 6C: Spatial clustering for subset matching
                // Group nearby strokes into clusters, check each cluster separately

                // Build all components first
                const allComponents = state.strokes.map((stroke, idx) => {
                    const recognizedAs = tempContext[idx] || '';
                    if (!recognizedAs) return null;

                    // Extract type for fingerprinting
                    let type = 'unknown';
                    if (recognizedAs.startsWith('art')) {
                        type = 'art';
                    } else if (state.library[recognizedAs]) {
                        const libItem = state.library[recognizedAs];
                        type = libItem.shapeType || libItem.type || 'user-shape';
                    } else {
                        type = recognizedAs;
                    }

                    return {
                        index: idx,
                        strokeId: state.strokeIds[idx],
                        originalStroke: stroke,
                        refinedStroke: state.refinedStrokes[idx],
                        recognizedAs: recognizedAs,
                        type: type,
                        fingerprint: getFingerprint(stroke),
                        bounds: getBounds(stroke),
                        geometricShape: state.shapes[idx]
                    };
                }).filter(c => c !== null);

                if (allComponents.length < 1) return [];

                // Spatial clustering: group components that are close together
                // DAY 5 FIX: Reduced from 100px to 35px for tighter matching (requires actual overlap/touching)
                const clusters = spatialCluster(allComponents, 35);

                console.log(`🔍 Found ${clusters.length} spatial clusters:`, clusters.map(c => c.length));

                // Check each cluster for composition matches
                const allMatches = [];

                clusters.forEach((clusterComponents, clusterIdx) => {
                    vlog(`\n🔍 === CLUSTER ${clusterIdx}: ${clusterComponents.length} components ===`);
                    vlog('🔍 Components:', clusterComponents.map(c => `${c.recognizedAs}(${c.type})`).join(', '));

                    if (clusterComponents.length < 1) return;

                    // Track which components are already matched (for non-overlapping matches)
                    const usedIndices = new Set();

                    // PHASE 6C FIX: Sort compositions by component count (descending)
                    // This ensures larger compositions match first, preventing smaller ones from claiming components
                    const compositionKeys = Object.keys(state.library)
                        .filter(key => {
                            const item = state.library[key];
                            return (item.type === 'builtin-composition' || item.type === 'composition') && item.fingerprint;
                        })
                        .sort((a, b) => {
                            const countA = state.library[a].fingerprint.componentCount || 0;
                            const countB = state.library[b].fingerprint.componentCount || 0;
                            return countB - countA; // Descending order (larger first)
                        });

                    vlog(`🔍 Checking compositions in priority order: ${compositionKeys.map(k => `${k}(${state.library[k].fingerprint.componentCount})`).join(', ')}`);

                    // Check compositions in priority order (larger component count first)
                    compositionKeys.forEach(key => {
                        const libItem = state.library[key];

                        vlog(`\n🔍 Searching for "${key}" in cluster ${clusterIdx}...`);

                        // Find subset matches within this cluster
                        const subsetMatches = findSubsetMatches(
                            clusterComponents,
                            libItem,
                            key,
                            0.8
                        );

                        if (subsetMatches.length > 0) {
                            // Take best match (greedy)
                            const bestMatch = subsetMatches[0];
                            const componentIndices = bestMatch.components.map(c => c.index);

                            // Check if any components are already used
                            const hasOverlap = componentIndices.some(idx => usedIndices.has(idx));

                            if (!hasOverlap) {
                                console.log(`✅ Found "${key}" in cluster ${clusterIdx}! Components: [${componentIndices.join(', ')}]`);

                                // Mark components as used
                                componentIndices.forEach(idx => usedIndices.add(idx));

                                // Add to matches
                                allMatches.push({
                                    type: key,
                                    label: libItem.label,
                                    score: Math.round(bestMatch.score * 100),
                                    confidence: bestMatch.score,
                                    isComposition: true,
                                    componentCount: libItem.fingerprint.componentCount,
                                    matchDetails: bestMatch.matchDetails,
                                    clusterIndex: clusterIdx,
                                    componentIndices: componentIndices
                                });
                            } else {
                                console.log(`⚠️ "${key}" match overlaps with already-matched components, skipping`);
                            }
                        }
                    });

                    vlog(`🔍 Cluster ${clusterIdx} complete. Used ${usedIndices.size}/${clusterComponents.length} components.`);
                });

                console.log('🔍 Final matches from all clusters:', allMatches);
                return allMatches;
            }

            function showSuggestions(analysis) {
                // Primitive suggestions from stroke analysis
                const allResults = analysis ? analysis.results : [];
                let suggestions = allResults.filter(r => r.score > 10);

                // Phase 3C: Check for composition matches (canvas-level)
                const compositionMatches = checkCanvasForCompositions();
                if (compositionMatches.length > 0) {
                    // Add composition matches to suggestions
                    suggestions = [...compositionMatches, ...suggestions];
                }

                // DAY 5 FIX: Sort suggestions by score (descending) - highest confidence first
                suggestions.sort((a, b) => {
                    const scoreA = a.score || Math.round((a.confidence || 0) * 100);
                    const scoreB = b.score || Math.round((b.confidence || 0) * 100);
                    return scoreB - scoreA; // Descending order
                });

                state.suggestions = suggestions;

                // Update status
                if (suggestions.length === 0) {
                    recognitionStatus.textContent = 'No strong matches';
                    recognitionStatus.style.background = '#5c4033';
                    recognitionStatus.style.color = '#fbbf24';
                } else {
                    recognitionStatus.textContent = `Found ${suggestions.length} match${suggestions.length > 1 ? 'es' : ''}`;
                    recognitionStatus.style.background = '#2d4a3e';
                    recognitionStatus.style.color = '#4ade80';
                }

                suggestionsDiv.innerHTML = '';

                if (suggestions.length > 0) {
                    suggestions.forEach(sug => {
                        const btn = document.createElement('button');
                        btn.className = 'suggestion-button';
                        const score = sug.score || Math.round(sug.confidence * 100);

                        // Confidence-based styling
                        let confidenceClass = 'low';
                        let confidenceText = 'low';
                        if (score >= 60) {
                            confidenceClass = 'high';
                            confidenceText = 'high';
                        } else if (score >= 30) {
                            confidenceClass = 'medium';
                            confidenceText = 'medium';
                        }

                        const compositionBadge = sug.isComposition
                            ? `<span style="font-size:10px;opacity:0.7">(${sug.componentCount} strokes)</span> `
                            : '';

                        btn.innerHTML = `
                        <span class="label">${sug.label} ${compositionBadge}</span>
                        <span class="confidence ${confidenceClass}">
                            ${score}/100 (${confidenceText} confidence)
                        </span>
                    `;
                        btn.onclick = () => acceptSuggestion(sug);
                        suggestionsDiv.appendChild(btn);
                    });
                }

                // Always show "Something else" button
                const elseBtn = document.createElement('button');
                elseBtn.className = 'something-else-button';
                elseBtn.textContent = 'Something else';
                elseBtn.onclick = handleSomethingElse;
                suggestionsDiv.appendChild(elseBtn);
            }

            function acceptSuggestion(suggestion) {
                // PHASE 5.5A: Capture state before acceptance (for undo)
                const beforeState = captureState();

                // PHASE 3C: Handle composition acceptance (multi-stroke)
                if (suggestion.isComposition) {
                    // Accept all strokes that are currently on canvas
                    // Option A: Accept entire canvas as the composition
                    const compositionName = suggestion.type;

                    state.strokes.forEach((stroke, idx) => {
                        // Only accept strokes that have been recognized (have context)
                        if (state.context[idx] && state.context[idx] !== '') {
                            // Keep existing context - don't overwrite individual stroke names
                            // The composition is recorded separately

                            // Mark shape as accepted if it exists
                            if (state.shapes[idx]) {
                                state.shapes[idx].accepted = true;
                            }
                        }
                    });

                    // Increment usage count for composition in library
                    if (state.library[compositionName]) {
                        state.library[compositionName].usageCount++;
                        saveLibrary();
                        renderLibrary();
                    }

                    // Reset UI
                    state.selectedStrokeIndex = null;
                    fuzzyMatchInput.value = '';
                    fuzzyMatchInput.blur();  // DAY 5 FIX: Remove focus after acceptance
                    recognitionStatus.textContent = `Composition "${suggestion.label}" accepted!`;
                    recognitionStatus.style.background = '#4CAF50';
                    recognitionStatus.style.color = '#fff';

                    // Update and render
                    updateCanvasLooksLike();
                    render();

                    // PHASE 5.5A: Record action for undo
                    const afterState = captureState();
                    recordAction('accept-composition', beforeState, afterState, {
                        suggestion: suggestion,
                        compositionName: compositionName
                    });

                    // DAY 5 FIX: Check for remaining composition matches after acceptance
                    showSuggestions(null);

                    // Reset status after 2 seconds if no new suggestions
                    setTimeout(() => {
                        if (state.suggestions.length === 0) {
                            recognitionStatus.textContent = 'Waiting for stroke...';
                            recognitionStatus.style.background = '#555';
                            recognitionStatus.style.color = '#ccc';
                        }
                    }, 2000);

                    return;
                }

                // Regular single-stroke acceptance
                if (state.selectedStrokeIndex === null) return;

                const strokeIndex = state.selectedStrokeIndex;
                const originalStroke = state.strokes[strokeIndex];

                // Set context
                state.context[strokeIndex] = suggestion.type;

                // Generate refined geometry ONLY for built-in shapes
                // User-saved shapes are NOT refined - they stay as original stroke (just turn blue)
                if (suggestion.isUserPrimitive) {
                    // No refinement for user primitives
                    state.refinedStrokes[strokeIndex] = null;
                    state.tipDebugData[strokeIndex] = null;
                } else {
                    // Refine built-in shapes (circle, line, rectangle, triangle)
                    const refined = refineStroke(originalStroke, suggestion.type, state.lastFingerprint);
                    state.refinedStrokes[strokeIndex] = refined;

                    // Store tip debug data for triangles
                    if (suggestion.type === 'triangle') {
                        const tipData = detectTriangleTipDirection(originalStroke);
                        state.tipDebugData[strokeIndex] = tipData.tipPoint;
                    } else {
                        state.tipDebugData[strokeIndex] = null;
                    }

                    // Store corner debug data for visualization (triangles and rectangles)
                    if ((suggestion.type === 'triangle' || suggestion.type === 'rectangle') &&
                        state.lastFingerprint && state.lastFingerprint.cornerData) {
                        state.cornerDebugData[strokeIndex] = state.lastFingerprint.cornerData;
                    } else {
                        state.cornerDebugData[strokeIndex] = null;
                    }
                }

                // UNIFIED GEOMETRY: Modify existing geometric shape (already created in mouseup)
                const existingShape = state.shapes[strokeIndex];

                if (existingShape) {
                    // Update acceptance and label
                    existingShape.accepted = true;
                    existingShape.label = suggestion.type;

                    // Re-extract geometric definition
                    // For polygons (rectangle/triangle), refined strokes are segment-based arrays
                    // which don't work with polygon extraction - always use original stroke
                    const isPolygon = (suggestion.type === 'rectangle' || suggestion.type === 'triangle');
                    const strokeToUse = (isPolygon || !state.refinement.enabled || !state.refinedStrokes[strokeIndex])
                        ? originalStroke
                        : state.refinedStrokes[strokeIndex];

                    const newShape = extractGeometricShape(
                        strokeToUse,
                        suggestion.type,
                        state.lastFingerprint,
                        suggestion.type,
                        true  // accepted = true
                    );

                    // Update the geometric type, definition, rendering, and properties
                    existingShape.type = newShape.type;
                    existingShape.formalism = newShape.formalism;
                    existingShape.definition = newShape.definition;
                    existingShape.rendering = newShape.rendering;
                    existingShape.properties = newShape.properties;

                    // Legacy compatibility
                    state.semanticData[strokeIndex] = existingShape.definition;
                } else {
                    // Fallback: create shape if it doesn't exist (shouldn't happen with unified geometry)
                    console.warn(`⚠️ Shape ${strokeIndex} didn't exist, creating new one`);
                    const shape = extractGeometricShape(
                        originalStroke,
                        suggestion.type,
                        state.lastFingerprint,
                        suggestion.type,
                        true  // accepted = true
                    );
                    state.shapes[strokeIndex] = shape;
                    state.semanticData[strokeIndex] = shape.definition;
                }

                // Increment usage count in library
                if (state.library[suggestion.type]) {
                    state.library[suggestion.type].usageCount++;
                    saveLibrary();
                    renderLibrary();
                }

                state.selectedStrokeIndex = null;

                // Reset UI
                fuzzyMatchInput.value = '';
                fuzzyMatchInput.blur();  // DAY 5 FIX: Remove focus after acceptance

                // DAY 5 FIX: Check for composition matches after accepting primitive
                // Use unified showSuggestions() instead of duplicate code
                showSuggestions(null);

                // Day 4: Update composition matching (for debug area)
                updateCanvasLooksLike();

                // PHASE 5.5A: Record action for undo
                const afterState = captureState();
                recordAction('accept-primitive', beforeState, afterState, {
                    suggestion: suggestion,
                    strokeIndex: state.selectedStrokeIndex
                });

                render();
            }

            function handleSomethingElse() {
                if (state.selectedStrokeIndex === null) return;

                // Check if fuzzy match input has text - use it for save
                const fuzzyText = fuzzyMatchInput.value.trim();

                if (fuzzyText) {
                    // Save directly with fuzzy match text
                    const name = fuzzyText;
                    const key = name.toLowerCase().replace(/\s+/g, '-');

                    // Check if name already exists
                    if (state.library[key]) {
                        alert('A shape with that name already exists! Try a different name.');
                        return;
                    }

                    // Save the stroke as new primitive
                    const strokeIndex = state.selectedStrokeIndex;
                    const stroke = state.strokes[strokeIndex];

                    // Use refined stroke if refinement is enabled and available
                    const refinedStroke = state.refinedStrokes[strokeIndex];
                    const strokeToSave = (state.refinement.enabled && refinedStroke) ? refinedStroke : stroke;

                    const fingerprint = getFingerprint(strokeToSave);

                    // PHASE 6A: Capture what this shape is based on (if any)
                    const oldContext = state.context[strokeIndex];
                    const builtinShapes = ['circle', 'rectangle', 'triangle', 'line', 'point'];
                    const basedOn = builtinShapes.includes(oldContext) ? oldContext : null;

                    state.library[key] = {
                        type: 'user-primitive',
                        label: name,
                        strokes: [strokeToSave],
                        fingerprint: fingerprint,
                        basedOn: basedOn,  // PHASE 6A: Reference to built-in shape (if any)
                        usageCount: 0,
                        created: Date.now()
                    };

                    // Update context
                    state.context[strokeIndex] = key;
                    state.library[key].usageCount++;

                    saveLibrary();
                    renderLibrary();
                    render();

                    // Clear inputs and reset
                    fuzzyMatchInput.value = '';
                    state.selectedStrokeIndex = null;
                    recognitionStatus.textContent = 'Waiting for stroke...';
                    recognitionStatus.style.background = '#555';
                    recognitionStatus.style.color = '#ccc';
                    suggestionsDiv.innerHTML = '<button class="something-else-button disabled">Something else</button>';
                } else {
                    // No fuzzy text - show inline save UI as fallback
                    showSavePrimitiveUI();
                }
            }

            // ===== FUZZY MATCHING =====

            function getAllAvailableShapes() {
                // Get all shapes: built-ins + user primitives
                const shapes = [];

                Object.keys(state.library).forEach(key => {
                    const item = state.library[key];
                    shapes.push({
                        key: key,
                        label: item.label,
                        type: item.type
                    });
                });

                return shapes;
            }

            function fuzzyMatchScore(query, target) {
                // Simple fuzzy matching: case-insensitive substring match with position bonus
                query = query.toLowerCase();
                target = target.toLowerCase();

                if (target === query) return 100; // Exact match
                if (target.startsWith(query)) return 80; // Starts with
                if (target.includes(query)) return 60; // Contains

                // Check if all characters in query appear in order in target
                let queryIndex = 0;
                for (let i = 0; i < target.length && queryIndex < query.length; i++) {
                    if (target[i] === query[queryIndex]) {
                        queryIndex++;
                    }
                }
                if (queryIndex === query.length) return 40; // All chars present in order

                return 0; // No match
            }

            function handleFuzzyMatch() {
                const query = fuzzyMatchInput.value.trim();

                if (!query) {
                    // Empty query - show normal suggestions if stroke is selected
                    if (state.selectedStrokeIndex !== null && state.lastFingerprint) {
                        const analysis = analyzeStrokeDetailed(state.strokes[state.selectedStrokeIndex]);
                        showSuggestions(analysis);
                    }
                    return;
                }

                // Get all available shapes
                const allShapes = getAllAvailableShapes();

                // Score and sort by match quality
                const matches = allShapes
                    .map(shape => ({
                        ...shape,
                        score: fuzzyMatchScore(query, shape.label)
                    }))
                    .filter(m => m.score > 0)
                    .sort((a, b) => b.score - a.score);

                // Update suggestions display
                if (matches.length === 0) {
                    recognitionStatus.textContent = 'No matches found';
                    recognitionStatus.style.background = '#5c4033';
                    recognitionStatus.style.color = '#fbbf24';

                    // Clear state.suggestions so Enter triggers "something else"
                    state.suggestions = [];

                    // Show active "Something else" button if there's a selected stroke
                    if (state.selectedStrokeIndex !== null) {
                        const elseBtn = document.createElement('button');
                        elseBtn.className = 'something-else-button';
                        elseBtn.textContent = `Save as "${query}"`;
                        elseBtn.onclick = handleSomethingElse;
                        suggestionsDiv.innerHTML = '';
                        suggestionsDiv.appendChild(elseBtn);
                    } else {
                        suggestionsDiv.innerHTML = '<button class="something-else-button disabled">Something else</button>';
                    }
                } else {
                    recognitionStatus.textContent = `Found ${matches.length} match${matches.length > 1 ? 'es' : ''}`;
                    recognitionStatus.style.background = '#2d4a3e';
                    recognitionStatus.style.color = '#4ade80';

                    // Update state.suggestions so Enter key can accept first match
                    state.suggestions = matches.slice(0, 5).map(match => ({
                        type: match.key,
                        label: match.label,
                        score: match.score,
                        confidence: match.score / 100
                    }));

                    suggestionsDiv.innerHTML = '';

                    state.suggestions.forEach(match => {
                        const btn = document.createElement('button');
                        btn.className = 'suggestion-button';
                        btn.innerHTML = `
                        <span class="label">${match.label}</span>
                        <span class="confidence ${match.score > 70 ? 'high' : 'medium'}">
                            ${match.score}/100 (fuzzy match)
                        </span>
                    `;
                        btn.onclick = () => {
                            if (state.selectedStrokeIndex !== null) {
                                acceptSuggestion(match);
                            }
                        };
                        suggestionsDiv.appendChild(btn);
                    });

                    const elseBtn = document.createElement('button');
                    elseBtn.className = 'something-else-button';
                    elseBtn.textContent = 'Something else';
                    elseBtn.onclick = handleSomethingElse;
                    suggestionsDiv.appendChild(elseBtn);
                }
            }

            // Mouse events
            console.log('Attaching mouse events to canvas...');

            canvas.addEventListener('mousedown', (e) => {
                const rect = canvas.getBoundingClientRect();
                const point = {
                    x: e.clientX - rect.left,
                    y: e.clientY - rect.top
                };
                state.isDrawing = true;
                state.currentStroke = [point];
            });

            canvas.addEventListener('mousemove', (e) => {
                if (!state.isDrawing) return;

                const rect = canvas.getBoundingClientRect();
                const point = {
                    x: e.clientX - rect.left,
                    y: e.clientY - rect.top
                };
                state.currentStroke.push(point);
                render();
            });

            canvas.addEventListener('mouseup', () => {
                if (state.currentStroke.length > 0) {
                    // DAY 5: Check for point detection (zero-length stroke)
                    const isPoint = checkIfPoint(state.currentStroke);

                    if (isPoint) {
                        // Calculate average position (in case of tiny movement)
                        const avgX = state.currentStroke.reduce((sum, p) => sum + p.x, 0) / state.currentStroke.length;
                        const avgY = state.currentStroke.reduce((sum, p) => sum + p.y, 0) / state.currentStroke.length;

                        // Add to legacy arrays
                        state.strokes.push([...state.currentStroke]);
                        state.strokeIds.push(`stroke-${state.nextStrokeId++}`); // PHASE 5.5C
                        state.context.push('point');
                        state.semanticData.push({ type: 'point', x: avgX, y: avgY });

                        // DAY 5: Create Shape object
                        const pointShape = createPointShape(avgX, avgY, 'point', true);
                        state.shapes.push(pointShape);

                        // PHASE 5.5A: Record stroke creation for undo
                        const afterState = captureState();
                        recordAction('draw-point', {
                            strokes: state.strokes.slice(0, -1),
                            strokeIds: state.strokeIds.slice(0, -1),  // PHASE 5.5C
                            context: state.context.slice(0, -1),
                            shapes: state.shapes.slice(0, -1),
                            refinedStrokes: state.refinedStrokes.slice(0, -1),
                            semanticData: state.semanticData.slice(0, -1),
                            selectedStrokeIndex: null,
                            suggestions: []
                        }, afterState, {
                            strokeIndex: state.strokes.length - 1,
                            type: 'point'
                        });

                        // Update UI
                        state.selectedStrokeIndex = state.strokes.length - 1;
                        recognitionStatus.textContent = 'Point detected';
                        recognitionStatus.style.background = '#4CAF50';
                        recognitionStatus.style.color = '#fff';

                    } else {
                        // Normal stroke processing
                        state.strokes.push([...state.currentStroke]);
                        state.strokeIds.push(`stroke-${state.nextStrokeId++}`); // PHASE 5.5C
                        state.context.push(''); // Unaccepted initially
                        state.semanticData.push(null); // Will be filled when accepted

                        try {
                            // Analyze and show detailed results
                            const analysis = analyzeStrokeDetailed(state.currentStroke);
                            state.selectedStrokeIndex = state.strokes.length - 1;
                            state.lastFingerprint = analysis.fingerprint;  // Cache for refinement

                            // UNIFIED GEOMETRY: Create geometric shape for ALL strokes
                            // Determine best-fit geometry based on analysis
                            let geometricType = 'curve'; // Default fallback
                            let geometricLabel = 'curve';

                            if (analysis.results.length > 0) {
                                // Use top recognition result for geometry type
                                const topResult = analysis.results[0];
                                geometricType = topResult.type;
                                geometricLabel = topResult.label;
                            }

                            // Create geometric shape (unaccepted initially)
                            const shape = extractGeometricShape(
                                state.currentStroke,
                                geometricType,
                                analysis.fingerprint,
                                geometricLabel,
                                false  // accepted = false (unaccepted stroke)
                            );

                            state.shapes.push(shape);

                            // PHASE 5.5A: Record stroke creation for undo
                            const afterState = captureState();
                            recordAction('draw-stroke', {
                                strokes: state.strokes.slice(0, -1),
                                strokeIds: state.strokeIds.slice(0, -1),  // PHASE 5.5C
                                context: state.context.slice(0, -1),
                                shapes: state.shapes.slice(0, -1),
                                refinedStrokes: state.refinedStrokes.slice(0, -1),
                                semanticData: state.semanticData.slice(0, -1),
                                selectedStrokeIndex: null,
                                suggestions: []
                            }, afterState, {
                                strokeIndex: state.strokes.length - 1,
                                topSuggestion: analysis.results.length > 0 ? analysis.results[0].type : 'none'
                            });

                            updateMetrics(analysis);
                            showSuggestions(analysis);
                        } catch (error) {
                            console.error('Error in analysis:', error);
                            alert('Error analyzing stroke: ' + error.message);
                        }

                        // Update refined strokes if refinement is enabled
                        if (state.refinement.enabled) {
                            updateRefinedStrokes();
                        }
                    }
                }
                state.isDrawing = false;
                state.currentStroke = [];
                render();
            });

            canvas.addEventListener('mouseleave', () => {
                if (state.isDrawing) {
                    if (state.currentStroke.length > 0) {
                        state.strokes.push([...state.currentStroke]);
                        state.strokeIds.push(`stroke-${state.nextStrokeId++}`); // PHASE 5.5C
                        state.context.push(''); // Unaccepted initially
                        state.semanticData.push(null); // Will be filled when accepted

                        const analysis = analyzeStrokeDetailed(state.currentStroke);
                        state.selectedStrokeIndex = state.strokes.length - 1;
                        state.lastFingerprint = analysis.fingerprint;  // Cache for refinement

                        // UNIFIED GEOMETRY: Create geometric shape for ALL strokes
                        let geometricType = 'curve';
                        let geometricLabel = 'curve';

                        if (analysis.results.length > 0) {
                            const topResult = analysis.results[0];
                            geometricType = topResult.type;
                            geometricLabel = topResult.label;
                        }

                        const shape = extractGeometricShape(
                            state.currentStroke,
                            geometricType,
                            analysis.fingerprint,
                            geometricLabel,
                            false  // accepted = false
                        );

                        state.shapes.push(shape);

                        // PHASE 5.5A: Record stroke creation for undo
                        const afterState = captureState();
                        recordAction('draw-stroke', {
                            strokes: state.strokes.slice(0, -1),
                            strokeIds: state.strokeIds.slice(0, -1),  // PHASE 5.5C
                            context: state.context.slice(0, -1),
                            shapes: state.shapes.slice(0, -1),
                            refinedStrokes: state.refinedStrokes.slice(0, -1),
                            semanticData: state.semanticData.slice(0, -1),
                            selectedStrokeIndex: null,
                            suggestions: []
                        }, afterState, {
                            strokeIndex: state.strokes.length - 1,
                            topSuggestion: analysis.results.length > 0 ? analysis.results[0].type : 'none'
                        });

                        updateMetrics(analysis);
                        showSuggestions(analysis);

                        // Update refined strokes if refinement is enabled
                        if (state.refinement.enabled) {
                            updateRefinedStrokes();
                        }
                    }
                    state.isDrawing = false;
                    state.currentStroke = [];
                    render();
                }
            });

            // Library Management Functions
            function generateThumbnail(item, maxHeight = 70) {
                // Generate a thumbnail canvas for a library item
                // Maintains aspect ratio within maxHeight constraint

                // Determine what to draw
                let strokesToDraw = [];
                let isBuiltin = false;
                let isBuiltinComposition = false;

                if (item.type === 'builtin-composition') {
                    // Built-in composition (like arrow) - render iconic version
                    isBuiltinComposition = true;
                } else if (item.type === 'composition' && item.components) {
                    // Draw composition - all strokes
                    strokesToDraw = item.components.map(c => c.originalStroke || c.refinedStroke || []);
                } else if (item.strokes && item.strokes.length > 0) {
                    // User primitive with strokes
                    strokesToDraw = item.strokes;
                } else if (item.type === 'builtin-primitive') {
                    isBuiltin = true;
                }

                // Calculate dimensions based on content
                let canvasWidth = maxHeight;
                let canvasHeight = maxHeight;

                if (!isBuiltin && strokesToDraw.length > 0) {
                    // Calculate bounding box for actual content
                    let allPoints = [];
                    strokesToDraw.forEach(stroke => {
                        if (stroke && stroke.length > 0) {
                            allPoints = allPoints.concat(stroke);
                        }
                    });

                    if (allPoints.length > 0) {
                        const bounds = getBounds(allPoints);
                        const contentWidth = bounds.maxX - bounds.minX;
                        const contentHeight = bounds.maxY - bounds.minY;
                        const aspectRatio = contentWidth / contentHeight;

                        // Adjust canvas size to maintain aspect ratio
                        if (aspectRatio > 1) {
                            // Wider than tall
                            canvasWidth = maxHeight * aspectRatio;
                            canvasHeight = maxHeight;
                        } else {
                            // Taller than wide
                            canvasWidth = maxHeight;
                            canvasHeight = maxHeight / aspectRatio;
                        }

                        // Cap maximum width to avoid extremely wide thumbnails
                        const maxWidth = maxHeight * 2;
                        if (canvasWidth > maxWidth) {
                            canvasHeight = canvasHeight * (maxWidth / canvasWidth);
                            canvasWidth = maxWidth;
                        }
                    }
                }

                const thumbnailCanvas = document.createElement('canvas');
                thumbnailCanvas.width = canvasWidth;
                thumbnailCanvas.height = canvasHeight;
                const thumbCtx = thumbnailCanvas.getContext('2d');

                // Clear with light gray background
                thumbCtx.fillStyle = '#F5F5F5';
                thumbCtx.fillRect(0, 0, canvasWidth, canvasHeight);

                if (isBuiltin || isBuiltinComposition) {
                    // Draw built-in primitives and compositions as simple shapes
                    thumbCtx.strokeStyle = '#7C3AED';
                    thumbCtx.lineWidth = 2;
                    thumbCtx.lineCap = 'round';
                    thumbCtx.lineJoin = 'round';

                    const center = canvasWidth / 2;
                    const centerY = canvasHeight / 2;
                    const radius = Math.min(canvasWidth, canvasHeight) * 0.3;

                    if (isBuiltinComposition) {
                        // Draw iconic representation of built-in compositions
                        // For arrow: line + triangle
                        if (item.label === 'Arrow') {
                            // Draw horizontal line
                            thumbCtx.beginPath();
                            thumbCtx.moveTo(canvasWidth * 0.15, centerY);
                            thumbCtx.lineTo(canvasWidth * 0.65, centerY);
                            thumbCtx.stroke();

                            // Draw triangle arrowhead pointing right
                            thumbCtx.beginPath();
                            thumbCtx.moveTo(canvasWidth * 0.85, centerY); // tip
                            thumbCtx.lineTo(canvasWidth * 0.65, centerY - radius * 0.6); // top corner
                            thumbCtx.lineTo(canvasWidth * 0.65, centerY + radius * 0.6); // bottom corner
                            thumbCtx.closePath();
                            thumbCtx.stroke();
                        }
                    } else {
                        // Built-in primitives
                        switch (item.shapeType) {
                            case 'circle':
                                // Draw as circle (can be elongated via aspectRatio)
                                thumbCtx.beginPath();
                                thumbCtx.arc(center, centerY, radius, 0, Math.PI * 2);
                                thumbCtx.stroke();
                                break;
                            case 'triangle':
                                thumbCtx.beginPath();
                                thumbCtx.moveTo(center, canvasHeight * 0.2);
                                thumbCtx.lineTo(canvasWidth * 0.2, canvasHeight * 0.7);
                                thumbCtx.lineTo(canvasWidth * 0.8, canvasHeight * 0.7);
                                thumbCtx.closePath();
                                thumbCtx.stroke();
                                break;
                            case 'rectangle':
                                thumbCtx.strokeRect(canvasWidth * 0.2, canvasHeight * 0.25, canvasWidth * 0.6, canvasHeight * 0.5);
                                break;
                        }
                    }
                    return thumbnailCanvas;
                }

                // Draw user-created strokes
                if (strokesToDraw.length > 0) {
                    // Calculate bounding box for all strokes
                    let allPoints = [];
                    strokesToDraw.forEach(stroke => {
                        if (stroke && stroke.length > 0) {
                            allPoints = allPoints.concat(stroke);
                        }
                    });

                    if (allPoints.length > 0) {
                        const bounds = getBounds(allPoints);
                        const width = bounds.maxX - bounds.minX;
                        const height = bounds.maxY - bounds.minY;

                        // Calculate scale to fit in thumbnail with padding
                        const padding = Math.min(canvasWidth, canvasHeight) * 0.1;
                        const scaleX = (canvasWidth - padding * 2) / width;
                        const scaleY = (canvasHeight - padding * 2) / height;
                        const scale = Math.min(scaleX, scaleY);

                        // Center the drawing
                        const offsetX = (canvasWidth - width * scale) / 2;
                        const offsetY = (canvasHeight - height * scale) / 2;

                        // Draw each stroke
                        thumbCtx.strokeStyle = '#7C3AED';
                        thumbCtx.lineWidth = 2;
                        thumbCtx.lineCap = 'round';
                        thumbCtx.lineJoin = 'round';

                        strokesToDraw.forEach(stroke => {
                            if (!stroke || stroke.length === 0) return;

                            thumbCtx.beginPath();
                            stroke.forEach((point, i) => {
                                const x = (point.x - bounds.minX) * scale + offsetX;
                                const y = (point.y - bounds.minY) * scale + offsetY;
                                if (i === 0) thumbCtx.moveTo(x, y);
                                else thumbCtx.lineTo(x, y);
                            });
                            thumbCtx.stroke();
                        });
                    }
                }

                return thumbnailCanvas;
            }

            function renderLibrary() {
                // Get all library items, separated by type
                const builtins = Object.keys(state.library).filter(key =>
                    state.library[key].type === 'builtin-primitive' || state.library[key].type === 'builtin-composition'
                );

                const userItems = Object.keys(state.library).filter(key =>
                    state.library[key].type === 'user-primitive' || state.library[key].type === 'composition'
                );

                // Combine: built-ins first, then user items
                const allItems = [...builtins, ...userItems];

                if (allItems.length === 0) {
                    libraryGrid.innerHTML = '<div class="empty-message">No shapes yet</div>';
                    return;
                }

                // Render all items
                libraryGrid.innerHTML = allItems.map(key => {
                    const item = state.library[key];
                    const isBuiltin = item.type === 'builtin-primitive' || item.type === 'builtin-composition';

                    // Determine type and meta info
                    let metaInfo = '';
                    let typeLabel = '';

                    if (isBuiltin) {
                        metaInfo = `Used ${item.usageCount}×`;
                    } else if (item.type === 'builtin-composition') {
                        // Built-in multi-stroke composition (like arrow)
                        typeLabel = '🔗';
                        const componentCount = item.componentCount || 2;
                        metaInfo = `${componentCount} strokes · ${item.usageCount}×`;
                    } else if (item.type === 'composition') {
                        // User-created multi-stroke composition
                        typeLabel = '🔗';
                        const connections = item.spatialGraph ? item.spatialGraph.connections.length : 0;
                        const componentCount = item.components ? item.components.length : 0;
                        metaInfo = `${componentCount} strokes · ${connections} conn · ${item.usageCount}×`;
                    } else if (item.components) {
                        // Legacy compound primitive from Day 2
                        typeLabel = '📦';
                        metaInfo = `${item.components.length} comp · ${item.usageCount}×`;
                    } else {
                        // Single stroke primitive
                        typeLabel = '✏️';
                        metaInfo = `1 stroke · ${item.usageCount}×`;
                    }

                    const deleteButton = !isBuiltin ? `<button class="delete-button" onclick="deleteLibraryItem('${key}')" title="Delete">×</button>` : '';

                    return `
                    <div class="library-item ${isBuiltin ? 'builtin' : ''}" data-key="${key}">
                        ${deleteButton}
                        <div class="library-item-thumbnail" id="thumb-${key}"></div>
                        <div class="library-item-info">
                            <div class="library-item-label">${typeLabel}${item.label}</div>
                            <div class="library-item-meta">${metaInfo}</div>
                        </div>
                    </div>
                `;
                }).join('');

                // Generate thumbnails for all items
                allItems.forEach(key => {
                    const thumbnailContainer = document.getElementById(`thumb-${key}`);
                    if (thumbnailContainer) {
                        const thumbnail = generateThumbnail(state.library[key]);
                        thumbnailContainer.appendChild(thumbnail);
                    }
                });
            }

            function showSavePrimitiveUI() {
                // Show the inline save primitive container (for "Something else" - single stroke)
                savePrimitiveContainer.classList.add('active');
                primitiveNameInput.value = '';
                primitiveNameInput.dataset.saveMode = 'single'; // Mark as single stroke save
                primitiveNameInput.focus();
            }

            function hideSavePrimitiveUI() {
                savePrimitiveContainer.classList.remove('active');
                primitiveNameInput.value = '';
            }

            function initiateLibrarySave() {
                // Called by "Save to Library" button
                // Saves ALL strokes on canvas as compound primitive
                if (state.strokes.length === 0) return;

                // Show inline save UI
                savePrimitiveContainer.classList.add('active');
                primitiveNameInput.value = '';
                primitiveNameInput.dataset.saveMode = 'compound'; // Mark as compound save
                primitiveNameInput.focus();
            }

            function confirmSavePrimitive() {
                const name = primitiveNameInput.value.trim();
                if (!name) {
                    primitiveNameInput.focus();
                    return;
                }

                const key = name.toLowerCase().replace(/\s+/g, '-');

                // Check if name already exists
                if (state.library[key]) {
                    // Show error inline instead of alert
                    primitiveNameInput.style.borderColor = '#ff5252';
                    primitiveNameInput.placeholder = 'Name already exists! Try another...';
                    primitiveNameInput.value = '';
                    primitiveNameInput.focus();
                    return;
                }

                const saveMode = primitiveNameInput.dataset.saveMode || 'single';

                if (saveMode === 'compound') {
                    // Save compound primitive (all strokes)
                    saveCompoundPrimitive(name, key);
                } else {
                    // Save single stroke primitive (from "Something else")
                    saveSingleStrokePrimitive(name, key);
                }

                hideSavePrimitiveUI();
                state.selectedStrokeIndex = null;
            }

            function saveSingleStrokePrimitive(name, key) {
                const strokeIndex = state.selectedStrokeIndex;
                if (strokeIndex === null || !state.strokes[strokeIndex]) return;

                const stroke = state.strokes[strokeIndex];

                // Use refined stroke if refinement is enabled and available
                const refinedStroke = state.refinedStrokes[strokeIndex];
                const strokeToSave = (state.refinement.enabled && refinedStroke) ? refinedStroke : stroke;

                const fingerprint = getFingerprint(strokeToSave);

                // PHASE 6A: Capture what this shape is based on (if any)
                const oldContext = state.context[strokeIndex];
                const builtinShapes = ['circle', 'rectangle', 'triangle', 'line', 'point'];
                const basedOn = builtinShapes.includes(oldContext) ? oldContext : null;

                state.library[key] = {
                    type: 'user-primitive',
                    label: name,
                    strokes: [strokeToSave],
                    fingerprint: fingerprint,
                    basedOn: basedOn,  // PHASE 6A: Reference to built-in shape (if any)
                    usageCount: 0,
                    created: Date.now()
                };

                // Update context to reference the new primitive
                state.context[strokeIndex] = key;
                state.library[key].usageCount++;

                saveLibrary();
                renderLibrary();
                render();
            }

            function saveCompoundPrimitive(name, key) {
                // Auto-accept any pending strokes as artN
                let artCounter = 0;
                state.strokes.forEach((stroke, idx) => {
                    if (!state.context[idx] || state.context[idx] === '') {
                        state.context[idx] = `art${artCounter}`;
                        // Mark shape as accepted
                        if (state.shapes[idx]) {
                            state.shapes[idx].accepted = true;
                        }
                        artCounter++;
                    }
                });

                // Build components array
                const components = state.strokes.map((stroke, idx) => {
                    const originalStroke = stroke;
                    const refinedStroke = state.refinedStrokes[idx] || null;
                    const recognizedAs = state.context[idx];
                    const fingerprint = getFingerprint(originalStroke);
                    const bounds = getBounds(originalStroke);

                    // Day 4: Extract type from recognizedAs (builtin or library key)
                    let type = 'unknown';
                    if (recognizedAs.startsWith('art')) {
                        type = 'art';  // Unnamed stroke
                    } else if (state.library[recognizedAs]) {
                        const libItem = state.library[recognizedAs];
                        type = libItem.shapeType || libItem.type || 'user-shape';
                    } else {
                        type = recognizedAs;  // Direct shape name (circle, line, etc.)
                    }

                    return {
                        strokeId: state.strokeIds[idx],  // PHASE 5.5C: Track stroke identity
                        originalStroke: originalStroke,
                        refinedStroke: refinedStroke,
                        recognizedAs: recognizedAs,
                        type: type,  // Day 4: for fingerprinting
                        fingerprint: fingerprint,
                        bounds: bounds
                    };
                });

                console.log('💾 Saving composition with components:', components.map(c => ({ type: c.type, recognizedAs: c.recognizedAs })));

                // Calculate overall bounds
                const allBounds = components.map(c => c.bounds);
                const overallBounds = {
                    minX: Math.min(...allBounds.map(b => b.minX)),
                    maxX: Math.max(...allBounds.map(b => b.maxX)),
                    minY: Math.min(...allBounds.map(b => b.minY)),
                    maxY: Math.max(...allBounds.map(b => b.maxY))
                };

                // Build spatial graph (Day 3)
                const spatialGraph = buildSpatialGraph(components);

                // Phase 3C: Create order-invariant composition fingerprint
                const compositionFingerprint = createCompositionFingerprint(components, spatialGraph);

                // FUZZY RELATIONSHIPS: Keep histogram but mark as fuzzy (not strict)
                // This enables proportional scoring instead of exact matching
                compositionFingerprint.fuzzyRelationships = true;

                // PHASE 6A: Create semantics for hierarchical composition description
                const semantics = {
                    componentTypes: components.map(c => c.type),
                    componentCount: components.length,
                    // Extract basedOn information from components if available
                    basedOnReferences: components.map(c => {
                        const recognizedAs = c.recognizedAs;
                        if (state.library[recognizedAs] && state.library[recognizedAs].basedOn) {
                            return state.library[recognizedAs].basedOn;
                        }
                        return recognizedAs;  // Use direct type if no basedOn
                    }).filter(r => r),
                    // Count each type for quick queries
                    typeCounts: components.reduce((counts, c) => {
                        counts[c.type] = (counts[c.type] || 0) + 1;
                        return counts;
                    }, {})
                };

                state.library[key] = {
                    type: 'composition',  // Day 3: distinct from primitives
                    label: name,
                    components: components,
                    strokeIds: components.map(c => c.strokeId),  // PHASE 5.5C: Top-level IDs for easy querying
                    semantics: semantics,  // PHASE 6A: Hierarchical description
                    overallBounds: overallBounds,
                    spatialGraph: spatialGraph,  // Day 3: properly generated
                    fingerprint: compositionFingerprint,  // Day 4: composition signature
                    usageCount: 0,
                    created: Date.now()
                };

                saveLibrary();
                renderLibrary();

                // Clear canvas after save
                state.strokes = [];
                state.strokeIds = [];  // PHASE 5.5C
                state.refinedStrokes = [];
                state.semanticData = [];
                state.context = [];
                state.currentStroke = [];
                state.suggestions = [];

                recognitionStatus.textContent = 'Waiting for stroke...';
                recognitionStatus.style.background = '#555';
                recognitionStatus.style.color = '#ccc';
                suggestionsDiv.innerHTML = '<button class="something-else-button disabled">Something else</button>';

                // Day 4: Clear composition matches after save
                updateCanvasLooksLike();

                render();
            }

            function cancelSavePrimitive() {
                hideSavePrimitiveUI();
                state.selectedStrokeIndex = null;
            }

            function deleteLibraryItem(key) {
                // Direct delete without confirmation for faster workflow
                delete state.library[key];
                saveLibrary();
                renderLibrary();
            }

            function saveLibrary() {
                try {
                    localStorage.setItem('metamedium_library_v1', JSON.stringify(state.library));
                } catch (e) {
                    console.error('Failed to save library:', e);
                }
            }

            function loadLibrary() {
                try {
                    const saved = localStorage.getItem('metamedium_library_v1');
                    if (saved) {
                        const loaded = JSON.parse(saved);
                        // Merge with built-ins (keep built-ins, add user items and compositions)
                        Object.keys(loaded).forEach(key => {
                            if (loaded[key].type === 'user-primitive' || loaded[key].type === 'composition') {
                                state.library[key] = loaded[key];
                            }
                        });
                    }
                } catch (e) {
                    console.error('Failed to load library:', e);
                }
            }

            function exportLibrary() {
                const dataStr = JSON.stringify(state.library, null, 2);
                const dataBlob = new Blob([dataStr], { type: 'application/json' });
                const url = URL.createObjectURL(dataBlob);
                const link = document.createElement('a');
                link.href = url;
                link.download = `metamedium-library-${Date.now()}.json`;
                link.click();
                URL.revokeObjectURL(url);
            }

            function compareFingerprints(fp1, fp2) {
                // Simple similarity score between two fingerprints
                let score = 0;
                let factors = 0;

                // Aspect ratio similarity
                const aspectDiff = Math.abs(fp1.aspectRatio - fp2.aspectRatio);
                score += Math.max(0, 1 - aspectDiff);
                factors++;

                // Straightness similarity
                const straightDiff = Math.abs(fp1.straightness - fp2.straightness);
                score += Math.max(0, 1 - straightDiff);
                factors++;

                // Closure match (binary)
                if (fp1.isClosed === fp2.isClosed) {
                    score += 1;
                }
                factors++;

                // Size similarity (normalized)
                if (fp1.size && fp2.size) {
                    const sizeDiff = Math.abs(fp1.size - fp2.size) / Math.max(fp1.size, fp2.size);
                    score += Math.max(0, 1 - sizeDiff);
                    factors++;
                }

                return score / factors; // 0-1 similarity
            }

            // Event Listeners for Library
            exportLibraryBtn.addEventListener('click', exportLibrary);

            // Inline save primitive UI event listeners
            confirmSaveBtn.addEventListener('click', confirmSavePrimitive);
            cancelSaveBtn.addEventListener('click', cancelSavePrimitive);

            primitiveNameInput.addEventListener('keydown', (e) => {
                if (e.key === 'Enter') {
                    confirmSavePrimitive();
                } else if (e.key === 'Escape') {
                    cancelSavePrimitive();
                }
            });

            // Reset input styling on typing
            primitiveNameInput.addEventListener('input', () => {
                primitiveNameInput.style.borderColor = '';
                primitiveNameInput.placeholder = 'Enter shape name...';
            });

            // Fuzzy match input listeners
            fuzzyMatchInput.addEventListener('input', handleFuzzyMatch);

            fuzzyMatchInput.addEventListener('keydown', (e) => {
                if (e.key === 'Enter') {
                    // DAY 5 FIX: Guard against accepting when no stroke is selected
                    if (state.selectedStrokeIndex === null) {
                        console.log('⚠️ No stroke selected, ignoring Enter key');
                        return;
                    }

                    // Accept first suggestion if available, otherwise trigger "something else"
                    if (state.suggestions && state.suggestions.length > 0) {
                        acceptSuggestion(state.suggestions[0]);
                    } else {
                        handleSomethingElse();
                    }
                } else if (e.key === 'Escape') {
                    // Clear fuzzy match input and restore normal suggestions
                    fuzzyMatchInput.value = '';
                    if (state.selectedStrokeIndex !== null && state.lastFingerprint) {
                        const analysis = analyzeStrokeDetailed(state.strokes[state.selectedStrokeIndex]);
                        showSuggestions(analysis);
                    }
                }
            });

            saveToLibraryBtn.addEventListener('click', initiateLibrarySave);

            // Show/Hide Library Row toggle
            showLibraryBtn.addEventListener('click', () => {
                libraryRow.classList.toggle('visible');
                showLibraryBtn.textContent = libraryRow.classList.contains('visible') ? 'Hide Library' : 'Show Library';
            });

            // Show/Hide Metrics Panel toggle
            showMetricsBtn.addEventListener('click', () => {
                metricsPanel.classList.toggle('visible');
                showMetricsBtn.textContent = metricsPanel.classList.contains('visible') ? 'Hide Metrics' : 'Show Metrics';
            });

            // Debug toggle button
            debugToggleBtn.addEventListener('click', () => {
                state.debugMode = !state.debugMode;
                debugCheckbox.checked = state.debugMode;
                debugToggleBtn.textContent = state.debugMode ? 'Debug On' : 'Debug Off';
                debugToggleBtn.classList.toggle('active', state.debugMode);
                render();
            });

            clearBtn.addEventListener('click', () => {
                // PHASE 5.5A: Capture state before clearing (for undo)
                const beforeState = captureState();

                // Clear all arrays
                state.shapes = [];          // DAY 5: Clear Shape objects
                state.strokes = [];
                state.strokeIds = [];       // PHASE 5.5C
                state.refinedStrokes = [];
                state.semanticData = [];
                state.tipDebugData = [];
                state.cornerDebugData = [];
                state.context = [];
                state.currentStroke = [];
                state.suggestions = [];     // DAY 5 FIX: Ensure suggestions cleared
                state.selectedStrokeIndex = null;
                state.lastFingerprint = null;  // DAY 5 FIX: Clear cached fingerprint

                metricsContent.innerHTML = '<div class="no-stroke-message">Draw a stroke to see metrics...</div>';
                recognitionStatus.textContent = 'Waiting for stroke...';
                recognitionStatus.style.background = '#555';
                recognitionStatus.style.color = '#ccc';
                suggestionsDiv.innerHTML = '<button class="something-else-button disabled">Something else</button>';
                hideSavePrimitiveUI();
                fuzzyMatchInput.value = '';
                fuzzyMatchInput.blur();  // DAY 5 FIX: Remove focus to prevent accidental Enter key

                // Day 4: Clear composition matches
                updateCanvasLooksLike();

                // PHASE 5.5A: Record action for undo
                const afterState = captureState();
                recordAction('clear-canvas', beforeState, afterState, {
                    strokesCleared: beforeState.strokes.length
                });

                render();
            });

            // Canvas input - Reserved for future commands
            canvasInput.addEventListener('keydown', (e) => {
                if (e.key === 'Enter') {
                    const typed = canvasInput.value.trim();
                    if (!typed) return;

                    // TODO: Handle commands here in future
                    // For now, just clear the input
                    canvasInput.value = '';
                } else if (e.key === 'Escape') {
                    canvasInput.value = '';
                }
            });

            // Refinement controls event listeners
            const refinementToggle = document.getElementById('refinementToggle');
            const smoothSlider = document.getElementById('smoothSlider');
            const smoothValue = document.getElementById('smoothValue');
            const simplifySlider = document.getElementById('simplifySlider');
            const simplifyValue = document.getElementById('simplifyValue');
            const normalizeToggle = document.getElementById('normalizeToggle');

            refinementToggle.addEventListener('click', () => {
                state.refinement.enabled = !state.refinement.enabled;
                refinementToggle.textContent = state.refinement.enabled ? 'Refine On' : 'Refine Off';
                refinementToggle.classList.toggle('active', state.refinement.enabled);
                updateRefinedStrokes();
                render();
            });

            smoothSlider.addEventListener('input', (e) => {
                state.refinement.smooth = parseInt(e.target.value);
                smoothValue.textContent = e.target.value;
                updateRefinedStrokes();
                render();
            });

            simplifySlider.addEventListener('input', (e) => {
                state.refinement.simplify = parseInt(e.target.value);
                simplifyValue.textContent = e.target.value;
                updateRefinedStrokes();
                render();
            });

            normalizeToggle.addEventListener('change', (e) => {
                state.refinement.normalize = e.target.checked;
                updateRefinedStrokes();
                render();
            });

            // Initialize refinement UI to match state defaults
            refinementToggle.textContent = state.refinement.enabled ? 'Refine On' : 'Refine Off';
            refinementToggle.classList.toggle('active', state.refinement.enabled);
            smoothSlider.value = state.refinement.smooth;
            smoothValue.textContent = state.refinement.smooth;
            simplifySlider.value = state.refinement.simplify;
            simplifyValue.textContent = state.refinement.simplify;
            normalizeToggle.checked = state.refinement.normalize;

            // PHASE 5.5A: Global keyboard shortcuts for undo/redo
            document.addEventListener('keydown', (e) => {
                // Cmd/Ctrl+Z for undo
                if ((e.metaKey || e.ctrlKey) && e.key === 'z' && !e.shiftKey) {
                    e.preventDefault();
                    const success = undo();
                    if (success) {
                        // Show brief feedback
                        recognitionStatus.textContent = 'Undid last action';
                        recognitionStatus.style.background = '#ff9800';
                        recognitionStatus.style.color = '#fff';
                        setTimeout(() => {
                            if (state.selectedStrokeIndex !== null) {
                                recognitionStatus.textContent = 'Select a suggestion or draw something else';
                            } else {
                                recognitionStatus.textContent = 'Waiting for stroke...';
                            }
                            recognitionStatus.style.background = '#555';
                            recognitionStatus.style.color = '#ccc';
                        }, 1000);
                    }
                }
                // Cmd/Ctrl+Shift+Z for redo
                else if ((e.metaKey || e.ctrlKey) && e.key === 'z' && e.shiftKey) {
                    e.preventDefault();
                    const success = redo();
                    if (success) {
                        // Show brief feedback
                        recognitionStatus.textContent = 'Redid last action';
                        recognitionStatus.style.background = '#4CAF50';
                        recognitionStatus.style.color = '#fff';
                        setTimeout(() => {
                            if (state.selectedStrokeIndex !== null) {
                                recognitionStatus.textContent = 'Select a suggestion or draw something else';
                            } else {
                                recognitionStatus.textContent = 'Waiting for stroke...';
                            }
                            recognitionStatus.style.background = '#555';
                            recognitionStatus.style.color = '#ccc';
                        }, 1000);
                    }
                }
            });

            // Update refined strokes based on current refinement settings
            function updateRefinedStrokes() {
                if (!state.refinement.enabled) {
                    state.refinedStrokes = [];
                    return;
                }

                state.refinedStrokes = state.strokes.map((stroke, idx) => {
                    // Don't overwrite accepted shapes - they keep their geometric refinement
                    const isAccepted = state.context[idx] && state.context[idx] !== '';
                    if (isAccepted && state.refinedStrokes[idx]) {
                        // Keep existing refined geometry for accepted shapes
                        return state.refinedStrokes[idx];
                    }

                    // Only apply manual refinement to unaccepted strokes
                    return applyRefinement(stroke, {
                        smooth: state.refinement.smooth,
                        simplify: state.refinement.simplify,
                        normalize: state.refinement.normalize,
                        normalizeSize: 200
                    });
                });
            }

            // Resize canvas to fill container
            function resizeCanvas() {
                const wrapper = canvas.parentElement;
                const rect = wrapper.getBoundingClientRect();

                // Account for input and padding
                const inputHeight = canvasInput.offsetHeight;
                const gap = 8; // gap between input and canvas
                const padding = 24; // wrapper padding (12px * 2)

                const availableWidth = rect.width - padding;
                const availableHeight = rect.height - inputHeight - gap - padding;

                // Set canvas display size (CSS pixels)
                canvas.style.width = availableWidth + 'px';
                canvas.style.height = availableHeight + 'px';

                // Set canvas resolution (drawing buffer)
                const dpr = window.devicePixelRatio || 1;
                canvas.width = availableWidth * dpr;
                canvas.height = availableHeight * dpr;

                // Scale context to handle high DPI
                ctx.scale(dpr, dpr);

                // Re-render after resize
                render();
            }

            // Initial setup
            loadLibrary();
            renderLibrary();
            updateCanvasLooksLike();  // Day 4: Initialize composition matching UI

            // Show library row by default
            libraryRow.classList.add('visible');
            showLibraryBtn.textContent = 'Hide Library';

            // Resize canvas once DOM is ready
            setTimeout(() => {
                resizeCanvas();
            }, 100);

            // Handle window resize
            window.addEventListener('resize', () => {
                resizeCanvas();
            });

            console.log('🎯 Doodle2.0 - Recombinatorial MetaMedium Drawing System');
            console.log('   ✓ Geometric type system (Point, Segment, Angle, Circle, Polygon)');
            console.log('   ✓ Convex hull & robust corner detection (Graham scan)');
            console.log('   ✓ Rotation-aware rectangle & triangle fitting');
            console.log('   ✓ Shape structure with formalism levels');
            console.log('   ✓ Spatial graph relationships');
            console.log('   ✓ Composition matching & semantic queries');
            console.log('   ✓ Undo/Redo with Ctrl+Z / Ctrl+Shift+Z');
            console.log('   🚀 Ready to draw!');

            // ===== PHASE 6B: SEMANTIC QUERY API =====
            // Console-accessible API for semantic queries about drawings and library

            window.query = {
                // Get all components currently on canvas with metadata
                getCurrentComponents: () => {
                    return state.strokes.map((stroke, idx) => ({
                        strokeId: state.strokeIds[idx],
                        recognizedAs: state.context[idx],
                        type: state.shapes[idx]?.type || 'unknown',
                        accepted: state.context[idx] !== '',
                        bounds: getBounds(stroke)
                    })).filter(c => c.accepted);
                },

                // Count shapes of a specific type on current canvas
                countType: (type) => {
                    const components = window.query.getCurrentComponents();
                    return components.filter(c =>
                        c.recognizedAs === type || c.type === type
                    ).length;
                },

                // Find all saved compositions containing a specific type
                findCompositions: (type) => {
                    const results = [];
                    Object.entries(state.library).forEach(([key, item]) => {
                        if (item.type === 'composition' && item.semantics) {
                            const hasType = item.semantics.componentTypes.includes(type) ||
                                item.semantics.basedOnReferences.includes(type);
                            if (hasType) {
                                results.push({
                                    name: item.label,
                                    key: key,
                                    componentCount: item.semantics.componentCount,
                                    typeCounts: item.semantics.typeCounts
                                });
                            }
                        }
                    });
                    return results;
                },

                // List all user primitives based on a specific built-in shape
                listBasedOn: (builtinType) => {
                    const results = [];
                    Object.entries(state.library).forEach(([key, item]) => {
                        if (item.type === 'user-primitive' && item.basedOn === builtinType) {
                            results.push({
                                name: item.label,
                                key: key,
                                basedOn: item.basedOn,
                                usageCount: item.usageCount
                            });
                        }
                    });
                    return results;
                },

                // Get semantic description of a composition
                getSemantics: (compositionName) => {
                    const key = compositionName.toLowerCase().replace(/\s+/g, '-');
                    const item = state.library[key];
                    if (!item || item.type !== 'composition') {
                        return null;
                    }
                    return item.semantics;
                },

                // Get full library structure
                getLibrary: () => {
                    return Object.entries(state.library).map(([key, item]) => ({
                        key: key,
                        label: item.label,
                        type: item.type,
                        basedOn: item.basedOn,
                        semantics: item.semantics,
                        usageCount: item.usageCount
                    }));
                },

                // Find all compositions that could be on current canvas (subset matching preview)
                detectPossibleCompositions: () => {
                    const components = window.query.getCurrentComponents();
                    const results = [];

                    Object.entries(state.library).forEach(([key, item]) => {
                        if (item.type === 'composition' && item.semantics) {
                            // Check if canvas has enough components of each type
                            let possible = true;
                            Object.entries(item.semantics.typeCounts).forEach(([type, count]) => {
                                const canvasCount = components.filter(c =>
                                    c.recognizedAs === type || c.type === type
                                ).length;
                                if (canvasCount < count) {
                                    possible = false;
                                }
                            });

                            if (possible) {
                                results.push({
                                    name: item.label,
                                    key: key,
                                    required: item.semantics.typeCounts,
                                    available: components.length
                                });
                            }
                        }
                    });

                    return results;
                },

                // Help text
                help: () => {
                    console.log('📊 SEMANTIC QUERY API (Phase 6B)');
                    console.log('================================');
                    console.log('');
                    console.log('Canvas Queries:');
                    console.log('  query.getCurrentComponents()     - Get all shapes on canvas');
                    console.log('  query.countType("circle")        - Count specific type on canvas');
                    console.log('');
                    console.log('Library Queries:');
                    console.log('  query.getLibrary()               - List all saved shapes');
                    console.log('  query.findCompositions("line")   - Find compositions with type');
                    console.log('  query.listBasedOn("circle")      - List shapes based on built-in');
                    console.log('  query.getSemantics("arrow")      - Get composition semantics');
                    console.log('');
                    console.log('Advanced:');
                    console.log('  query.detectPossibleCompositions() - Find possible matches on canvas');
                    console.log('');
                    console.log('Examples:');
                    console.log('  query.countType("circle")        → 3');
                    console.log('  query.findCompositions("triangle") → [{name: "Arrow", ...}]');
                    console.log('  query.listBasedOn("circle")      → [{name: "Bubble", ...}]');
                }
            };

            // Print help on load
            console.log('');
            console.log('💡 Tip: Type query.help() for semantic query API');
            console.log('');
        </script>
</body>

</html>