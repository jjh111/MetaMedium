<!DOCTYPE html>
<!--
MetaMedium - Recombinatorial Drawing System
Day 1 MVP: Primitive Recognition with Advanced Scoring

DELIVERABLE: Basic drawing with primitive shape recognition
- Draw circles, lines, rectangles, triangles
- 4-component weighted scoring system:
  * Corner Count (25%)
  * Angle Quality (25%)
  * Straightness (30%)
  * Aspect Ratio (20%)
- Real-time corner detection with angle analysis
- Diagnostic metrics panel for tuning
- Accept/reject suggestions with visual feedback

STATUS: ✅ Complete - Day 1 deliverable exceeds PRD spec
TECH: Vanilla JS, single-file, ~1200 lines
VERSION: v1.0-day1
DATE: October 16, 2025

NEXT: Copy to day2.html and add library system
-->
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>MetaMedium - Day 1: Primitive Recognition</title>
    <style>
        * {
            box-sizing: border-box;
        }
        
        body {
            margin: 0;
            padding: 0;
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', 'Roboto', sans-serif;
            background: #f5f5f5;
            color: #333;
        }
        
        .app {
            min-height: 100vh;
            display: flex;
            flex-direction: column;
        }
        
        .app-header {
            background: white;
            padding: 20px 40px;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
            text-align: center;
        }
        
        .app-header h1 {
            margin: 0;
            font-size: 28px;
            color: #333;
            font-weight: 600;
        }
        
        .app-header .subtitle {
            margin: 8px 0 0 0;
            font-size: 14px;
            color: #666;
        }
        
        .app-content {
            flex: 1;
            display: flex;
            gap: 20px;
            padding: 20px;
            position: relative;
        }
        
        /* Left panel - Metrics */
        .metrics-panel {
            width: 320px;
            background: white;
            padding: 20px;
            border-radius: 8px;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);
            overflow-y: auto;
            max-height: calc(100vh - 200px);
        }
        
        .metrics-panel h2 {
            margin: 0 0 16px 0;
            font-size: 18px;
            font-weight: 600;
            color: #333;
            border-bottom: 2px solid #0066ff;
            padding-bottom: 8px;
        }
        
        .metrics-section {
            margin-bottom: 20px;
        }
        
        .metrics-section h3 {
            margin: 0 0 12px 0;
            font-size: 14px;
            font-weight: 600;
            color: #666;
        }
        
        .metric-item {
            display: flex;
            justify-content: space-between;
            padding: 6px 0;
            border-bottom: 1px solid #f0f0f0;
            font-size: 13px;
        }
        
        .metric-label {
            color: #666;
            font-weight: 500;
        }
        
        .metric-value {
            color: #333;
            font-weight: 600;
            font-family: 'Courier New', monospace;
        }
        
        .condition-check {
            margin: 8px 0;
            padding: 8px 12px;
            border-radius: 4px;
            font-size: 12px;
        }
        
        .condition-check.pass {
            background: #e8f5e9;
            border-left: 4px solid #4caf50;
        }
        
        .condition-check.fail {
            background: #ffebee;
            border-left: 4px solid #f44336;
        }
        
        .condition-check .shape-name {
            font-weight: 600;
            margin-bottom: 4px;
        }
        
        .condition-check .reason {
            color: #666;
            font-size: 11px;
            margin-top: 4px;
        }
        
        /* Center - Canvas */
        .canvas-container {
            flex: 1;
            display: flex;
            flex-direction: column;
            gap: 16px;
            align-items: center;
            justify-content: center;
        }
        
        canvas {
            border: 2px solid #e0e0e0;
            border-radius: 8px;
            background: white;
            cursor: crosshair;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);
        }
        
        canvas:hover {
            border-color: #0066ff;
        }
        
        .controls {
            display: flex;
            gap: 16px;
            align-items: center;
        }
        
        .clear-button {
            padding: 10px 20px;
            background: #ff5252;
            color: white;
            border: none;
            border-radius: 6px;
            font-size: 14px;
            font-weight: 600;
            cursor: pointer;
            transition: background 0.2s ease;
        }
        
        .clear-button:hover {
            background: #ff1744;
        }
        
        .stroke-count {
            font-size: 14px;
            color: #666;
            font-weight: 500;
        }
        
        /* Right panel - Recognition */
        .recognition-panel {
            width: 300px;
            background: white;
            padding: 20px;
            border-radius: 8px;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);
        }
        
        .recognition-panel h2 {
            margin: 0 0 16px 0;
            font-size: 18px;
            font-weight: 600;
            color: #333;
            border-bottom: 2px solid #4caf50;
            padding-bottom: 8px;
        }
        
        .recognition-status {
            padding: 12px;
            background: #f5f5f5;
            border-radius: 6px;
            margin-bottom: 16px;
            text-align: center;
            font-size: 13px;
            color: #666;
        }
        
        .suggestions {
            display: flex;
            flex-direction: column;
            gap: 8px;
        }
        
        .suggestion-button {
            padding: 12px 16px;
            border: 2px solid #e0e0e0;
            border-radius: 6px;
            background: white;
            cursor: pointer;
            text-align: left;
            transition: all 0.2s ease;
            display: flex;
            flex-direction: column;
            gap: 4px;
        }
        
        .suggestion-button:hover {
            border-color: #0066ff;
            background: #f5f9ff;
        }
        
        .suggestion-button.disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }
        
        .suggestion-button .label {
            font-size: 14px;
            font-weight: 600;
            color: #333;
        }
        
        .suggestion-button .confidence {
            font-size: 12px;
            color: #666;
        }
        
        .suggestion-button .confidence.high {
            color: #4CAF50;
        }
        
        .suggestion-button .confidence.medium {
            color: #ff9800;
        }
        
        .something-else-button {
            padding: 12px 16px;
            border: 2px solid #0066ff;
            border-radius: 6px;
            background: #f5f9ff;
            cursor: pointer;
            text-align: center;
            color: #0066ff;
            font-weight: 600;
            transition: all 0.2s ease;
        }
        
        .something-else-button:hover {
            background: #e3f2fd;
            border-color: #0052cc;
        }
        
        .something-else-button.disabled {
            opacity: 0.5;
            cursor: not-allowed;
            border-color: #d0d0d0;
            background: #f5f5f5;
            color: #666;
        }
        
        .app-footer {
            background: white;
            padding: 16px 40px;
            text-align: center;
            border-top: 1px solid #e0e0e0;
        }
        
        .app-footer p {
            margin: 4px 0;
            font-size: 14px;
            color: #666;
        }
        
        .no-stroke-message {
            padding: 20px;
            text-align: center;
            color: #999;
            font-style: italic;
        }
    </style>
</head>
<body>
    <div class="app">
        <header class="app-header">
            <h1>Recombinatorial Drawing System</h1>
            <p class="subtitle">Day 1: Basic Drawing + Primitive Recognition v2.0 (Corner-Based Detection)</p>
        </header>

        <div class="app-content">
            <!-- Left: Metrics Panel -->
            <div class="metrics-panel">
                <h2>Recognition Metrics</h2>
                
                <div id="metricsContent" class="no-stroke-message">
                    Draw a stroke to see metrics...
                </div>
            </div>

            <!-- Center: Canvas -->
            <div class="canvas-container">
                <canvas id="canvas" width="700" height="500"></canvas>
                
                <div class="controls">
                    <button id="clearBtn" class="clear-button">Clear Canvas</button>
                    <div class="stroke-count">
                        Strokes: <span id="strokeCount">0</span> | Accepted: <span id="acceptedCount">0</span>
                    </div>
                </div>
            </div>

            <!-- Right: Recognition Panel -->
            <div class="recognition-panel">
                <h2>Suggestions</h2>
                
                <div id="recognitionStatus" class="recognition-status">
                    Waiting for stroke...
                </div>
                
                <div id="suggestions" class="suggestions">
                    <button class="something-else-button disabled">Something else</button>
                </div>
            </div>
        </div>

        <footer class="app-footer">
            <p><strong>Debug Mode:</strong> Left panel shows detailed recognition metrics. Right panel shows suggestions (always visible).</p>
            <p>Draw circles, lines, or rectangles. Watch the metrics to understand recognition logic.</p>
        </footer>
    </div>

    <script>
        console.log('Script loading...');

        // State
        const state = {
            strokes: [],
            currentStroke: [],
            context: [],
            isDrawing: false,
            suggestions: [],
            selectedStrokeIndex: null,
            lastFingerprint: null
        };

        // Elements
        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');
        const suggestionsDiv = document.getElementById('suggestions');
        const metricsContent = document.getElementById('metricsContent');
        const recognitionStatus = document.getElementById('recognitionStatus');
        const clearBtn = document.getElementById('clearBtn');
        const strokeCountSpan = document.getElementById('strokeCount');
        const acceptedCountSpan = document.getElementById('acceptedCount');

        // Utility functions
        function countCorners(points, angleThreshold = Math.PI / 3) {
            // Count significant direction changes (corners)
            // Angle threshold = 60 degrees (π/3) - catches hand-drawn corners
            if (points.length < 15) return { count: 0, angles: [] };

            const cornerPositions = [];
            const windowSize = 8; // Smaller window to catch sharper corners

            // Sample every 4 points to catch corners better
            for (let i = windowSize; i < points.length - windowSize; i += 4) {
                // Get vectors before and after this point
                const before = {
                    x: points[i].x - points[i - windowSize].x,
                    y: points[i].y - points[i - windowSize].y
                };
                const after = {
                    x: points[i + windowSize].x - points[i].x,
                    y: points[i + windowSize].y - points[i].y
                };

                // Calculate angle between vectors
                const dotProduct = before.x * after.x + before.y * after.y;
                const magBefore = Math.sqrt(before.x * before.x + before.y * before.y);
                const magAfter = Math.sqrt(after.x * after.x + after.y * after.y);

                if (magBefore === 0 || magAfter === 0) continue;

                const cosAngle = dotProduct / (magBefore * magAfter);
                const angle = Math.acos(Math.max(-1, Math.min(1, cosAngle)));

                // If angle > threshold (90 degrees), it's a sharp corner
                if (angle > angleThreshold) {
                    cornerPositions.push({ index: i, angle: angle });
                }
            }

            // Cluster corners - merge corners within 20 points of each other
            if (cornerPositions.length === 0) return { count: 0, angles: [] };

            const clusteredCorners = [cornerPositions[0]];
            for (let i = 1; i < cornerPositions.length; i++) {
                const lastCorner = clusteredCorners[clusteredCorners.length - 1];
                const distance = cornerPositions[i].index - lastCorner.index;

                if (distance > 20) {
                    // Far enough away, it's a new corner
                    clusteredCorners.push(cornerPositions[i]);
                } else if (cornerPositions[i].angle > lastCorner.angle) {
                    // Same cluster, but this corner is sharper - replace
                    clusteredCorners[clusteredCorners.length - 1] = cornerPositions[i];
                }
            }

            return {
                count: clusteredCorners.length,
                angles: clusteredCorners.map(c => c.angle)
            };
        }

        function analyzeCornerAngles(angles) {
            // Analyze the distribution of corner angles
            // Returns metrics useful for distinguishing rectangles from triangles
            // Handle undefined or empty arrays gracefully
            if (!angles || angles.length === 0) {
                return {
                    avgAngle: 0,
                    variance: 0,
                    consistency: 0,
                    rectangleLikeness: 0,
                    triangleLikeness: 0
                };
            }

            const avgAngle = angles.reduce((sum, a) => sum + a, 0) / angles.length;
            const variance = angles.reduce((sum, a) => sum + Math.pow(a - avgAngle, 2), 0) / angles.length;
            const stdDev = Math.sqrt(variance);

            // Consistency: how similar are all the angles? (0-1, higher = more consistent)
            const consistency = angles.length > 1 ? Math.max(0, 1 - stdDev / (Math.PI / 4)) : 1;

            // Check how "rectangle-like" the angles are (close to 90° = π/2)
            const rectangleLikeness = angles.reduce((sum, angle) => {
                const deviationFrom90 = Math.abs(angle - Math.PI / 2);
                // Score each corner: perfect 90° = 1, off by 45° = 0
                return sum + Math.max(0, 1 - deviationFrom90 / (Math.PI / 4));
            }, 0) / angles.length;

            // Check how "triangle-like" the angles are (more varied, typically sharper or wider than 90°)
            const triangleLikeness = angles.reduce((sum, angle) => {
                // Triangles typically have angles != 90°, often 60° or 120° external
                const deviationFrom90 = Math.abs(angle - Math.PI / 2);
                // Score higher if NOT near 90°
                return sum + Math.min(1, deviationFrom90 / (Math.PI / 6));
            }, 0) / angles.length;

            return {
                avgAngle,
                variance,
                consistency,
                rectangleLikeness,
                triangleLikeness
            };
        }

        function checkOvershoot(points, threshold = 50) {
            // Check if stroke passes near start point at any point
            // (not just at the end)
            if (points.length < 10) return false;
            
            const start = points[0];
            
            // Check last 30% of stroke for proximity to start
            const checkStart = Math.floor(points.length * 0.7);
            
            for (let i = checkStart; i < points.length; i++) {
                const distance = Math.sqrt(
                    Math.pow(points[i].x - start.x, 2) + 
                    Math.pow(points[i].y - start.y, 2)
                );
                
                if (distance < threshold) {
                    return true;
                }
            }
            
            return false;
        }

        function getBounds(points) {
            if (points.length === 0) return { minX: 0, maxX: 0, minY: 0, maxY: 0 };
            
            let minX = Infinity, maxX = -Infinity;
            let minY = Infinity, maxY = -Infinity;
            
            points.forEach(point => {
                minX = Math.min(minX, point.x);
                maxX = Math.max(maxX, point.x);
                minY = Math.min(minY, point.y);
                maxY = Math.max(maxY, point.y);
            });
            
            return { minX, maxX, minY, maxY };
        }

        function isStrokeClosed(points, threshold = 50) {
            if (points.length < 5) return false;
            
            const start = points[0];
            const end = points[points.length - 1];
            const distance = Math.sqrt(
                Math.pow(end.x - start.x, 2) + 
                Math.pow(end.y - start.y, 2)
            );
            
            // Check direct closure
            if (distance < threshold) return true;
            
            // Also consider size-relative closure
            const bounds = getBounds(points);
            const width = bounds.maxX - bounds.minX;
            const height = bounds.maxY - bounds.minY;
            const size = Math.max(width, height);
            const relativeGap = size > 0 ? distance / size : 1;
            
            if (relativeGap < 0.15) return true;
            
            // Check for overshoot (passes near start somewhere in last 30%)
            return checkOvershoot(points, threshold);
        }

        function calculateStraightness(points) {
            if (points.length < 2) return 0;
            
            const start = points[0];
            const end = points[points.length - 1];
            
            const directDistance = Math.sqrt(
                Math.pow(end.x - start.x, 2) + 
                Math.pow(end.y - start.y, 2)
            );
            
            let pathLength = 0;
            for (let i = 1; i < points.length; i++) {
                const dx = points[i].x - points[i-1].x;
                const dy = points[i].y - points[i-1].y;
                pathLength += Math.sqrt(dx * dx + dy * dy);
            }
            
            if (pathLength === 0) return 0;
            return directDistance / pathLength;
        }

        function getFingerprint(points) {
            const bounds = getBounds(points);
            const width = bounds.maxX - bounds.minX;
            const height = bounds.maxY - bounds.minY;
            const start = points[0];
            const end = points[points.length - 1];
            const endDistance = Math.sqrt(
                Math.pow(end.x - start.x, 2) +
                Math.pow(end.y - start.y, 2)
            );

            // Get corner data (count + angles)
            const cornerData = countCorners(points);
            const angleAnalysis = analyzeCornerAngles(cornerData.angles);

            return {
                aspectRatio: height === 0 ? 1 : width / height,
                straightness: calculateStraightness(points),
                isClosed: isStrokeClosed(points),
                closureDistance: endDistance,
                corners: cornerData.count,
                cornerAngles: cornerData.angles,
                angleAnalysis: angleAnalysis,
                bounds: bounds,
                size: Math.max(width, height),
                pointCount: points.length
            };
        }

        function analyzeStrokeDetailed(points) {
            const fp = getFingerprint(points);
            const results = [];
            const checks = [];

            // STRATEGY: Contextual scoring - weight evidence, find best fit
            // Each shape gets a score 0-100 based on how well fingerprint matches
            // Circle: 0-1 corners, closed, roundish, VERY curved (straightness < 0.2)
            // Triangle: 2-3 corners, closed, somewhat straight (0.3-0.7)
            // Rectangle: 3-4 corners, closed, somewhat straight (0.3-0.7)
            // Line: 0-2 corners, NOT closed, VERY straight (>0.65)
            
            // Triangle checks (add as new primitive!)
            const triangleChecks = {
                isClosed: fp.isClosed,
                hasThreeCorners: fp.corners >= 2 && fp.corners <= 3,  // 2-3 corners (hand-drawn may miss one)
                reasonableShape: fp.aspectRatio >= 0.3 && fp.aspectRatio <= 3.0
            };

            checks.push({
                shape: 'Triangle',
                passed: triangleChecks.isClosed && triangleChecks.hasThreeCorners && triangleChecks.reasonableShape,
                conditions: [
                    { test: 'Is closed?', pass: triangleChecks.isClosed, detail: `End distance: ${fp.closureDistance.toFixed(1)}px (checks overshoot too)` },
                    { test: 'Has 3 corners?', pass: triangleChecks.hasThreeCorners, detail: `Corners: ${fp.corners} (need: 2-3)` },
                    { test: 'Reasonable shape?', pass: triangleChecks.reasonableShape, detail: `Aspect: ${fp.aspectRatio.toFixed(2)} (need: 0.3-3.0)` }
                ]
            });

            if (triangleChecks.isClosed && triangleChecks.hasThreeCorners && triangleChecks.reasonableShape) {
                results.push({ type: 'triangle', confidence: 0.85, label: 'Triangle' });
            }
            
            // Rectangle checks
            const rectangleChecks = {
                isClosed: fp.isClosed,
                hasFourCorners: fp.corners >= 3 && fp.corners <= 4,  // 3-4 corners (hand-drawn may miss one)
                aspectRatioOk: fp.aspectRatio > 0.3 && fp.aspectRatio < 3.0
            };

            checks.push({
                shape: 'Rectangle',
                passed: rectangleChecks.isClosed && rectangleChecks.hasFourCorners && rectangleChecks.aspectRatioOk,
                conditions: [
                    { test: 'Is closed?', pass: rectangleChecks.isClosed, detail: `End distance: ${fp.closureDistance.toFixed(1)}px` },
                    { test: 'Has 4 corners?', pass: rectangleChecks.hasFourCorners, detail: `Corners: ${fp.corners} (need: 3-4)` },
                    { test: 'Reasonable shape?', pass: rectangleChecks.aspectRatioOk, detail: `Aspect: ${fp.aspectRatio.toFixed(2)} (need: 0.3-3.0)` }
                ]
            });

            if (rectangleChecks.isClosed && rectangleChecks.hasFourCorners && rectangleChecks.aspectRatioOk) {
                results.push({ type: 'rectangle', confidence: 0.8, label: 'Rectangle' });
            }
            
            // Circle checks - use overshoot for better closure detection
            const hasOvershoot = checkOvershoot(points);
            const circleChecks = {
                isClosed: fp.isClosed || hasOvershoot,  // Either exact closure OR passes near start
                fewCorners: fp.corners <= 1,  // Circles should have 0-1 corners max
                aspectRatioOk: Math.abs(fp.aspectRatio - 1) < 0.5,
                notStraight: fp.straightness < 0.5
            };

            checks.push({
                shape: 'Circle',
                passed: circleChecks.isClosed && circleChecks.fewCorners && circleChecks.aspectRatioOk && circleChecks.notStraight,
                conditions: [
                    { test: 'Is closed?', pass: circleChecks.isClosed, detail: `End: ${fp.closureDistance.toFixed(1)}px ${hasOvershoot ? '(overshoot ✓)' : ''}` },
                    { test: 'Few corners?', pass: circleChecks.fewCorners, detail: `Corners: ${fp.corners} (need: ≤1)` },
                    { test: 'Aspect ratio ~1?', pass: circleChecks.aspectRatioOk, detail: `Ratio: ${fp.aspectRatio.toFixed(2)} (need: 0.5-1.5)` },
                    { test: 'Is curved?', pass: circleChecks.notStraight, detail: `Straightness: ${fp.straightness.toFixed(2)} (need: <0.5)` }
                ]
            });

            if (circleChecks.isClosed && circleChecks.fewCorners && circleChecks.aspectRatioOk && circleChecks.notStraight) {
                results.push({ type: 'circle', confidence: 0.8, label: 'Circle' });
            }
            
            // Line checks
            const lineChecks = {
                isStraight: fp.straightness > 0.65,
                notClosed: !fp.isClosed,
                fewCorners: fp.corners <= 2
            };
            
            checks.push({
                shape: 'Line',
                passed: lineChecks.isStraight && lineChecks.notClosed && lineChecks.fewCorners,
                conditions: [
                    { test: 'Is straight?', pass: lineChecks.isStraight, detail: `Straightness: ${fp.straightness.toFixed(2)} (need: >0.65)` },
                    { test: 'Not closed?', pass: lineChecks.notClosed, detail: `End distance: ${fp.closureDistance.toFixed(1)}px` },
                    { test: 'Few corners?', pass: lineChecks.fewCorners, detail: `Corners: ${fp.corners} (need: ≤2)` }
                ]
            });
            
            if (lineChecks.isStraight && lineChecks.notClosed && lineChecks.fewCorners) {
                results.push({ type: 'line', confidence: 0.9, label: 'Line' });
            }

            // FEATURE-BASED WEIGHTED SCORING SYSTEM
            // Each shape scored on: Corner Match (40%) + Straightness (40%) + Aspect Ratio (20%)
            // Disqualifying features eliminate shapes entirely
            // Note: hasOvershoot already declared above for circle checks
            const scoredResults = [];
            const scoringDetails = { circle: {}, triangle: {}, rectangle: {}, line: {} };

            // Helper function to calculate component scores
            // New 4-component system: Corner Count (25%) + Angle Quality (25%) + Straightness (30%) + Aspect Ratio (20%)
            function calculateScore(cornerScore, angleScore, straightnessScore, aspectScore) {
                return Math.round(cornerScore * 0.25 + angleScore * 0.25 + straightnessScore * 0.30 + aspectScore * 0.20);
            }

            // Continuous scoring functions - map raw values to 0-100 smoothly
            function scoreCurviness(straightness) {
                // For circles: lower straightness = higher score
                // Ideal: 0 (completely curved) = 100
                // Disqualify: 0.3+ (too straight)
                if (straightness >= 0.3) return 0;
                return 100 * (1 - straightness / 0.3);
            }

            function scoreStraightness(straightness) {
                // For lines: higher straightness = higher score
                // Ideal: 1.0 (perfectly straight) = 100
                // Disqualify: <0.65 (too curved)
                if (straightness < 0.65) return 0;
                return 100 * ((straightness - 0.65) / (1.0 - 0.65));
            }

            function scoreRoundness(aspectRatio) {
                // For circles: closer to 1.0 = higher score
                // Ideal: 1.0 (perfect circle) = 100
                // Maximum deviation: 0.8 (score drops to 0)
                const deviation = Math.abs(aspectRatio - 1.0);
                if (deviation >= 0.8) return 0;
                return 100 * (1 - deviation / 0.8);
            }

            function scoreAspectRange(aspectRatio, minRatio, maxRatio) {
                // For shapes with acceptable aspect ranges
                // Penalty for being outside the comfortable range
                if (aspectRatio < minRatio) {
                    // Too thin
                    const deviation = minRatio - aspectRatio;
                    return Math.max(0, 100 - deviation * 100);
                } else if (aspectRatio > maxRatio) {
                    // Too wide
                    const deviation = aspectRatio - maxRatio;
                    return Math.max(0, 100 - deviation * 100);
                }
                return 100;
            }

            function scoreLineElongation(aspectRatio) {
                // For lines: more elongated = higher score
                // Ideal: very elongated (>5) = 100
                // Minimum acceptable: 2.0
                if (aspectRatio < 2.0) return 0;
                if (aspectRatio >= 5.0) return 100;
                // Linear scale from 2.0 to 5.0
                return ((aspectRatio - 2.0) / (5.0 - 2.0)) * 100;
            }

            // ===== CIRCLE SCORING =====
            let circleCornerScore = 0;
            let circleAngleScore = 0;
            let circleStraightnessScore = 0;
            let circleAspectScore = 0;
            let circleDisqualified = false;

            // 1. DISQUALIFYING: Must be closed
            scoringDetails.circle.closed = fp.isClosed || hasOvershoot;
            if (!scoringDetails.circle.closed) {
                circleDisqualified = true;
                scoringDetails.circle.closedPoints = 'DISQUALIFIED (not closed)';
            } else {
                scoringDetails.circle.closedPoints = '✓ closed';
            }

            // 2. CORNER COUNT SCORE (25%): 0-100 based on corner count
            if (fp.corners === 0) {
                circleCornerScore = 100;
                scoringDetails.circle.cornerScore = '100 (no corners)';
            } else if (fp.corners === 1) {
                circleCornerScore = 70;
                scoringDetails.circle.cornerScore = '70 (1 corner)';
            } else {
                circleCornerScore = 0;
                circleDisqualified = true;
                scoringDetails.circle.cornerScore = `0 (${fp.corners} corners)`;
            }

            // 3. ANGLE QUALITY SCORE (25%): For circles, no angles should exist
            if (fp.corners === 0) {
                circleAngleScore = 100;
                scoringDetails.circle.angleScore = '100 (smooth, no angles)';
            } else if (fp.corners === 1) {
                circleAngleScore = 50;
                scoringDetails.circle.angleScore = '50 (one angle detected)';
            } else {
                circleAngleScore = 0;
                scoringDetails.circle.angleScore = '0 (multiple angles)';
            }

            // 4. STRAIGHTNESS SCORE (30%): Must be curved (continuous scoring)
            circleStraightnessScore = scoreCurviness(fp.straightness);
            if (circleStraightnessScore === 0) {
                circleDisqualified = true;
                scoringDetails.circle.straightnessScore = `0 (too straight: ${fp.straightness.toFixed(3)})`;
            } else {
                scoringDetails.circle.straightnessScore = `${Math.round(circleStraightnessScore)} (straightness: ${fp.straightness.toFixed(3)})`;
            }

            // 5. ASPECT RATIO SCORE (20%): Roundness (continuous scoring)
            circleAspectScore = scoreRoundness(fp.aspectRatio);
            scoringDetails.circle.aspectScore = `${Math.round(circleAspectScore)} (ratio: ${fp.aspectRatio.toFixed(2)})`;

            const circleFinalScore = circleDisqualified ? 0 : calculateScore(circleCornerScore, circleAngleScore, circleStraightnessScore, circleAspectScore);
            scoringDetails.circle.total = circleFinalScore;
            scoringDetails.circle.breakdown = `(${Math.round(circleCornerScore)}×25% + ${Math.round(circleAngleScore)}×25% + ${Math.round(circleStraightnessScore)}×30% + ${Math.round(circleAspectScore)}×20%)`;

            scoredResults.push({
                type: 'circle',
                confidence: circleFinalScore / 100,
                label: 'Circle',
                score: circleFinalScore
            });

            // ===== TRIANGLE SCORING =====
            let triangleCornerScore = 0;
            let triangleAngleScore = 0;
            let triangleStraightnessScore = 0;
            let triangleAspectScore = 0;
            let triangleDisqualified = false;

            // 1. DISQUALIFYING: Must be closed
            scoringDetails.triangle.closed = fp.isClosed;
            if (!fp.isClosed) {
                triangleDisqualified = true;
                scoringDetails.triangle.closedPoints = 'DISQUALIFIED (not closed)';
            } else {
                scoringDetails.triangle.closedPoints = '✓ closed';
            }

            // 2. CORNER COUNT SCORE (25%): 0-100 based on corner count
            if (fp.corners === 3) {
                triangleCornerScore = 100;
                scoringDetails.triangle.cornerScore = `100 (exactly 3)`;
            } else if (fp.corners === 2) {
                triangleCornerScore = 85;
                scoringDetails.triangle.cornerScore = `85 (2 corners)`;
            } else if (fp.corners === 4) {
                triangleCornerScore = 40;
                scoringDetails.triangle.cornerScore = `40 (4 corners)`;
            } else {
                triangleCornerScore = 0;
                triangleDisqualified = true;
                scoringDetails.triangle.cornerScore = `0 (${fp.corners} corners)`;
            }

            // 3. ANGLE QUALITY SCORE (25%): Should NOT be 90° angles (triangle-like)
            if (!triangleDisqualified && fp.corners >= 2 && fp.corners <= 4) {
                // Base score from triangle-likeness (0-1 → 0-100)
                const baseLikeness = fp.angleAnalysis.triangleLikeness * 100;
                // Penalty from rectangle-likeness
                const rectPenalty = fp.angleAnalysis.rectangleLikeness * 30;
                triangleAngleScore = Math.max(0, Math.min(100, baseLikeness - rectPenalty));

                const avgAngleDeg = (fp.angleAnalysis.avgAngle * 180 / Math.PI).toFixed(0);
                scoringDetails.triangle.angleScore = `${Math.round(triangleAngleScore)} (avg: ${avgAngleDeg}°, tri-like: ${fp.angleAnalysis.triangleLikeness.toFixed(2)})`;
            } else {
                triangleAngleScore = 0;
                scoringDetails.triangle.angleScore = '0 (no valid angles)';
            }

            // 4. STRAIGHTNESS SCORE (30%): Corners imply straight edges
            if (fp.corners >= 2 && fp.corners <= 3) {
                // Has corners = has straight edges
                triangleStraightnessScore = 100;
                scoringDetails.triangle.straightnessScore = '100 (has corners = straight edges)';
            } else if (fp.straightness >= 0.3 && fp.straightness <= 0.7) {
                triangleStraightnessScore = 100;
                scoringDetails.triangle.straightnessScore = '100 (straight enough)';
            } else if (fp.straightness > 0.7) {
                triangleStraightnessScore = 70;
                scoringDetails.triangle.straightnessScore = '70 (too straight - line-like)';
            } else {
                triangleStraightnessScore = 0;
                triangleDisqualified = true;
                scoringDetails.triangle.straightnessScore = `0 (too curved: ${fp.straightness.toFixed(3)})`;
            }

            // 5. ASPECT RATIO SCORE (20%): Reasonable shape (continuous scoring)
            triangleAspectScore = scoreAspectRange(fp.aspectRatio, 0.3, 3.0);
            scoringDetails.triangle.aspectScore = `${Math.round(triangleAspectScore)} (ratio: ${fp.aspectRatio.toFixed(2)})`;

            const triangleFinalScore = triangleDisqualified ? 0 : calculateScore(triangleCornerScore, triangleAngleScore, triangleStraightnessScore, triangleAspectScore);
            scoringDetails.triangle.total = triangleFinalScore;
            scoringDetails.triangle.breakdown = `(${Math.round(triangleCornerScore)}×25% + ${Math.round(triangleAngleScore)}×25% + ${Math.round(triangleStraightnessScore)}×30% + ${Math.round(triangleAspectScore)}×20%)`;

            scoredResults.push({
                type: 'triangle',
                confidence: triangleFinalScore / 100,
                label: 'Triangle',
                score: triangleFinalScore
            });

            // ===== RECTANGLE SCORING =====
            let rectangleCornerScore = 0;
            let rectangleAngleScore = 0;
            let rectangleStraightnessScore = 0;
            let rectangleAspectScore = 0;
            let rectangleDisqualified = false;

            // 1. DISQUALIFYING: Must be closed
            scoringDetails.rectangle.closed = fp.isClosed;
            if (!fp.isClosed) {
                rectangleDisqualified = true;
                scoringDetails.rectangle.closedPoints = 'DISQUALIFIED (not closed)';
            } else {
                scoringDetails.rectangle.closedPoints = '✓ closed';
            }

            // 2. CORNER COUNT SCORE (25%): 0-100 based on corner count
            if (fp.corners === 4) {
                rectangleCornerScore = 100;
                scoringDetails.rectangle.cornerScore = `100 (exactly 4)`;
            } else if (fp.corners === 3) {
                rectangleCornerScore = 85;
                scoringDetails.rectangle.cornerScore = `85 (3 corners)`;
            } else if (fp.corners === 5) {
                rectangleCornerScore = 40;
                scoringDetails.rectangle.cornerScore = `40 (5 corners)`;
            } else {
                rectangleCornerScore = 0;
                rectangleDisqualified = true;
                scoringDetails.rectangle.cornerScore = `0 (${fp.corners} corners)`;
            }

            // 3. ANGLE QUALITY SCORE (25%): Should be ~90° angles (rectangle-like)
            if (!rectangleDisqualified && fp.corners >= 3 && fp.corners <= 5) {
                // Base score from rectangle-likeness (0-1 → 0-100)
                const baseLikeness = fp.angleAnalysis.rectangleLikeness * 100;
                // Penalty from triangle-likeness
                const triPenalty = fp.angleAnalysis.triangleLikeness * 30;
                rectangleAngleScore = Math.max(0, Math.min(100, baseLikeness - triPenalty));

                const avgAngleDeg = (fp.angleAnalysis.avgAngle * 180 / Math.PI).toFixed(0);
                scoringDetails.rectangle.angleScore = `${Math.round(rectangleAngleScore)} (avg: ${avgAngleDeg}°, rect-like: ${fp.angleAnalysis.rectangleLikeness.toFixed(2)})`;
            } else {
                rectangleAngleScore = 0;
                scoringDetails.rectangle.angleScore = '0 (no valid angles)';
            }

            // 4. STRAIGHTNESS SCORE (30%): Corners imply straight edges
            if (fp.corners >= 3 && fp.corners <= 4) {
                // Has corners = has straight edges
                rectangleStraightnessScore = 100;
                scoringDetails.rectangle.straightnessScore = '100 (has corners = straight edges)';
            } else if (fp.straightness >= 0.4 && fp.straightness <= 0.8) {
                rectangleStraightnessScore = 100;
                scoringDetails.rectangle.straightnessScore = '100 (straight enough)';
            } else if (fp.straightness > 0.8) {
                rectangleStraightnessScore = 70;
                scoringDetails.rectangle.straightnessScore = '70 (too straight - line-like)';
            } else {
                rectangleStraightnessScore = 0;
                rectangleDisqualified = true;
                scoringDetails.rectangle.straightnessScore = `0 (too curved: ${fp.straightness.toFixed(3)})`;
            }

            // 5. ASPECT RATIO SCORE (20%): Reasonable shape (continuous scoring)
            rectangleAspectScore = scoreAspectRange(fp.aspectRatio, 0.3, 3.0);
            scoringDetails.rectangle.aspectScore = `${Math.round(rectangleAspectScore)} (ratio: ${fp.aspectRatio.toFixed(2)})`;

            const rectangleFinalScore = rectangleDisqualified ? 0 : calculateScore(rectangleCornerScore, rectangleAngleScore, rectangleStraightnessScore, rectangleAspectScore);
            scoringDetails.rectangle.total = rectangleFinalScore;
            scoringDetails.rectangle.breakdown = `(${Math.round(rectangleCornerScore)}×25% + ${Math.round(rectangleAngleScore)}×25% + ${Math.round(rectangleStraightnessScore)}×30% + ${Math.round(rectangleAspectScore)}×20%)`;

            scoredResults.push({
                type: 'rectangle',
                confidence: rectangleFinalScore / 100,
                label: 'Rectangle',
                score: rectangleFinalScore
            });

            // ===== LINE SCORING =====
            let lineCornerScore = 0;
            let lineAngleScore = 0;
            let lineStraightnessScore = 0;
            let lineAspectScore = 0;
            let lineDisqualified = false;

            // 1. DISQUALIFYING: Must NOT be closed
            scoringDetails.line.notClosed = !fp.isClosed;
            if (fp.isClosed) {
                lineDisqualified = true;
                scoringDetails.line.closedPoints = 'DISQUALIFIED (lines must be open)';
            } else {
                scoringDetails.line.closedPoints = '✓ not closed';
            }

            // 2. CORNER COUNT SCORE (25%): 0-100 based on corner count
            if (fp.corners === 0) {
                lineCornerScore = 100;
                scoringDetails.line.cornerScore = '100 (no corners)';
            } else if (fp.corners <= 2) {
                lineCornerScore = 80;
                scoringDetails.line.cornerScore = `80 (${fp.corners} corners)`;
            } else {
                lineCornerScore = 0;
                lineDisqualified = true;
                scoringDetails.line.cornerScore = `0 (${fp.corners} corners)`;
            }

            // 3. ANGLE QUALITY SCORE (25%): Lines shouldn't have sharp angles
            if (fp.corners === 0) {
                lineAngleScore = 100;
                scoringDetails.line.angleScore = '100 (perfectly smooth)';
            } else if (fp.corners <= 2) {
                // Slight penalty for any angles
                lineAngleScore = 60;
                scoringDetails.line.angleScore = '60 (minor bends)';
            } else {
                lineAngleScore = 0;
                scoringDetails.line.angleScore = '0 (too many angles)';
            }

            // 4. STRAIGHTNESS SCORE (30%): MUST be very straight (continuous scoring)
            lineStraightnessScore = scoreStraightness(fp.straightness);
            if (lineStraightnessScore === 0) {
                lineDisqualified = true;
                scoringDetails.line.straightnessScore = `0 (too curved: ${fp.straightness.toFixed(3)})`;
            } else {
                scoringDetails.line.straightnessScore = `${Math.round(lineStraightnessScore)} (straightness: ${fp.straightness.toFixed(3)})`;
            }

            // 5. ASPECT RATIO SCORE (20%): Lines should be elongated (continuous scoring)
            lineAspectScore = scoreLineElongation(fp.aspectRatio);
            scoringDetails.line.aspectScore = `${Math.round(lineAspectScore)} (ratio: ${fp.aspectRatio.toFixed(2)})`;

            const lineFinalScore = lineDisqualified ? 0 : calculateScore(lineCornerScore, lineAngleScore, lineStraightnessScore, lineAspectScore);
            scoringDetails.line.total = lineFinalScore;
            scoringDetails.line.breakdown = `(${Math.round(lineCornerScore)}×25% + ${Math.round(lineAngleScore)}×25% + ${Math.round(lineStraightnessScore)}×30% + ${Math.round(lineAspectScore)}×20%)`;

            scoredResults.push({
                type: 'line',
                confidence: lineFinalScore / 100,
                label: 'Line',
                score: lineFinalScore
            });

            // Sort by score - show ALL shapes ranked, filter only scores > 20 for suggestions
            const finalResults = scoredResults.sort((a, b) => b.score - a.score);

            return {
                results: finalResults.length > 0 ? finalResults : results,
                fingerprint: fp,
                checks: checks,
                scoringDetails: scoringDetails
            };
        }

        function updateMetrics(analysis) {
            if (!analysis) {
                metricsContent.innerHTML = '<div class="no-stroke-message">Draw a stroke to see metrics...</div>';
                return;
            }
            
            const fp = analysis.fingerprint;
            
            let html = '<div class="metrics-section">';
            html += '<h3>Fingerprint Data</h3>';
            html += `<div class="metric-item"><span class="metric-label">Aspect Ratio</span><span class="metric-value">${fp.aspectRatio.toFixed(3)}</span></div>`;
            html += `<div class="metric-item"><span class="metric-label">Straightness</span><span class="metric-value">${fp.straightness.toFixed(3)}</span></div>`;
            html += `<div class="metric-item"><span class="metric-label">Corners</span><span class="metric-value">${fp.corners}</span></div>`;

            // Show corner angle details if corners exist
            if (fp.corners > 0 && fp.cornerAngles && fp.cornerAngles.length > 0) {
                const anglesDeg = fp.cornerAngles.map(a => (a * 180 / Math.PI).toFixed(0) + '°').join(', ');
                html += `<div class="metric-item"><span class="metric-label">Corner Angles</span><span class="metric-value">${anglesDeg}</span></div>`;
                html += `<div class="metric-item"><span class="metric-label">Avg Angle</span><span class="metric-value">${(fp.angleAnalysis.avgAngle * 180 / Math.PI).toFixed(0)}°</span></div>`;
                html += `<div class="metric-item"><span class="metric-label">Rect-like</span><span class="metric-value">${fp.angleAnalysis.rectangleLikeness.toFixed(2)}</span></div>`;
                html += `<div class="metric-item"><span class="metric-label">Tri-like</span><span class="metric-value">${fp.angleAnalysis.triangleLikeness.toFixed(2)}</span></div>`;
            }

            html += `<div class="metric-item"><span class="metric-label">Is Closed</span><span class="metric-value">${fp.isClosed ? 'Yes' : 'No'}</span></div>`;
            html += `<div class="metric-item"><span class="metric-label">End Distance</span><span class="metric-value">${fp.closureDistance.toFixed(1)}px</span></div>`;
            html += `<div class="metric-item"><span class="metric-label">Size</span><span class="metric-value">${fp.size.toFixed(0)}px</span></div>`;
            html += `<div class="metric-item"><span class="metric-label">Points</span><span class="metric-value">${fp.pointCount}</span></div>`;
            html += '</div>';
            
            html += '<div class="metrics-section">';
            html += '<h3>Weighted Scoring System</h3>';
            html += '<p style="font-size: 11px; color: #666; margin: 0 0 12px 0;">Each shape scored on: Corner Count (25%) + Angle Quality (25%) + Straightness (30%) + Aspect Ratio (20%)</p>';

            // Store scoring details for display
            if (analysis.scoringDetails) {
                const details = analysis.scoringDetails;

                // Circle details
                html += `<div class="condition-check" style="margin-bottom: 12px; background: #f9f9f9;">`;
                html += `<div class="shape-name" style="font-weight: bold; color: #333;">Circle: ${details.circle.total}/100</div>`;
                html += `<div class="reason" style="font-size: 11px;">`;
                html += `• Closed: ${details.circle.closedPoints}<br>`;
                html += `• Corner Count (25%): ${details.circle.cornerScore}<br>`;
                html += `• Angle Quality (25%): ${details.circle.angleScore}<br>`;
                html += `• Straightness (30%): ${details.circle.straightnessScore}<br>`;
                html += `• Aspect Ratio (20%): ${details.circle.aspectScore}<br>`;
                html += `<span style="color: #666; font-size: 10px;">${details.circle.breakdown}</span>`;
                html += `</div></div>`;

                // Triangle details
                html += `<div class="condition-check" style="margin-bottom: 12px; background: #f9f9f9;">`;
                html += `<div class="shape-name" style="font-weight: bold; color: #333;">Triangle: ${details.triangle.total}/100</div>`;
                html += `<div class="reason" style="font-size: 11px;">`;
                html += `• Closed: ${details.triangle.closedPoints}<br>`;
                html += `• Corner Count (25%): ${details.triangle.cornerScore}<br>`;
                html += `• Angle Quality (25%): ${details.triangle.angleScore}<br>`;
                html += `• Straightness (30%): ${details.triangle.straightnessScore}<br>`;
                html += `• Aspect Ratio (20%): ${details.triangle.aspectScore}<br>`;
                html += `<span style="color: #666; font-size: 10px;">${details.triangle.breakdown}</span>`;
                html += `</div></div>`;

                // Rectangle details
                html += `<div class="condition-check" style="margin-bottom: 12px; background: #f9f9f9;">`;
                html += `<div class="shape-name" style="font-weight: bold; color: #333;">Rectangle: ${details.rectangle.total}/100</div>`;
                html += `<div class="reason" style="font-size: 11px;">`;
                html += `• Closed: ${details.rectangle.closedPoints}<br>`;
                html += `• Corner Count (25%): ${details.rectangle.cornerScore}<br>`;
                html += `• Angle Quality (25%): ${details.rectangle.angleScore}<br>`;
                html += `• Straightness (30%): ${details.rectangle.straightnessScore}<br>`;
                html += `• Aspect Ratio (20%): ${details.rectangle.aspectScore}<br>`;
                html += `<span style="color: #666; font-size: 10px;">${details.rectangle.breakdown}</span>`;
                html += `</div></div>`;

                // Line details
                html += `<div class="condition-check" style="margin-bottom: 12px; background: #f9f9f9;">`;
                html += `<div class="shape-name" style="font-weight: bold; color: #333;">Line: ${details.line.total}/100</div>`;
                html += `<div class="reason" style="font-size: 11px;">`;
                html += `• Not closed: ${details.line.closedPoints}<br>`;
                html += `• Corner Count (25%): ${details.line.cornerScore}<br>`;
                html += `• Angle Quality (25%): ${details.line.angleScore}<br>`;
                html += `• Straightness (30%): ${details.line.straightnessScore}<br>`;
                html += `• Aspect Ratio (20%): ${details.line.aspectScore}<br>`;
                html += `<span style="color: #666; font-size: 10px;">${details.line.breakdown}</span>`;
                html += `</div></div>`;
            }

            html += '</div>';
            
            metricsContent.innerHTML = html;
        }

        // Rendering
        function render() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            
            // Draw completed strokes
            state.strokes.forEach((stroke, idx) => {
                const isAccepted = state.context[idx] && state.context[idx] !== '';
                ctx.strokeStyle = isAccepted ? '#0066ff' : '#666666';
                ctx.lineWidth = 2;
                ctx.lineCap = 'round';
                ctx.lineJoin = 'round';
                
                ctx.beginPath();
                stroke.forEach((point, i) => {
                    if (i === 0) ctx.moveTo(point.x, point.y);
                    else ctx.lineTo(point.x, point.y);
                });
                ctx.stroke();
            });
            
            // Draw current stroke
            if (state.currentStroke.length > 0) {
                ctx.strokeStyle = '#666666';
                ctx.lineWidth = 2;
                ctx.lineCap = 'round';
                ctx.lineJoin = 'round';
                
                ctx.beginPath();
                state.currentStroke.forEach((point, i) => {
                    if (i === 0) ctx.moveTo(point.x, point.y);
                    else ctx.lineTo(point.x, point.y);
                });
                ctx.stroke();
            }
            
            // Update counters
            strokeCountSpan.textContent = state.strokes.length;
            acceptedCountSpan.textContent = state.context.filter(c => c && c !== '').length;
        }

        function showSuggestions(analysis) {
            // Filter to show only reasonable matches (score > 20)
            const allResults = analysis.results;
            const suggestions = allResults.filter(r => r.score > 20);
            state.suggestions = suggestions;

            // Update status
            if (suggestions.length === 0) {
                recognitionStatus.textContent = 'No strong matches';
                recognitionStatus.style.background = '#fff3e0';
                recognitionStatus.style.color = '#e65100';
            } else {
                recognitionStatus.textContent = `Found ${suggestions.length} match${suggestions.length > 1 ? 'es' : ''}`;
                recognitionStatus.style.background = '#e8f5e9';
                recognitionStatus.style.color = '#2e7d32';
            }

            suggestionsDiv.innerHTML = '';

            if (suggestions.length > 0) {
                suggestions.forEach(sug => {
                    const btn = document.createElement('button');
                    btn.className = 'suggestion-button';
                    const score = sug.score || Math.round(sug.confidence * 100);
                    btn.innerHTML = `
                        <span class="label">${sug.label}</span>
                        <span class="confidence ${sug.confidence > 0.6 ? 'high' : 'medium'}">
                            ${score}/100 (${sug.confidence > 0.6 ? 'high' : 'medium'} confidence)
                        </span>
                    `;
                    btn.onclick = () => acceptSuggestion(sug);
                    suggestionsDiv.appendChild(btn);
                });
            }
            
            // Always show "Something else" button
            const elseBtn = document.createElement('button');
            elseBtn.className = 'something-else-button';
            elseBtn.textContent = 'Something else';
            elseBtn.onclick = handleSomethingElse;
            suggestionsDiv.appendChild(elseBtn);
        }

        function acceptSuggestion(suggestion) {
            if (state.selectedStrokeIndex === null) return;
            
            state.context[state.selectedStrokeIndex] = suggestion.type;
            state.selectedStrokeIndex = null;
            
            // Reset UI
            recognitionStatus.textContent = 'Waiting for stroke...';
            recognitionStatus.style.background = '#f5f5f5';
            recognitionStatus.style.color = '#666';
            
            suggestionsDiv.innerHTML = '<button class="something-else-button disabled">Something else</button>';
            
            render();
        }

        function handleSomethingElse() {
            if (state.selectedStrokeIndex === null) return;
            
            const customName = prompt('What should we call this?');
            if (customName) {
                state.context[state.selectedStrokeIndex] = customName;
                state.selectedStrokeIndex = null;
                
                // Reset UI
                recognitionStatus.textContent = 'Waiting for stroke...';
                recognitionStatus.style.background = '#f5f5f5';
                recognitionStatus.style.color = '#666';
                
                suggestionsDiv.innerHTML = '<button class="something-else-button disabled">Something else</button>';
                
                render();
            }
        }

        // Mouse events
        console.log('Attaching mouse events to canvas...');

        canvas.addEventListener('mousedown', (e) => {
            console.log('mousedown event triggered');
            const rect = canvas.getBoundingClientRect();
            const point = {
                x: e.clientX - rect.left,
                y: e.clientY - rect.top
            };
            state.isDrawing = true;
            state.currentStroke = [point];
            console.log('Started drawing, point:', point);
        });

        canvas.addEventListener('mousemove', (e) => {
            if (!state.isDrawing) return;
            
            const rect = canvas.getBoundingClientRect();
            const point = {
                x: e.clientX - rect.left,
                y: e.clientY - rect.top
            };
            state.currentStroke.push(point);
            render();
        });

        canvas.addEventListener('mouseup', () => {
            if (state.currentStroke.length > 0) {
                state.strokes.push([...state.currentStroke]);

                try {
                    // Analyze and show detailed results
                    const analysis = analyzeStrokeDetailed(state.currentStroke);
                    console.log('Analysis result:', analysis);
                    state.selectedStrokeIndex = state.strokes.length - 1;

                    updateMetrics(analysis);
                    showSuggestions(analysis);
                } catch (error) {
                    console.error('Error in analysis:', error);
                    alert('Error analyzing stroke: ' + error.message);
                }
            }
            state.isDrawing = false;
            state.currentStroke = [];
            render();
        });

        canvas.addEventListener('mouseleave', () => {
            if (state.isDrawing) {
                if (state.currentStroke.length > 0) {
                    state.strokes.push([...state.currentStroke]);
                    
                    const analysis = analyzeStrokeDetailed(state.currentStroke);
                    state.selectedStrokeIndex = state.strokes.length - 1;
                    
                    updateMetrics(analysis);
                    showSuggestions(analysis);
                }
                state.isDrawing = false;
                state.currentStroke = [];
                render();
            }
        });

        clearBtn.addEventListener('click', () => {
            state.strokes = [];
            state.context = [];
            state.currentStroke = [];
            state.suggestions = [];
            state.selectedStrokeIndex = null;
            
            metricsContent.innerHTML = '<div class="no-stroke-message">Draw a stroke to see metrics...</div>';
            recognitionStatus.textContent = 'Waiting for stroke...';
            recognitionStatus.style.background = '#f5f5f5';
            recognitionStatus.style.color = '#666';
            suggestionsDiv.innerHTML = '<button class="something-else-button disabled">Something else</button>';
            
            render();
        });

        // Initial render
        render();
    </script>
</body>
</html>
